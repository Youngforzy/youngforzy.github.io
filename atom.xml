<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZY&#39;s Blog</title>
  <subtitle>Young for you.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-07-21T06:27:07.133Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Z Yong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>多线程经典实例(二)</title>
    <link href="http://yoursite.com/2018/07/21/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BB%8F%E5%85%B8%E5%AE%9E%E4%BE%8B(%E4%BA%8C)/"/>
    <id>http://yoursite.com/2018/07/21/多线程经典实例(二)/</id>
    <published>2018-07-21T13:12:12.000Z</published>
    <updated>2018-07-21T06:27:07.133Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇文章<a href="http://youngforzy.top/2018/07/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BB%8F%E5%85%B8%E5%AE%9E%E4%BE%8B(%E4%B8%80" target="_blank" rel="external">多线程经典实例(一)</a>/) 讲到了几个多线程相关的例子，接下来我们来看一个经典的案例：生产者消费者问题。</p>
<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>生产者消费者问题是多线程中的一个经典问题，问题大概就是有一块缓冲区作为仓库，当仓库未满时生产者可以将产品放入仓库，当仓库未空时消费者可以从仓库取走产品。<strong>解决这个问题的核心就是处理好多线程之间的同步与协作。</strong></p>
<h4 id="生产者消费者的实现方式"><a href="#生产者消费者的实现方式" class="headerlink" title="生产者消费者的实现方式"></a>生产者消费者的实现方式</h4><p>通常有以下几种方式来实现生产者与消费者模型：</p>
<ol>
<li><strong>BlockingQueue 阻塞队列</strong></li>
<li><strong>wait()/notify()等待通知机制</strong></li>
<li><strong>Lock/Condition</strong></li>
<li><strong>管道流PipedOutputStream和PipedInputStream</strong></li>
</ol>
<h5 id="BlockingQueue实现"><a href="#BlockingQueue实现" class="headerlink" title="BlockingQueue实现"></a>BlockingQueue实现</h5><p>BlockingQueue是阻塞队列接口。它常用的几个实现如LinkedBlockingQueue、ArrayBlockingQueue等内部已经实现了同步队列，所以是线程安全的，所采用的原理是await()/singnal()方法。 </p>
<p>BlockingQueue中常见方法：</p>
<table>
<thead>
<tr>
<th>操作\情况</th>
<th>抛异常</th>
<th>特定值</th>
<th>阻塞</th>
<th>超时</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入元素</td>
<td>add(e)</td>
<td>offer(e)</td>
<td><strong>put()</strong></td>
<td>offer(e,timeout,unit)</td>
<td></td>
</tr>
<tr>
<td>移除元素</td>
<td>remove(e)</td>
<td>poll()</td>
<td><strong>take()</strong></td>
<td>poll(timeout,unit)</td>
<td></td>
</tr>
<tr>
<td>检查元素</td>
<td>element()</td>
<td>peek()</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>主要用到 put() 和 take() 方法：  </p>
<p><strong>当队列已满时调用 put() 方法会自动阻塞；<br>当队列为空时调用 take() 方法会自动阻塞。</strong><br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerAndConsumer2</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> BlockingQueue repertory = <span class="keyword">new</span> <span class="type">LinkedBlockingQueue</span>();</div><div class="line">    <span class="keyword">private</span> final int SIZE = <span class="number">5</span>;</div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Prodecer</span> <span class="keyword"><span class="keyword">implements</span> <span class="type">Runnable</span></span> </span>&#123;</div><div class="line">        @Override</div><div class="line">        <span class="keyword">public</span> void run() &#123;</div><div class="line">            <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    Thread.sleep(<span class="number">1000</span>); <span class="comment">//等待一段时间</span></div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">                synchronized (repertory) &#123;</div><div class="line">                    <span class="keyword">if</span> (repertory.size() == SIZE) &#123;</div><div class="line">                        System.out.println(<span class="string">"仓库已满！"</span>);</div><div class="line">                        <span class="keyword">return</span>;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        repertory.put(<span class="keyword">new</span> <span class="type">Object</span>());</div><div class="line">                        System.out.println(<span class="string">"线程："</span> + Thread.currentThread().getName() + <span class="string">"成功生产一个产品！产品总数： "</span> + repertory.size());</div><div class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                        System.out.println(<span class="string">"生产者生产失败！ "</span> + e.getMessage());</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword"><span class="keyword">implements</span> <span class="type">Runnable</span></span> </span>&#123;</div><div class="line">        @Override</div><div class="line">        <span class="keyword">public</span> void run() &#123;</div><div class="line">            <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    Thread.sleep(<span class="number">1000</span>); <span class="comment">//等待一段时间</span></div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">                synchronized (repertory) &#123;</div><div class="line">                    <span class="keyword">if</span> (repertory.isEmpty()) &#123;</div><div class="line">                        System.out.println(<span class="string">"仓库为空！"</span>);</div><div class="line">                        <span class="keyword">continue</span>;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        Object object = repertory.take();</div><div class="line">                        System.out.println(<span class="string">"线程："</span> + Thread.currentThread().getName() + <span class="string">"成功消费一个产品！当前仓库剩余产品："</span> + repertory.size());</div><div class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                        System.out.println(<span class="string">"消费者消费失败！ "</span> + e.getMessage());</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args) &#123;</div><div class="line">        ProducerAndConsumer2 test = <span class="keyword">new</span> <span class="type">ProducerAndConsumer2</span>();</div><div class="line">        <span class="keyword">new</span> <span class="type">Thread</span>(test.<span class="keyword">new</span> <span class="type">Prodecer</span>()).start();</div><div class="line">        <span class="keyword">new</span> <span class="type">Thread</span>(test.<span class="keyword">new</span> <span class="type">Prodecer</span>()).start();</div><div class="line">        <span class="keyword">new</span> <span class="type">Thread</span>(test.<span class="keyword">new</span> <span class="type">Prodecer</span>()).start();</div><div class="line">        <span class="keyword">new</span> <span class="type">Thread</span>(test.<span class="keyword">new</span> <span class="type">Consumer</span>()).start();</div><div class="line">        <span class="keyword">new</span> <span class="type">Thread</span>(test.<span class="keyword">new</span> <span class="type">Consumer</span>()).start();</div><div class="line">        <span class="keyword">new</span> <span class="type">Thread</span>(test.<span class="keyword">new</span> <span class="type">Consumer</span>()).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="wait-notify-实现"><a href="#wait-notify-实现" class="headerlink" title="wait()/notify()实现"></a>wait()/notify()实现</h5><figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerAndConsumer</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> LinkedList repertory = <span class="keyword">new</span> <span class="type">LinkedList</span>();</div><div class="line">    <span class="keyword">private</span> final int SIZE = <span class="number">8</span>;</div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Prodecer</span> <span class="keyword"><span class="keyword">implements</span> <span class="type">Runnable</span></span> </span>&#123;</div><div class="line">        @Override</div><div class="line">        <span class="keyword">public</span> void run() &#123;</div><div class="line">            <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">                synchronized (repertory) &#123;</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        Thread.sleep(<span class="number">1000</span>); <span class="comment">//等待一段时间</span></div><div class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">while</span> (repertory.size() == SIZE) &#123;</div><div class="line">                        System.out.println(<span class="string">"仓库已满！"</span>);</div><div class="line">                        <span class="keyword">try</span> &#123;</div><div class="line">                            repertory.wait(); <span class="comment">//生产者释放锁并阻塞，等待消费者消费</span></div><div class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                            e.printStackTrace();</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    repertory.add(<span class="keyword">new</span> <span class="type">Object</span>());</div><div class="line">                    System.out.println(<span class="string">"线程："</span> + Thread.currentThread().getName() + <span class="string">"成功生产一个产品！产品总数： "</span> + repertory.size());</div><div class="line">                    repertory.notifyAll();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword"><span class="keyword">implements</span> <span class="type">Runnable</span></span> </span>&#123;</div><div class="line">        @Override</div><div class="line">        <span class="keyword">public</span> void run() &#123;</div><div class="line">            <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    Thread.sleep(<span class="number">1000</span>); <span class="comment">//等待一段时间</span></div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">                synchronized (repertory) &#123;</div><div class="line">                    <span class="keyword">while</span> (repertory.size() == <span class="number">0</span>) &#123;</div><div class="line">                        System.out.println(<span class="string">"仓库为空！"</span>);</div><div class="line">                        <span class="keyword">try</span> &#123;</div><div class="line">                            repertory.wait();<span class="comment">//消费者释放锁并阻塞，等待生产者生产</span></div><div class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                            e.printStackTrace();</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    Object object = repertory.removeLast();</div><div class="line">                    System.out.println(<span class="string">"线程："</span> + Thread.currentThread().getName() + <span class="string">"成功消费一个产品！当前仓库剩余产品："</span> + repertory.size());</div><div class="line">                    repertory.notify();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args) &#123;</div><div class="line">        ProducerAndConsumer producerAndConsumer = <span class="keyword">new</span> <span class="type">ProducerAndConsumer</span>();</div><div class="line">        <span class="keyword">new</span> <span class="type">Thread</span>(producerAndConsumer.<span class="keyword">new</span> <span class="type">Prodecer</span>()).start();</div><div class="line">        <span class="keyword">new</span> <span class="type">Thread</span>(producerAndConsumer.<span class="keyword">new</span> <span class="type">Consumer</span>()).start();</div><div class="line">        <span class="keyword">new</span> <span class="type">Thread</span>(producerAndConsumer.<span class="keyword">new</span> <span class="type">Prodecer</span>()).start();</div><div class="line">        <span class="keyword">new</span> <span class="type">Thread</span>(producerAndConsumer.<span class="keyword">new</span> <span class="type">Consumer</span>()).start();</div><div class="line">        <span class="keyword">new</span> <span class="type">Thread</span>(producerAndConsumer.<span class="keyword">new</span> <span class="type">Prodecer</span>()).start();</div><div class="line">        <span class="keyword">new</span> <span class="type">Thread</span>(producerAndConsumer.<span class="keyword">new</span> <span class="type">Consumer</span>()).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">线程：Thread<span class="number">-0</span>成功生产一个产品！产品总数： <span class="number">1</span></div><div class="line">线程：Thread<span class="number">-0</span>成功生产一个产品！产品总数： <span class="number">2</span></div><div class="line">线程：Thread<span class="number">-0</span>成功生产一个产品！产品总数： <span class="number">3</span></div><div class="line">线程：Thread<span class="number">-0</span>成功生产一个产品！产品总数： <span class="number">4</span></div><div class="line">线程：Thread<span class="number">-0</span>成功生产一个产品！产品总数： <span class="number">5</span></div><div class="line">线程：Thread<span class="number">-5</span>成功消费一个产品！当前仓库剩余产品：<span class="number">4</span></div><div class="line">线程：Thread<span class="number">-1</span>成功消费一个产品！当前仓库剩余产品：<span class="number">3</span></div><div class="line">线程：Thread<span class="number">-3</span>成功消费一个产品！当前仓库剩余产品：<span class="number">2</span></div><div class="line">线程：Thread<span class="number">-4</span>成功生产一个产品！产品总数： <span class="number">3</span></div><div class="line">线程：Thread<span class="number">-4</span>成功生产一个产品！产品总数： <span class="number">4</span></div><div class="line">线程：Thread<span class="number">-4</span>成功生产一个产品！产品总数： <span class="number">5</span></div><div class="line">线程：Thread<span class="number">-4</span>成功生产一个产品！产品总数： <span class="number">6</span></div><div class="line">线程：Thread<span class="number">-4</span>成功生产一个产品！产品总数： <span class="number">7</span></div><div class="line">线程：Thread<span class="number">-2</span>成功生产一个产品！产品总数： <span class="number">8</span></div><div class="line">仓库已满！</div><div class="line">线程：Thread<span class="number">-3</span>成功消费一个产品！当前仓库剩余产品：<span class="number">7</span></div><div class="line">线程：Thread<span class="number">-1</span>成功消费一个产品！当前仓库剩余产品：<span class="number">6</span></div><div class="line">线程：Thread<span class="number">-5</span>成功消费一个产品！当前仓库剩余产品：<span class="number">5</span></div><div class="line">线程：Thread<span class="number">-2</span>成功生产一个产品！产品总数： <span class="number">6</span></div><div class="line">线程：Thread<span class="number">-2</span>成功生产一个产品！产品总数： <span class="number">7</span></div><div class="line">线程：Thread<span class="number">-2</span>成功生产一个产品！产品总数： <span class="number">8</span></div><div class="line">仓库已满！</div><div class="line">线程：Thread<span class="number">-5</span>成功消费一个产品！当前仓库剩余产品：<span class="number">7</span></div><div class="line">线程：Thread<span class="number">-1</span>成功消费一个产品！当前仓库剩余产品：<span class="number">6</span></div><div class="line">线程：Thread<span class="number">-3</span>成功消费一个产品！当前仓库剩余产品：<span class="number">5</span></div><div class="line">线程：Thread<span class="number">-2</span>成功生产一个产品！产品总数： <span class="number">6</span></div><div class="line">线程：Thread<span class="number">-5</span>成功消费一个产品！当前仓库剩余产品：<span class="number">5</span></div><div class="line">线程：Thread<span class="number">-1</span>成功消费一个产品！当前仓库剩余产品：<span class="number">4</span></div><div class="line">线程：Thread<span class="number">-3</span>成功消费一个产品！当前仓库剩余产品：<span class="number">3</span></div><div class="line">线程：Thread<span class="number">-3</span>成功消费一个产品！当前仓库剩余产品：<span class="number">2</span></div><div class="line">线程：Thread<span class="number">-5</span>成功消费一个产品！当前仓库剩余产品：<span class="number">1</span></div><div class="line">线程：Thread<span class="number">-1</span>成功消费一个产品！当前仓库剩余产品：<span class="number">0</span></div></pre></td></tr></table></figure>
<h5 id="Lock-Condition实现"><a href="#Lock-Condition实现" class="headerlink" title="Lock/Condition实现"></a>Lock/Condition实现</h5><figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerAndConsumer3</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> LinkedList repertory = <span class="keyword">new</span> <span class="type">LinkedList</span>(); <span class="comment">//仓库</span></div><div class="line">    <span class="keyword">private</span> final int SIZE = <span class="number">5</span>;</div><div class="line">    <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> <span class="type">ReentrantLock</span>();</div><div class="line">    <span class="keyword">private</span> Condition notFull = lock.<span class="keyword">new</span><span class="type">Condition</span>(); <span class="comment">//与生产者绑定</span></div><div class="line">    <span class="keyword">private</span> Condition notEmpty = lock.<span class="keyword">new</span><span class="type">Condition</span>();<span class="comment">//与消费者绑定</span></div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Prodecer</span> <span class="keyword"><span class="keyword">implements</span> <span class="type">Runnable</span></span> </span>&#123;</div><div class="line">        @Override</div><div class="line">        <span class="keyword">public</span> void run() &#123;</div><div class="line">            <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    Thread.sleep(<span class="number">1000</span>); <span class="comment">//等待一段时间</span></div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">                lock.lock();</div><div class="line">                <span class="keyword">try</span>&#123;</div><div class="line">                    <span class="keyword">while</span> (repertory.size() == SIZE) &#123;</div><div class="line">                        System.out.println(<span class="string">"仓库已满！"</span>);</div><div class="line">                        <span class="keyword">try</span> &#123;</div><div class="line">                            notFull.await(); <span class="comment">//阻塞生产者</span></div><div class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                            e.printStackTrace();</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">//仓库未满</span></div><div class="line">                    repertory.add(<span class="keyword">new</span> <span class="type">Object</span>());<span class="comment">//添加产品</span></div><div class="line">                    System.out.println(<span class="string">"线程："</span> + Thread.currentThread().getName() + <span class="string">"成功生产一个产品！产品总数： "</span> + repertory.size());</div><div class="line">                    notEmpty.signal();<span class="comment">//唤醒消费者</span></div><div class="line">                &#125; finally &#123;</div><div class="line">                    lock.unlock();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword"><span class="keyword">implements</span> <span class="type">Runnable</span></span> </span>&#123;</div><div class="line">        @Override</div><div class="line">        <span class="keyword">public</span> void run() &#123;</div><div class="line">            <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    Thread.sleep(<span class="number">1000</span>); <span class="comment">//等待一段时间</span></div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">                lock.lock();</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    <span class="keyword">while</span> (repertory.isEmpty()) &#123;</div><div class="line">                        System.out.println(<span class="string">"仓库为空！"</span>);</div><div class="line">                        <span class="keyword">try</span> &#123;</div><div class="line">                            notEmpty.await();<span class="comment">//阻塞消费者</span></div><div class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                            e.printStackTrace();</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">//仓库不为空</span></div><div class="line">                    Object object = repertory.removeLast(); <span class="comment">//取出产品</span></div><div class="line">                    System.out.println(<span class="string">"线程："</span> + Thread.currentThread().getName() + <span class="string">"成功消费一个产品！当前仓库剩余产品："</span> + repertory.size());</div><div class="line">                    notFull.signal();<span class="comment">//唤醒生产者</span></div><div class="line">                &#125; finally &#123;</div><div class="line">                    lock.unlock();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args) &#123;</div><div class="line">        ProducerAndConsumer3 test = <span class="keyword">new</span> <span class="type">ProducerAndConsumer3</span>();</div><div class="line">        <span class="keyword">new</span> <span class="type">Thread</span>(test.<span class="keyword">new</span> <span class="type">Prodecer</span>()).start();</div><div class="line">        <span class="keyword">new</span> <span class="type">Thread</span>(test.<span class="keyword">new</span> <span class="type">Prodecer</span>()).start();</div><div class="line">        <span class="keyword">new</span> <span class="type">Thread</span>(test.<span class="keyword">new</span> <span class="type">Prodecer</span>()).start();</div><div class="line">        <span class="keyword">new</span> <span class="type">Thread</span>(test.<span class="keyword">new</span> <span class="type">Consumer</span>()).start();</div><div class="line">        <span class="keyword">new</span> <span class="type">Thread</span>(test.<span class="keyword">new</span> <span class="type">Consumer</span>()).start();</div><div class="line">        <span class="keyword">new</span> <span class="type">Thread</span>(test.<span class="keyword">new</span> <span class="type">Consumer</span>()).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="管道流PipedOutputStream和PipedInputStream"><a href="#管道流PipedOutputStream和PipedInputStream" class="headerlink" title="管道流PipedOutputStream和PipedInputStream"></a>管道流PipedOutputStream和PipedInputStream</h5><p>在Java IO 包中，PipedOutputStream和PipedInputStream分别是管道输出流和管道输入流，可以利用它们来实现多线程之间的通信。<br><strong>主要通信流程</strong>：</p>
<ol>
<li>建立输入输出流</li>
<li>绑定输入输出流</li>
<li>向缓冲区写数据</li>
<li>读取缓冲区数据  </li>
</ol>
<p><strong>原理：<br>线程A向PipedOutputStream中写入数据，这些数据会自动的发送到与PipedOutputStream对应的PipedInputStream中，进而存储在PipedInputStream的缓冲区中；此时，线程B可以读取PipedInputStream中的数据，这样就实现了线程A和线程B的通信。</strong></p>
<ul>
<li>当这个缓冲数组已满的时候，输出流PipedOutputStream所在的线程将阻塞；</li>
<li>当这个缓冲数组首次为空的时候，输入流PipedInputStream所在的线程将阻塞。</li>
<li>“管道输入流”的缓冲数组大小默认只有1024个字节。</li>
</ul>
<p>注意：这里无法实现多生产者和多消费者的场景。<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> class ProducerAndConsumer4 &#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> PipedOutputStream pos = <span class="keyword">new</span> PipedOutputStream();<span class="comment">//管道输出流—生产者写数据</span></div><div class="line">    <span class="keyword">private</span> PipedInputStream pis = <span class="keyword">new</span> PipedInputStream();<span class="comment">//管道输入流-消费者读数据</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">    </div><div class="line">    class Prodecer implements Runnable &#123;</div><div class="line">        @Override</div><div class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">run</span>() &#123;</div><div class="line">            <span class="built_in">try</span> &#123;</div><div class="line">                <span class="built_in">while</span> (count &lt; <span class="number">5</span>) &#123; <span class="comment">//循环5次停止</span></div><div class="line">                    Thread.sleep(<span class="number">1000</span>); <span class="comment">//等待一段时间</span></div><div class="line">                    <span class="keyword">String</span> product = <span class="string">"zy的产品！"</span>;</div><div class="line">                    System.out.<span class="built_in">println</span>(<span class="string">"线程："</span> + Thread.currentThread().getName() + <span class="string">"成功生产一个产品！"</span>);</div><div class="line">                    count++;</div><div class="line">                    pos.<span class="built_in">write</span>(product.getBytes()); <span class="comment">//写入管道</span></div><div class="line">                    pos.<span class="built_in">flush</span>();</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="built_in">catch</span> (Exception e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125; finally &#123;</div><div class="line">                <span class="built_in">try</span> &#123;</div><div class="line">                    pos.<span class="built_in">close</span>();</div><div class="line">                &#125; <span class="built_in">catch</span> (IOException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    class Consumer implements Runnable &#123;</div><div class="line">        @Override</div><div class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">run</span>() &#123;</div><div class="line">            <span class="built_in">try</span> &#123;</div><div class="line">                <span class="built_in">while</span> (count &lt; <span class="number">5</span>) &#123;</div><div class="line">                    Thread.sleep(<span class="number">1000</span>); <span class="comment">//等待一段时间</span></div><div class="line">                    <span class="keyword">byte</span>[] <span class="built_in">buffer</span> = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</div><div class="line">                    <span class="keyword">int</span> len = pis.<span class="built_in">read</span>(<span class="built_in">buffer</span>); <span class="comment">//读取管道中的数据，存入缓冲区</span></div><div class="line">                    <span class="keyword">String</span> product = <span class="keyword">new</span> <span class="keyword">String</span>(<span class="built_in">buffer</span>, <span class="number">0</span>, len);</div><div class="line">                    System.out.<span class="built_in">println</span>(<span class="string">"线程："</span> + Thread.currentThread().getName() + <span class="string">"成功消费一个产品："</span> + product);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="built_in">catch</span> (Exception e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125; finally &#123;</div><div class="line">                <span class="built_in">try</span> &#123;</div><div class="line">                    pis.<span class="built_in">close</span>();</div><div class="line">                &#125; <span class="built_in">catch</span> (IOException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</div><div class="line">        ProducerAndConsumer4 test = <span class="keyword">new</span> ProducerAndConsumer4();</div><div class="line">        <span class="built_in">try</span> &#123;</div><div class="line">            test.pis.<span class="built_in">connect</span>(test.pos); <span class="comment">//管道连接</span></div><div class="line">        &#125; <span class="built_in">catch</span> (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">new</span> Thread(test.<span class="keyword">new</span> Prodecer()).start();</div><div class="line">        <span class="keyword">new</span> Thread(test.<span class="keyword">new</span> Consumer()).start();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>   除此之外，当然还有其他方式可以实现，如Semaphore。<br>以上就是实现生产者消费者的几个实例。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇文章&lt;a href=&quot;http://youngforzy.top/2018/07/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BB%8F%E5%85%B8%E5%AE%9E%E4%BE%8B(%E4%B8%80&quot; target=&quot;_blank&quot;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>多线程经典实例(一)</title>
    <link href="http://yoursite.com/2018/07/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BB%8F%E5%85%B8%E5%AE%9E%E4%BE%8B(%E4%B8%80)/"/>
    <id>http://yoursite.com/2018/07/20/多线程经典实例(一)/</id>
    <published>2018-07-20T13:12:12.000Z</published>
    <updated>2018-07-20T13:23:19.698Z</updated>
    
    <content type="html"><![CDATA[<p>在多线程的学习当中，有许多经典的例子值得学习，比如售票窗口、线程交替执行、生产者消费者等。下面就来看两个有关线程交替执行的案例。</p>
<h4 id="两个线程轮流打印数字"><a href="#两个线程轮流打印数字" class="headerlink" title="两个线程轮流打印数字"></a>两个线程轮流打印数字</h4><p>这里采用 wait/notify 等待通知和 Lock/Condition 两种方式实现。</p>
<h5 id="wait-notify-实现"><a href="#wait-notify-实现" class="headerlink" title="wait()/notify()实现"></a>wait()/notify()实现</h5><p>简单介绍一下wait/notify机制的几个方法。<br>以下4个方法都必须在<strong>获取了锁的情况下</strong>才能调用：  </p>
<p><strong>wait()</strong>: 使当前线程进入阻塞等待状态，直到被唤醒或中断; 调用后立即释放已有的锁；<br><strong>wait(Long times)</strong>: 使当前线程进入阻塞等待状态一段时间，超过时间后自动唤醒；<br><strong>notify()</strong>： 唤醒在该对象上等待的一个线程；<br><strong>notifyAll()</strong>： 唤醒在该对象上等待的所有线程。  </p>
<p>释放锁的场景主要有3种：</p>
<ol>
<li><strong>执行完同步方法/代码块</strong></li>
<li><strong>执行同步方法/代码块的过程中遇到异常</strong></li>
<li><strong>执行同步方法/代码块的过程中调用了锁对象的wait()方法</strong></li>
</ol>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TurnsPrintNumber</span> &#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object <span class="keyword">lock</span> = <span class="keyword">new</span> Object(); <span class="comment">//锁</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Print</span> <span class="title">implements</span> <span class="title">Runnable</span>&#123;</div><div class="line">        @<span class="function">Override</span></div><div class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) &#123;</div><div class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</div><div class="line">                synchronized (<span class="keyword">lock</span>) &#123;</div><div class="line">                    <span class="keyword">if</span> ( i &gt; <span class="number">20</span>) &#123;</div><div class="line">                        System.<span class="keyword">out</span>.println(<span class="string">"打印完毕！"</span>);</div><div class="line">                        <span class="keyword">lock</span>.notify();</div><div class="line">                        <span class="keyword">return</span>;</div><div class="line">                    &#125;</div><div class="line">                    System.<span class="keyword">out</span>.println(<span class="string">"线程"</span> + Thread.currentThread().getName() + <span class="string">"打印："</span>  + i ++ );</div><div class="line">                    <span class="keyword">lock</span>.notify();</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        Thread.sleep(<span class="number">100</span>);</div><div class="line">                        <span class="keyword">lock</span>.wait();</div><div class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</div><div class="line">        Print print = <span class="keyword">new</span> Print();</div><div class="line">        <span class="keyword">new</span> Thread(print).start();</div><div class="line">        <span class="keyword">new</span> Thread(print).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="Lock-Condition实现"><a href="#Lock-Condition实现" class="headerlink" title="Lock/Condition实现"></a>Lock/Condition实现</h5><p><strong>对于同一个锁（Lock对象）可以创建多个Condition，以便在不同的情况下使用不同的Condition。意思就是Condition可以明确指定唤醒哪一个线程。</strong><br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">TurnsPrintNumber2</span> &#123;</span></div><div class="line"></div><div class="line">    private static ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</div><div class="line">    private Condition a = lock.newCondition();</div><div class="line">    private Condition b = lock.newCondition();</div><div class="line">    static int i = <span class="number">1</span>;</div><div class="line"></div><div class="line">    private <span class="literal">void</span> <span class="built_in">print</span> () &#123;</div><div class="line">        <span class="keyword">new</span> Thread<span class="function"><span class="params">(() -&gt;&#123;</span></span></div><div class="line">            <span class="keyword">while</span> (i &lt; <span class="number">20</span>) &#123;</div><div class="line">                lock.lock();</div><div class="line">                System.out.println(<span class="string">"线程1打印： "</span> + i++);</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    a.await(); <span class="regexp">//将线程1从运行状态-&gt;阻塞等待</span></div><div class="line">                    b.signal();//唤醒线程<span class="number">2</span></div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                    lock.unlock();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;).<span class="title">start</span><span class="params">()</span>;</div><div class="line"></div><div class="line">        <span class="title">new</span> <span class="title">Thread</span><span class="params">(() -&gt;&#123;</span></div><div class="line">            <span class="keyword">while</span> (i &lt; <span class="number">20</span>) &#123;</div><div class="line">                lock.lock();</div><div class="line">                System.out.println(<span class="string">"线程2打印： "</span> + i++);</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    a.signal();</div><div class="line">                    b.await();</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                    lock.unlock();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;).<span class="title">start</span><span class="params">()</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="title">public</span> <span class="title">static</span> <span class="title">void</span> <span class="title">main</span><span class="params">(String[] args)</span> &#123;</div><div class="line">        <span class="title">new</span> <span class="title">TurnsPrintNumber2</span><span class="params">()</span>.<span class="title">print</span><span class="params">()</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="三个线程轮流打印-ABC"><a href="#三个线程轮流打印-ABC" class="headerlink" title="三个线程轮流打印 ABC"></a>三个线程轮流打印 ABC</h4><p>线程1 打印 A，线程2 打印 B，线程3 打印 C， 线程1 打印 A………..</p>
<p>采用以下3种方式实现：</p>
<ol>
<li><strong>wait()/notify()方式</strong></li>
<li><strong>Lock/Condition方式</strong></li>
<li><strong>Semaphore信号量方式</strong></li>
</ol>
<h5 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h5><p><strong>要在3个线程间实现轮流打印的操作，最重要的就是要控制3个线程的执行顺序。也就是要确定等待、唤醒的顺序，所以每一个线程必须同时持有两个对象锁，才能继续执行。</strong></p>
<h5 id="wait-notify-实现-1"><a href="#wait-notify-实现-1" class="headerlink" title="wait()/notify()实现"></a>wait()/notify()实现</h5><figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> class TurnsPrintABCWaitNotify &#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">Object</span> alock = <span class="keyword">new</span> <span class="keyword">Object</span>();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">Object</span> block = <span class="keyword">new</span> <span class="keyword">Object</span>();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">Object</span> clock = <span class="keyword">new</span> <span class="keyword">Object</span>();</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</div><div class="line"></div><div class="line">        <span class="keyword">new</span> Thread(() -&gt;&#123;</div><div class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">            <span class="keyword">synchronized</span> (alock) &#123;  <span class="comment">//先获取 A 的锁</span></div><div class="line">                <span class="keyword">synchronized</span> (block) &#123; <span class="comment">//再获取 B 的锁</span></div><div class="line">                    System.out.<span class="built_in">println</span>(<span class="string">"线程1打印：A"</span>);</div><div class="line">                    block.notify();    <span class="comment">//唤醒 B</span></div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (i == <span class="number">5</span>)&#123;<span class="keyword">return</span>;&#125;<span class="comment">//打印5次后结束</span></div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        alock.wait();  <span class="comment">//释放 A 的锁，进入等待阻塞</span></div><div class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;).start();</div><div class="line"></div><div class="line">        <span class="keyword">new</span> Thread(() -&gt;&#123;</div><div class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">                <span class="keyword">synchronized</span> (block) &#123;</div><div class="line">                    <span class="keyword">synchronized</span> (clock) &#123;</div><div class="line">                        System.out.<span class="built_in">println</span>(<span class="string">"线程2打印：B"</span>);</div><div class="line">                        clock.notifyAll();</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        block.wait();</div><div class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;).start();</div><div class="line"></div><div class="line">        <span class="keyword">new</span> Thread(() -&gt;&#123;</div><div class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">                <span class="keyword">synchronized</span> (clock) &#123;</div><div class="line">                    <span class="keyword">synchronized</span> (alock) &#123;</div><div class="line">                        System.out.<span class="built_in">println</span>(<span class="string">"线程3打印：C"</span>);</div><div class="line">                        alock.notifyAll();</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        clock.wait();</div><div class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;).start();</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="Lock-Condition实现-1"><a href="#Lock-Condition实现-1" class="headerlink" title="Lock/Condition实现"></a>Lock/Condition实现</h5><figure class="highlight livescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">TurnsPrintABCLock</span> &#123;</span></div><div class="line"></div><div class="line">    private static ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</div><div class="line">    private Condition a = lock.newCondition();</div><div class="line">    private Condition b = lock.newCondition();</div><div class="line">    private Condition c = lock.newCondition();</div><div class="line">    int i = <span class="number">1</span>;</div><div class="line"></div><div class="line">    private <span class="literal">void</span> <span class="built_in">print</span> () &#123;</div><div class="line">        <span class="keyword">new</span> Thread<span class="function"><span class="params">(() -&gt;&#123;</span></span></div><div class="line">            <span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123;</div><div class="line">                lock.lock();</div><div class="line">                System.out.println(<span class="string">"线程1打印： "</span> + <span class="string">"A"</span>);</div><div class="line">                i++;</div><div class="line">                <span class="keyword">if</span> (i &gt;= <span class="number">10</span>) &#123;</div><div class="line">                    System.out.println(<span class="string">"打印完毕！"</span>);</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    b.signal(); <span class="regexp">//唤醒线程2</span></div><div class="line">                    a.await(); //将线程<span class="number">1</span>从运行状态-&gt;阻塞等待</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                    lock.unlock();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;).<span class="title">start</span><span class="params">()</span>;</div><div class="line"></div><div class="line">        <span class="title">try</span> &#123;</div><div class="line">            <span class="title">Thread</span>.<span class="title">sleep</span><span class="params">(<span class="number">100</span>)</span>;</div><div class="line">        &#125; <span class="title">catch</span> <span class="params">(InterruptedException e)</span> &#123;</div><div class="line">            <span class="title">e</span>.<span class="title">printStackTrace</span><span class="params">()</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="title">new</span> <span class="title">Thread</span><span class="params">(() -&gt;&#123;</span></div><div class="line">            <span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123;</div><div class="line">                lock.lock();</div><div class="line">                System.out.println(<span class="string">"线程2打印： "</span> +  <span class="string">"B"</span>);</div><div class="line">                i++;</div><div class="line">                <span class="keyword">if</span> (i &gt;= <span class="number">10</span>) &#123;</div><div class="line">                    System.out.println(<span class="string">"打印完毕！"</span>);</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    c.signal();</div><div class="line">                    b.await();</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                    lock.unlock();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;).<span class="title">start</span><span class="params">()</span>;</div><div class="line"></div><div class="line">        <span class="title">try</span> &#123;</div><div class="line">            <span class="title">Thread</span>.<span class="title">sleep</span><span class="params">(<span class="number">100</span>)</span>;</div><div class="line">        &#125; <span class="title">catch</span> <span class="params">(InterruptedException e)</span> &#123;</div><div class="line">            <span class="title">e</span>.<span class="title">printStackTrace</span><span class="params">()</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="title">new</span> <span class="title">Thread</span><span class="params">(() -&gt;&#123;</span></div><div class="line">            <span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123;</div><div class="line">                lock.lock();</div><div class="line">                System.out.println(<span class="string">"线程3打印： "</span> +  <span class="string">"C"</span>);</div><div class="line">                i++;</div><div class="line">                <span class="keyword">if</span> (i &gt;= <span class="number">10</span>) &#123;</div><div class="line">                    System.out.println(<span class="string">"打印完毕！"</span>);</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    a.signal();</div><div class="line">                    c.await();</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                    lock.unlock();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;).<span class="title">start</span><span class="params">()</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="title">public</span> <span class="title">static</span> <span class="title">void</span> <span class="title">main</span><span class="params">(String[] args)</span> &#123;</div><div class="line">        <span class="title">new</span> <span class="title">TurnsPrintABCLock</span><span class="params">()</span>.<span class="title">print</span><span class="params">()</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="Semaphore信号量实现"><a href="#Semaphore信号量实现" class="headerlink" title="Semaphore信号量实现"></a>Semaphore信号量实现</h5><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">TurnsPrintABCSemaphore</span> </span>&#123;</div><div class="line">    <span class="comment">// A初始信号量数量为1</span></div><div class="line">    <span class="keyword">private</span> static <span class="type">Semaphore</span> <span class="type">A</span> = <span class="keyword">new</span> <span class="type">Semaphore</span>(<span class="number">1</span>);</div><div class="line">    <span class="comment">// B、C初始信号数量为0</span></div><div class="line">    <span class="keyword">private</span> static <span class="type">Semaphore</span> <span class="type">B</span> = <span class="keyword">new</span> <span class="type">Semaphore</span>(<span class="number">0</span>);</div><div class="line">    <span class="keyword">private</span> static <span class="type">Semaphore</span> <span class="type">C</span> = <span class="keyword">new</span> <span class="type">Semaphore</span>(<span class="number">0</span>);</div><div class="line"></div><div class="line">    static <span class="class"><span class="keyword">class</span> <span class="title">ThreadA</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        public void run() &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">                    <span class="type">A</span>.acquire();<span class="comment">// A获取信号执行,A信号量减1,当A为0时将无法继续获得该信号量</span></div><div class="line">                    <span class="type">System</span>.out.println(<span class="string">"线程1打印： "</span> + <span class="string">"A"</span>);</div><div class="line">                    <span class="type">B</span>.release();</div><div class="line">                    <span class="comment">//System.out.println(B.drainPermits());//B释放之后信号量加1（初始为0），可以查看到 B 的信号量为1</span></div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">catch</span> (<span class="type">InterruptedException</span> e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    static <span class="class"><span class="keyword">class</span> <span class="title">ThreadB</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        public void run() &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">                    <span class="type">B</span>.acquire();</div><div class="line">                    <span class="type">System</span>.out.println(<span class="string">"线程2打印： "</span> + <span class="string">"B"</span>);</div><div class="line">                    <span class="type">C</span>.release();</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">catch</span> (<span class="type">InterruptedException</span> e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    static <span class="class"><span class="keyword">class</span> <span class="title">ThreadC</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        public void run() &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">                    <span class="type">C</span>.acquire();</div><div class="line">                    <span class="type">System</span>.out.println(<span class="string">"线程3打印： "</span> + <span class="string">"C"</span>);</div><div class="line">                    <span class="type">A</span>.release();</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">catch</span> (<span class="type">InterruptedException</span> e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(<span class="type">String</span>[] args) <span class="keyword">throws</span> <span class="type">InterruptedException</span> &#123;</div><div class="line">        <span class="keyword">new</span> <span class="type">ThreadA</span>().start();</div><div class="line">        <span class="keyword">new</span> <span class="type">ThreadB</span>().start();</div><div class="line">        <span class="keyword">new</span> <span class="type">ThreadC</span>().start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上就是有关多个线程交替执行的例子。</p>
<h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><p>如何保证线程的顺序执行？比如有a，b，c三个线程，如何保证a执行完再执行b，b执行完再执行c？</p>
<ol>
<li>Join</li>
<li>线程池（newSingleThreadExecutor）</li>
<li>CountDownLatch/Semaphore</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在多线程的学习当中，有许多经典的例子值得学习，比如售票窗口、线程交替执行、生产者消费者等。下面就来看两个有关线程交替执行的案例。&lt;/p&gt;
&lt;h4 id=&quot;两个线程轮流打印数字&quot;&gt;&lt;a href=&quot;#两个线程轮流打印数字&quot; class=&quot;headerlink&quot; title=&quot;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出ThreadLocal的实现原理</title>
    <link href="http://yoursite.com/2018/07/02/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAThreadLocal%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2018/07/02/深入浅出ThreadLocal的实现原理/</id>
    <published>2018-07-02T06:12:12.000Z</published>
    <updated>2018-07-14T12:18:30.518Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ThreadLocal的简介"><a href="#ThreadLocal的简介" class="headerlink" title="ThreadLocal的简介"></a>ThreadLocal的简介</h3><p>ThreadLocal称为线程局部变量。在每个线程中都有自己独立的ThreadLocal变量。<br>每个线程中可有多个threadLocal变量。</p>
<h3 id="ThreadLocal的用法"><a href="#ThreadLocal的用法" class="headerlink" title="ThreadLocal的用法"></a>ThreadLocal的用法</h3><figure class="highlight livescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalDemo</span> &#123;</span></div><div class="line"></div><div class="line">    private static ThreadLocal&lt;Integer&gt; threadLocal1 = <span class="keyword">new</span> ThreadLocal&lt;Integer&gt;();</div><div class="line">    private static ThreadLocal&lt;String&gt; threadLocal2 = <span class="keyword">new</span> ThreadLocal&lt;String&gt;()&#123;</div><div class="line">        @Override</div><div class="line">        protected String initialValue() &#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">"默认值"</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    public static <span class="literal">void</span> main(String[] args) &#123;</div><div class="line"></div><div class="line">        int temp = <span class="number">100</span>;</div><div class="line">        <span class="keyword">new</span> Thread<span class="function"><span class="params">(() -&gt;&#123;</span></span></div><div class="line">            threadLocal1.set(temp + <span class="number">1</span>);</div><div class="line">            threadLocal2.set(<span class="string">"线程A"</span>);</div><div class="line">            System.out.println(<span class="string">"线程:"</span> +Thread.currentThread().getName() + <span class="string">"中 threadLocal1 的值为： "</span> +  threadLocal1.get());</div><div class="line">            System.out.println(<span class="string">"线程:"</span> +Thread.currentThread().getName() + <span class="string">"中 threadLocal2 的值为： "</span> +  threadLocal2.get());</div><div class="line">        &#125;).<span class="title">start</span><span class="params">()</span>;</div><div class="line"></div><div class="line">        <span class="title">new</span> <span class="title">Thread</span><span class="params">(() -&gt;&#123;</span></div><div class="line">            threadLocal1.set(temp - <span class="number">1</span>);</div><div class="line">            System.out.println(<span class="string">"线程:"</span> +Thread.currentThread().getName() + <span class="string">"中 threadLocal1 的值为： "</span> +  threadLocal1.get());</div><div class="line">            System.out.println(<span class="string">"线程:"</span> +Thread.currentThread().getName() + <span class="string">"中 threadLocal2 的值为： "</span> + threadLocal2.get());</div><div class="line">        &#125;).<span class="title">start</span><span class="params">()</span>;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">线程<span class="symbol">:Thread-</span><span class="number">0</span>中 threadLocal1 的值为： <span class="number">101</span></div><div class="line">线程<span class="symbol">:Thread-</span><span class="number">0</span>中 threadLocal2 的值为： 线程A</div><div class="line">线程<span class="symbol">:Thread-</span><span class="number">1</span>中 threadLocal1 的值为： <span class="number">99</span></div><div class="line">线程<span class="symbol">:Thread-</span><span class="number">1</span>中 threadLocal2 的值为： 默认值</div></pre></td></tr></table></figure></p>
<p>可以看到每个线程都保存着自己独立的变量threadLocal1、threadLocal2，互不影响。</p>
<p><strong>ThreadLocal实例通常定义成 static 变量，因此每个线程都能访问到该实例。</strong></p>
<p>抛出问题：为什么每个线程通过ThreadLocal实例时可以拿到自己设置的值？是如何实现的？</p>
<h3 id="ThreadLocal-的实现原理"><a href="#ThreadLocal-的实现原理" class="headerlink" title="ThreadLocal 的实现原理"></a>ThreadLocal 的实现原理</h3><p>ThreadLocal类主要有四个方法set()、get()、remove()、setInitialValue()，要想了解它的实现原理，那么就来看看这几个主要方法是如何实现的。</p>
<h4 id="set-方法"><a href="#set-方法" class="headerlink" title="set() 方法"></a>set() 方法</h4><figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="literal">void</span> <span class="built_in">set</span>(T value) &#123;</div><div class="line">        <span class="keyword">Thread</span> t = <span class="keyword">Thread</span>.currentThread();</div><div class="line">        ThreadLocalMap <span class="built_in">map</span> = getMap(t);</div><div class="line">        <span class="keyword">if</span> (<span class="built_in">map</span> != <span class="built_in">null</span>)</div><div class="line">            <span class="built_in">map</span>.<span class="built_in">set</span>(this, value);</div><div class="line">        <span class="keyword">else</span></div><div class="line">            createMap(t, value);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h5 id="getMap-获取ThreadLocalMap"><a href="#getMap-获取ThreadLocalMap" class="headerlink" title="getMap(): 获取ThreadLocalMap"></a>getMap(): 获取ThreadLocalMap</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> t.threadLocals;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><strong>threadLocals变量在线程Thread类中定义：</strong><br><figure class="highlight nix"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ThreadLocal.ThreadLocalMap <span class="attr">threadLocals</span> = <span class="literal">null</span>;</div></pre></td></tr></table></figure></p>
<p>每个线程都有一个threadLocals变量即ThreadLocalMap对象，ThreadLocalMap类是ThreadLocal类的静态内部类，用来存储相应的值，总之就是一个Map，后面会详细讲到。</p>
<h5 id="createMap-new-一个ThreadLocalMap"><a href="#createMap-new-一个ThreadLocalMap" class="headerlink" title="createMap(): new 一个ThreadLocalMap"></a>createMap(): new 一个ThreadLocalMap</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</div><div class="line">        t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>set()方法的过程如下：  </p>
<p><strong>1. 当前线程调用ThreadLocal.set()方法时，首先获取当前线程对象t;</strong>  </p>
<p><strong>2. 通过当前线程对象t获取到t线程中的threadLocals，即ThreadLocalMap</strong></p>
<ul>
<li>如果ThreadLocalMap存在，那么更新value，key为当前ThreadLocal对象;</li>
<li>如果ThreadLocalMap不存在，那么就根据当前线程对象t创建一个ThreadLocalMap，并将value存入。</li>
</ul>
<p>到这里，基本就能回答开头所提出的的问题，大体上知道了ThreadLocal的实现原理。再来看get()方法的实现。</p>
<h4 id="get-方法"><a href="#get-方法" class="headerlink" title="get() 方法"></a>get() 方法</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> T <span class="keyword">get</span>() &#123;</div><div class="line">        Thread t = Thread.currentThread();</div><div class="line">        ThreadLocalMap map = getMap(t);</div><div class="line">        <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</div><div class="line">            ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</div><div class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</div><div class="line">                <span class="meta">@SuppressWarnings(<span class="meta-string">"unchecked"</span>)</span></div><div class="line">                T result = (T)e.value;</div><div class="line">                <span class="keyword">return</span> result;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> setInitialValue();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>从上面可以看到，当调用get() 方法时，实际上就是先从当前线程中获取ThreadLocalMap，然后再根据当前this对象即ThreadLocal对象来获取对应的值。如果map不存在或者this对象的key不存在，那么就返回设置的初始值。</p>
<p>到这里就可以总结一下<strong>ThreadLocal的实现原理：每个线程都有一个自己的ThreadLocalMap对象，用来存储以ThreadLocal为key、Object为值的键值对，线程与线程之间互不影响。</strong></p>
<h5 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h5><p><img src="http://osuskkx7k.bkt.clouddn.com/threadlocal.jpg" alt="image"></p>
<h4 id="remove-方法"><a href="#remove-方法" class="headerlink" title="remove() 方法"></a>remove() 方法</h4><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        ThreadLocalMap m = getMap(Thread.currentThread());</div><div class="line">        <span class="keyword">if</span> (m != <span class="literal">null</span>)</div><div class="line">            m.<span class="keyword">remove</span>(<span class="keyword">this</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>当ThreadLocal对象调用该方法时，获取到线程的ThreadLocalMap，移除以this对象（该ThreadLocal对象）为key的键值对。</p>
<h4 id="setInitialValue-方法"><a href="#setInitialValue-方法" class="headerlink" title="setInitialValue() 方法"></a>setInitialValue() 方法</h4><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        T <span class="keyword">value</span> = initialValue();</div><div class="line">        Thread t = Thread.currentThread();</div><div class="line">        ThreadLocalMap map = getMap(t);</div><div class="line">        <span class="keyword">if</span> (map != <span class="literal">null</span>)</div><div class="line">            map.<span class="keyword">set</span>(<span class="keyword">this</span>, <span class="keyword">value</span>);</div><div class="line">        <span class="keyword">else</span></div><div class="line">            createMap(t, <span class="keyword">value</span>);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">value</span>;</div><div class="line">    &#125;</div><div class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>该方法主要作用是用来返回初始值，即initialValue()中的值，默认为null，在新建ThreadLocal时可以重写该方法，设置一个初始值。</p>
<h4 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h4><p>前面提到，ThreadLocalMap就是存储相应变量的地方。<br>ThreadLocalMap和大多数容器一样，维护了一个内部数组，即Entry[]数组，Entey节点如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">static <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference&lt;ThreadLocal&lt;?&gt;&gt;</span> </span>&#123;</div><div class="line">            <span class="comment">/** The value associated with this ThreadLocal. */</span></div><div class="line">            <span class="type">Object</span> value;</div><div class="line"></div><div class="line">            <span class="type">Entry</span>(<span class="type">ThreadLocal</span>&lt;?&gt; k, <span class="type">Object</span> v) &#123;</div><div class="line">                <span class="keyword">super</span>(k);</div><div class="line">                value = v;</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p>
<p>Entey是一个以ThreadLocal为key，Object为value的键值对，另外Entey继承了WeakReference（弱引用），在Entry的构造方法中，调用了super(k)方法将ThreadLocal实例包装成一个WeakReference。</p>
<h5 id="为什么使用弱引用（ThreadLocal）作为key？"><a href="#为什么使用弱引用（ThreadLocal）作为key？" class="headerlink" title="为什么使用弱引用（ThreadLocal）作为key？"></a>为什么使用弱引用（ThreadLocal）作为key？</h5><p>如果是强引用的话，ThreadLocalMap中一直会持有ThreadLocal的强引用，如果没有手动删除，那么ThreadLocal对象就无法回收，导致内存泄漏。  </p>
<p>我们知道弱引用无论内存是否足够都会被GC回收。这样当没有强引用指向ThreadLocal对象时就可以被回收，因此也就不会出现ThreadLocal对象的内存泄漏。但还是会出现另一种内存泄漏问题，见下面问题。</p>
<h5 id="为什么会引起内存泄漏？什么时候发生内存泄漏？如何防止内存泄漏？"><a href="#为什么会引起内存泄漏？什么时候发生内存泄漏？如何防止内存泄漏？" class="headerlink" title="为什么会引起内存泄漏？什么时候发生内存泄漏？如何防止内存泄漏？"></a>为什么会引起内存泄漏？什么时候发生内存泄漏？如何防止内存泄漏？</h5><p><strong>在线程的生命周期内发生内存泄漏。</strong></p>
<p><strong>我们知道ThreadLocalMap中存储的是key为ThreadLocal的引用，当这个引用失效时即为null时，那么线程中就存在ThreadLocalMap<null, value="">的键值对，此时无法获得对应的Value，于是就存在一条Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; Value 强引用链，无法访问到Value，因此就出现了内存泄漏的问题。</null,></strong></p>
<p>防止内存泄漏：<br><strong>1. 在ThreadLocalMap的set()、get()、remove()方法中，有一个将key为null的Entry擦除的过程，这样Entry内的value也就没有强引用链，自然会被回收。（不能保证一定擦除）</strong><br><strong>2. 当使用完毕后，显示调用remove()方法，直接清除ThreadLocalMap中以ThreadLocal对象为key的键值对;</strong></p>
<h5 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h5><p><strong>ThreadLocalMap使用开放地址法来处理Hash冲突</strong>，而不是拉链法(HashMap、concurrentHashMap)。<br>主要原因是：在ThreadLocalMap中的散列值分散的十分均匀，很少会出现冲突。并且ThreadLocalMap经常要清除无用的对象，使用纯数组更加方便。</p>
<p><strong>开放地址法</strong>：当发现有Hash冲突的时候，不会创建链表，而是继续在数组中寻找空的单元。探测数组中空单元的方式有很多，如<strong>线性探测法</strong>：从冲突的数组单元开始，依次往后搜索空单元，如果到了尾部还未找到就再从头开始查找，直到找到为止。</p>
<p>ThreadLocalMap<threadlocal,object>键值对数量为ThreadLocal的数量，一般来说ThreadLocal数量很少，相比在ThreadLocal中用Map<thread, object="">键值对存储线程变量（Thread数量一般来说比ThreadLocal数量多），性能提高很多。还有一个原因，如果是使用Map<thread, object="">的方式存储线程变量，还要考虑到增加减少线程时的并发问题。</thread,></thread,></threadlocal,object></p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>ThreadLocal由于在每个线程中都创建了副本,因此threadLocal会占用一定的内存；是一种空间换时间的思想；  </li>
<li>threadLocal只是一个工具，封装了ThreadLocalMap对象方法的入口；</li>
<li>threadLocal可以用来解决数据库连接、Session管理等问题，在spring也有大量使用，比如HttpServletRequest也是基于ThreadLocal来实现的。</li>
<li>ThreadLocal适用于每个线程需要有自己单独的实例，并且该实例需要在多个方法中共享，但不希望被多线程共享的场景。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;ThreadLocal的简介&quot;&gt;&lt;a href=&quot;#ThreadLocal的简介&quot; class=&quot;headerlink&quot; title=&quot;ThreadLocal的简介&quot;&gt;&lt;/a&gt;ThreadLocal的简介&lt;/h3&gt;&lt;p&gt;ThreadLocal称为线程局部变量。在每
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="ThreadLocal" scheme="http://yoursite.com/tags/ThreadLocal/"/>
    
      <category term="线程局部变量" scheme="http://yoursite.com/tags/%E7%BA%BF%E7%A8%8B%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>JDK动态代理的实现原理浅析</title>
    <link href="http://yoursite.com/2018/06/27/jdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/"/>
    <id>http://yoursite.com/2018/06/27/jdk动态代理的实现原理浅析/</id>
    <published>2018-06-27T06:12:12.000Z</published>
    <updated>2018-06-27T06:49:16.985Z</updated>
    
    <content type="html"><![CDATA[<h4 id="JDK动态代理简介"><a href="#JDK动态代理简介" class="headerlink" title="JDK动态代理简介"></a>JDK动态代理简介</h4><p>什么是JDK动态代理？<br>先看看代理的概念——<strong>代理：为其他对象提供一种代理以控制对这个对象的访问</strong>。  </p>
<p>代理在生活中很常见，比如买火车票可以不去火车站，而是通过代售点；想要逃课了，就让同学代签到等等。<br>说白了，就是可以通过代理来完成目标事件。（自我理解）</p>
<p>不同于静态代理直接采用编码的方式实现，JDK动态代理是<strong>利用反射机制在运行时创建代理类</strong>，进而调用相应的方法。</p>
<h4 id="JDK动态代理的使用"><a href="#JDK动态代理的使用" class="headerlink" title="JDK动态代理的使用"></a>JDK动态代理的使用</h4><p>通过一个小例子来看看如何使用JDK动态代理。</p>
<h5 id="目标接口"><a href="#目标接口" class="headerlink" title="目标接口"></a>目标接口</h5><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public<span class="built_in"> interface </span>GameService &#123;</div><div class="line"></div><div class="line">    String beginGame(String s);</div><div class="line"></div><div class="line">    void playGame(String s);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>目标接口中定义了两个目标方法。  </p>
<h5 id="目标对象"><a href="#目标对象" class="headerlink" title="目标对象"></a>目标对象</h5><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GamePlay</span> <span class="title">implements</span> <span class="title">GameService</span> &#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">beginGame</span>(<span class="params">String name</span>) </span>&#123;</div><div class="line">        System.<span class="keyword">out</span>.println(<span class="string">"玩家"</span> + name + <span class="string">"进入召唤师峡谷,游戏开始！"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="string">"玩家名字是："</span> + name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playGame</span>(<span class="params">String s</span>) </span>&#123;</div><div class="line">        System.<span class="keyword">out</span>.println(<span class="string">"玩家说： "</span> +  s);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>目标对象是目标接口的实现，也是要被代理的对象。</p>
<h5 id="调用处理器——InvocationHandler"><a href="#调用处理器——InvocationHandler" class="headerlink" title="调用处理器——InvocationHandler"></a>调用处理器——InvocationHandler</h5><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GameInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Object <span class="keyword">target</span>;</div><div class="line"></div><div class="line">    <span class="comment">//构造方法（可传入目标对象）</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GameInvocationHandler</span><span class="params">(Object <span class="keyword">target</span>)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.<span class="keyword">target</span> = <span class="keyword">target</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="function">Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        <span class="comment">//业务逻辑</span></div><div class="line">        System.out.println(<span class="string">"before-----欢迎来到——动态召唤师峡谷"</span>);</div><div class="line"> </div><div class="line">        <span class="comment">//方法的返回值（可以为空）</span></div><div class="line">        Object object = method.invoke(<span class="keyword">target</span>, args);</div><div class="line"></div><div class="line">        <span class="comment">//业务逻辑</span></div><div class="line">        System.out.println(<span class="string">"after------欢迎离开——动态召唤师峡谷"</span>);</div><div class="line">        <span class="keyword">return</span> object;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>InvocationHandler是调用处理器接口，它只定义了唯一一个 invoke() 方法，通过重写该方法可自定义代理的业务逻辑，该方法三个参数：  </p>
<ul>
<li>proxy：代理类对象（$Proxy0），在该方法中一般不会用到</li>
<li>method：被代理类调用的方法对象</li>
<li>args：方法对象中的参数</li>
</ul>
<h5 id="创建代理类对象——Proxy-newProxyInstance"><a href="#创建代理类对象——Proxy-newProxyInstance" class="headerlink" title="创建代理类对象——Proxy.newProxyInstance()"></a>创建代理类对象——Proxy.newProxyInstance()</h5><figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GamePlayDynamicProxy</span> </span>&#123;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args) &#123;</div><div class="line"></div><div class="line">        <span class="comment">//目标类（实现类）</span></div><div class="line">        GameService gameService = <span class="keyword">new</span> <span class="type">GamePlay</span>();</div><div class="line">        </div><div class="line">        <span class="comment">//调用处理器</span></div><div class="line">        InvocationHandler invocationHandler = <span class="keyword">new</span> <span class="type">GameInvocationHandler</span>(gameService);</div><div class="line"></div><div class="line">        <span class="comment">//生成代理对象</span></div><div class="line">        GameService GameServiceproxy = (GameService) Proxy.<span class="keyword">new</span><span class="type">ProxyInstance</span>(gameService.getClass().getClassLoader(),</div><div class="line">                gameService.getClass().getInterfaces(), invocationHandler);</div><div class="line"></div><div class="line">        <span class="comment">//调用方法,实际上运行的是真实类的方法（打断点可知）</span></div><div class="line">        GameServiceproxy.playGame(<span class="string">"我要超神啦！"</span>);</div><div class="line">        </div><div class="line">        <span class="comment">//beginGame()可获取返回值</span></div><div class="line">        <span class="comment">//String resultFromInvoke = GameServiceproxy.beginGame("LBJ");</span></div><div class="line">        <span class="comment">//System.out.println("InvocationHandler中的返回值：" + resultFromInvoke);</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过Proxy类的静态方法 newProxyInstance() 来创建代理类对象实例，关于其中具体的细节在下面的实现原理中将会提及。</p>
<h5 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h5><figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">before</span><span class="comment">-----欢迎来到——动态召唤师峡谷</span></div><div class="line">玩家说： 我要超神啦！</div><div class="line"><span class="keyword">after</span><span class="comment">------欢迎离开——动态召唤师峡谷</span></div></pre></td></tr></table></figure>
<p>可见，通过使用动态代理，可以<strong>在目标方法中增加所需要的业务逻辑</strong>（如日志处理、事务管理等）。  </p>
<h5 id="JDK动态代理使用步骤"><a href="#JDK动态代理使用步骤" class="headerlink" title="JDK动态代理使用步骤"></a>JDK动态代理使用步骤</h5><p><strong>1. 定义目标方法的接口（必须）</strong></p>
<p><strong>2. 实现接口目标方法的实现类（不是必须，如RPC中客户端代理没有实现类/Mybatis中的mapper接口也没有实现类，可在代理过程中实现 ）</strong></p>
<p><strong>3. 定义InvocationHandler，在invoke()方法中实现代理的业务逻辑，构造InvocationHandler时可传入必要的参数，以便在invoke()中使用。例如，可传入实现类作为构造参数。</strong></p>
<p><strong>4. 调用Proxy.newProxyInstance()生成代理类对象。该方法传入三个参数</strong>：</p>
<ul>
<li>ClassLoader：代理对象的类加载器；</li>
<li>Class&lt;?&gt;[] interfaces：代理对象需要实现的接口；</li>
<li>InvocationHandler：自定义实现的InvocationHandler</li>
</ul>
<p>5.通过代理类对象运行目标方法。</p>
<h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>那么 Java 的动态代理是如何实现的？<br>首先开门见山直接进入生成代理类对象的Proxy.newProxyInstance()方法。</p>
<h5 id="Proxy-newProxyInstance-方法"><a href="#Proxy-newProxyInstance-方法" class="headerlink" title="Proxy.newProxyInstance()方法"></a>Proxy.newProxyInstance()方法</h5><figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">@CallerSensitive</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object newProxyInstance(ClassLoader loader,</div><div class="line">                                      <span class="keyword">Class</span>&lt;?&gt;[] interfaces,</div><div class="line">                                      InvocationHandler h)</div><div class="line">    <span class="keyword">throws</span> IllegalArgumentException</div><div class="line">&#123;</div><div class="line">    Objects.requireNonNull(h);</div><div class="line">    <span class="comment">//克隆传入的接口</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">Class</span>&lt;?&gt;[] intfs = interfaces.clone();</div><div class="line">    <span class="keyword">final</span> SecurityManager sm = System.getSecurityManager();</div><div class="line">    <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</div><div class="line">        checkProxyAccess(Reflection.getCallerClass(), loader, intfs);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//通过类加载器和指定接口，生成代理类字节码文件，并获取代理类Class对象</span></div><div class="line">    <span class="keyword">Class</span>&lt;?&gt; cl = getProxyClass0(loader, intfs);</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</div><div class="line">            checkNewProxyPermission(Reflection.getCallerClass(), cl);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//获取指定构造函数对象(也就是 $Proxy0(InvocationHandler h))</span></div><div class="line">        <span class="keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</div><div class="line">        <span class="keyword">final</span> InvocationHandler ih = h;</div><div class="line">        <span class="keyword">if</span> (!Modifier.isPublic(cl.getModifiers())) &#123;</div><div class="line">            AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;<span class="keyword">Void</span>&gt;() &#123;</div><div class="line">                <span class="keyword">public</span> <span class="keyword">Void</span> run() &#123;</div><div class="line">                    cons.setAccessible(<span class="keyword">true</span>);</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//通过构造函数对象生成代理类对象</span></div><div class="line">        <span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> Object[]&#123;h&#125;);</div><div class="line">    &#125; <span class="comment">// catch...省略 </span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个方法中主要做了以下工作（如代码中的注释部分）：</p>
<ol>
<li><p>通过类加载器和指定接口，生成代理类字节码文件，并获取代理类Class对象cl；</p>
</li>
<li><p>通过Class对象cl获取指定的构造函数对象cons；</p>
</li>
<li><p>构造函数对象cons，通过方法中传入的InvocationHandler，生成一个实例，这个实例就是代理类对象。</p>
</li>
</ol>
<p>可见<strong>反射</strong>在上述代码中起了重要作用。  </p>
<p>大致了解了代理类对象是如何生成的，那么被代理的方法是如何调用的呢？ InvocationHandler中重写的invoke()方法又是如何调用的呢？接下来我们就来看看代理类究竟长什么模样。</p>
<h5 id="反编译"><a href="#反编译" class="headerlink" title="反编译"></a>反编译</h5><p>参考其他文章可知最终生成代理类的字节码是这样一行代码：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//生成字节码</span></div><div class="line"><span class="keyword">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces, accessFlags);</div></pre></td></tr></table></figure></p>
<p>调用了ProxyGenerator.generateProxyClass()方法, 因此我们可以通过该方法测试生成的代理类对象Class文件，并对其进行反编译，查看生成的具体代理类究竟是什么模样。</p>
<p>先获取代理类Class文件：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</div><div class="line"></div><div class="line">        <span class="keyword">byte</span>[] proxyBytes = ProxyGenerator.generateProxyClass(<span class="string">"ProxyObject"</span>, <span class="keyword">new</span> <span class="keyword">Class</span>[]&#123;GameService.<span class="keyword">class</span>&#125;);</div><div class="line">        <span class="keyword">File</span> <span class="keyword">file</span> = <span class="keyword">new</span> <span class="keyword">File</span>(<span class="string">"E:\\ProxyObject.class"</span>);</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            FileOutputStream out = <span class="keyword">new</span> FileOutputStream(<span class="keyword">file</span>);</div><div class="line">            out.<span class="keyword">write</span>(proxyBytes);</div><div class="line">            out.flush();</div><div class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>将获取到的Class文件存入E盘，即ProxyObject.class文件，然后再通过一个<a href="http://www.javadecompilers.com/" target="_blank" rel="external">在线反编译</a>的网站进行反编译，获取代理类的源码：<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> com.proxy.GameService;</div><div class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</div><div class="line"><span class="keyword">import</span> java.lang.reflect.Method;</div><div class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</div><div class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</div><div class="line"></div><div class="line"><span class="keyword">public</span> final <span class="class"><span class="keyword">class</span> <span class="title">ProxyObject</span></span></div><div class="line">  <span class="keyword"><span class="keyword">extends</span> <span class="type">Proxy</span></span></div><div class="line">  <span class="keyword"><span class="keyword">implements</span> <span class="type">GameService</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Method m4;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</div><div class="line">  </div><div class="line">  <span class="keyword">public</span> ProxyObject(InvocationHandler paramInvocationHandler)</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">super</span>(paramInvocationHandler);</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">public</span> final boolean equals(Object paramObject)</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">try</span></div><div class="line">    &#123;</div><div class="line">      <span class="keyword">return</span> ((Boolean)h.invoke(<span class="built_in">this</span>, m1, <span class="keyword">new</span> <span class="type">Object</span>[] &#123; paramObject &#125;)).booleanValue();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> (Error|RuntimeException localError)</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">throw</span> localError;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> (Throwable localThrowable)</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">UndeclaredThrowableException</span>(localThrowable);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">public</span> final <span class="keyword">String</span> toString()</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">try</span></div><div class="line">    &#123;</div><div class="line">      <span class="keyword">return</span> (<span class="keyword">String</span>)h.invoke(<span class="built_in">this</span>, m2, <span class="literal">null</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> (Error|RuntimeException localError)</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">throw</span> localError;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> (Throwable localThrowable)</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">UndeclaredThrowableException</span>(localThrowable);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">public</span> final void playGame(<span class="keyword">String</span> paramString)</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">try</span></div><div class="line">    &#123;</div><div class="line">      h.invoke(<span class="built_in">this</span>, m4, <span class="keyword">new</span> <span class="type">Object</span>[] &#123; paramString &#125;);</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> (Error|RuntimeException localError)</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">throw</span> localError;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> (Throwable localThrowable)</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">UndeclaredThrowableException</span>(localThrowable);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">public</span> final int hashCode()</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">try</span></div><div class="line">    &#123;</div><div class="line">      <span class="keyword">return</span> ((Integer)h.invoke(<span class="built_in">this</span>, m0, <span class="literal">null</span>)).intValue();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> (Error|RuntimeException localError)</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">throw</span> localError;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> (Throwable localThrowable)</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">UndeclaredThrowableException</span>(localThrowable);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">public</span> final <span class="keyword">String</span> beginGame(<span class="keyword">String</span> paramString)</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">try</span></div><div class="line">    &#123;</div><div class="line">      <span class="keyword">return</span> (<span class="keyword">String</span>)h.invoke(<span class="built_in">this</span>, m3, <span class="keyword">new</span> <span class="type">Object</span>[] &#123; paramString &#125;);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> (Error|RuntimeException localError)</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">throw</span> localError;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> (Throwable localThrowable)</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">UndeclaredThrowableException</span>(localThrowable);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">static</span></div><div class="line">  &#123;</div><div class="line">    <span class="keyword">try</span></div><div class="line">    &#123;</div><div class="line">      m1 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"equals"</span>, <span class="keyword">new</span> <span class="type">Class</span>[] &#123; Class.forName(<span class="string">"java.lang.Object"</span>) &#125;);</div><div class="line">      m2 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>, <span class="keyword">new</span> <span class="type">Class</span>[<span class="number">0</span>]);</div><div class="line">      m4 = Class.forName(<span class="string">"com.proxy.GameService"</span>).getMethod(<span class="string">"playGame"</span>, <span class="keyword">new</span> <span class="type">Class</span>[] &#123; Class.forName(<span class="string">"java.lang.String"</span>) &#125;);</div><div class="line">      m0 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashCode"</span>, <span class="keyword">new</span> <span class="type">Class</span>[<span class="number">0</span>]);</div><div class="line">      m3 = Class.forName(<span class="string">"com.proxy.GameService"</span>).getMethod(<span class="string">"beginGame"</span>, <span class="keyword">new</span> <span class="type">Class</span>[] &#123; Class.forName(<span class="string">"java.lang.String"</span>) &#125;);</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> (NoSuchMethodException localNoSuchMethodException)</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">NoSuchMethodError</span>(localNoSuchMethodException.getMessage());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> (ClassNotFoundException localClassNotFoundException)</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">NoClassDefFoundError</span>(localClassNotFoundException.getMessage());</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>观察上述代理类源码可以发现，包含了GameService接口中定义的两个方法playGame()和beginGame()。并且，<br><strong>当代理类对象调用目标方法时，实际上调用的就是InvocationHandler中的invoke()方法，因此也就解释代理类是如何与invoke()方法相关联的。</strong><br><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">以playGame方法为例：</div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> void playGame(String paramString) 即调用了</div><div class="line"> h.invoke(this, m4, <span class="keyword">new</span> Object[] <span class="comment">&#123; paramString &#125;</span>);</div><div class="line"> h：构建代理类传入的InvocationHandler</div><div class="line"> m4: <span class="keyword">static</span> 代码块中定义的<span class="function"><span class="keyword">method</span>实例</span></div><div class="line"> <span class="title">paramString</span>：参数</div></pre></td></tr></table></figure></p>
<h5 id="代理类特性"><a href="#代理类特性" class="headerlink" title="代理类特性"></a>代理类特性</h5><p>观察上述代理类源码，发现动态生成的代理类有以下特点：  </p>
<p><strong>1. 继承了Proxy类，实现了所代理的接口（不能再继承其他类）;</strong>  </p>
<p><strong>2. 除了包含所代理的接口方法，还有Object类的equals()、hashCode()、toString()三个方法，目的应该是防止重写保证和目标类一致；</strong>  </p>
<p><strong>3. 每一个方法都会执行调用处理器的 invoke() 方法（在其中可实现自定义的逻辑）；</strong></p>
<p><strong>4. 提供了一个使用InvocationHandler作为参数的构造方法，通过前面源码分析也能知道；</strong></p>
<p><strong>5. 每个代理类实例都会关联一个调用处理器对象。传入不同的调用处理器对象可生成不同的代理类对象。</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;JDK动态代理简介&quot;&gt;&lt;a href=&quot;#JDK动态代理简介&quot; class=&quot;headerlink&quot; title=&quot;JDK动态代理简介&quot;&gt;&lt;/a&gt;JDK动态代理简介&lt;/h4&gt;&lt;p&gt;什么是JDK动态代理？&lt;br&gt;先看看代理的概念——&lt;strong&gt;代理：为其他对象提
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="JDK动态代理" scheme="http://yoursite.com/tags/JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    
      <category term="代理模式" scheme="http://yoursite.com/tags/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>基数排序的简单实现</title>
    <link href="http://yoursite.com/2018/06/24/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2018/06/24/基数排序/</id>
    <published>2018-06-24T05:48:18.000Z</published>
    <updated>2018-06-24T06:28:43.863Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p><strong>基数排序是一种基于分配的排序（空间换时间）</strong>，不同于常见的基于比较的排序（冒泡、快排、归并…等）。  </p>
<p><strong>基于比较的排序时间复杂度通常是O（n^2）或者O（nlogn），下限是O（nlogn）；</strong>  </p>
<p><strong>基于分配的排序算法的时间复杂度可以达到O（n），但需要消耗额外空间；</strong></p>
<p>在某些时候，基数排序的效率高于其它基于比较的排序算法（快排、归并等）。</p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。进行了c次（c是整数的位数）比较之后，得到一个有序的数组。<br>基数排序是桶排序的扩展，每一次排序建立在桶排序的基础上。</p>
<h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><p><strong>1. 将每个数字统一位数长度（数位短的前面补0）；</strong><br><strong>2. 从最低位（个位）开始，依次进行每次排序；</strong><br><strong>3. 最高位排序完成后，数组就变成了有序数组。</strong></p>
<h4 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h4><p>通过基数排序对一个无序数组进行排序{53, 542, 3, 63, 14, 214, 154, 748, 616}，它的示意图如下：</p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F.jpg" alt="image"></p>
<h5 id="比较过程"><a href="#比较过程" class="headerlink" title="比较过程"></a>比较过程</h5><p>结合上图分析比较过程。<br><strong>每次比较，根据相应位数上的值，将元素放入对应的桶（0-10）中。</strong></p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%E8%A1%A8.png" alt=""></p>
<p>经过第三次排序，如图一，得到一个有序的数组。</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><h5 id="计算排序的次数"><a href="#计算排序的次数" class="headerlink" title="计算排序的次数"></a>计算排序的次数</h5><p>排序的次数即数组统一的位数（也是最大元素的位数），在这里是 3 位，总共需要比较3次。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//获取最大值</span></div><div class="line"><span class="type">int</span> <span class="built_in">max</span> = a[<span class="number">0</span>];</div><div class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">length</span>; i++) &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">max</span> &lt; a[i]) &#123;</div><div class="line">        <span class="built_in">max</span> = a[i];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//根据最大值确定排序的遍数（如369三位数，就是3遍）</span></div><div class="line"><span class="type">int</span> time = <span class="number">0</span>;</div><div class="line"><span class="keyword">while</span> (<span class="built_in">max</span> &gt; <span class="number">0</span>) &#123;</div><div class="line">    <span class="built_in">max</span> = <span class="built_in">max</span> / <span class="number">10</span>;</div><div class="line">    time ++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="排序过程"><a href="#排序过程" class="headerlink" title="排序过程"></a>排序过程</h5><p>每一次排序之后，都要根据排序的结果记录新的顺序，以便下一次排序。<br>思路如下：<br><strong>1. 将桶数组看成是一个只有10个元素（0-9）的队列，建立该队列（父队列）；</strong><br><strong>2. 父队列中的每一个元素都代表一个子队列，用于存放每个桶中的元素，可能0个也可能多个；</strong></p>
<p>注：采用数组ArrayList来代替子队列，也可以采用链表<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//建立一个主队列，包含10个子队列</span></div><div class="line">List&lt;ArrayList&gt; <span class="built_in">queue</span> = <span class="keyword">new</span> ArrayList&lt;ArrayList&gt;();</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">    ArrayList&lt;Integer&gt; subQueue = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    <span class="built_in">queue</span>.add(subQueue);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>3. 分配数组元素</strong></p>
<p>将每一个数组元素分配进入相应的桶中，即子队列中。<br>每次分配时，i 的值表示获取元素对应位数上的数字：<br>i = 0 ，表示个位；<br>i= 1，表示十位；<br>i = 2， 表示百位；<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//分配数组元素</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a.length; j++) &#123;</div><div class="line">    <span class="keyword">int</span> c = a[j] % (<span class="keyword">int</span>)Math.<span class="built_in">pow</span>(<span class="number">10</span>, i + <span class="number">1</span>); <span class="comment">//当前位上的数字</span></div><div class="line">    <span class="keyword">int</span> x = c / (<span class="keyword">int</span>)Math.<span class="built_in">pow</span>(<span class="number">10</span>, i); <span class="comment">//子队列的序号</span></div><div class="line">    <span class="comment">//System.out.println(x);</span></div><div class="line">    ArrayList&lt;Integer&gt; subQueue = <span class="built_in">queue</span>.get(x);  <span class="comment">//从父队列获取子队列</span></div><div class="line">    subQueue.add(a[j]);</div><div class="line">    <span class="built_in">queue</span>.<span class="built_in">set</span>(x, subQueue);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> radisSort(<span class="built_in">int</span>[] a) &#123;</div><div class="line"></div><div class="line">        <span class="comment">//获取最大值</span></div><div class="line">        <span class="built_in">int</span> <span class="built_in">max</span> = a[<span class="number">0</span>];</div><div class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (<span class="built_in">max</span> &lt; a[i]) &#123;</div><div class="line">                <span class="built_in">max</span> = a[i];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//根据最大值确定排序的遍数（如369三位数，3遍）</span></div><div class="line">        <span class="built_in">int</span> time = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (<span class="built_in">max</span> &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="built_in">max</span> = <span class="built_in">max</span> / <span class="number">10</span>;</div><div class="line">            time ++;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//建立一个主队列，包含10个子队列</span></div><div class="line">        List&lt;ArrayList&gt; queue = <span class="keyword">new</span> ArrayList&lt;ArrayList&gt;();</div><div class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">            ArrayList&lt;Integer&gt; subQueue = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">            queue.<span class="built_in">add</span>(subQueue);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//time次排序</span></div><div class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; time; i++) &#123;</div><div class="line"></div><div class="line">            <span class="comment">//分配数组元素</span></div><div class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; a.length; j++) &#123;</div><div class="line">                <span class="built_in">int</span> c = a[j] % (<span class="built_in">int</span>)Math.<span class="built_in">pow</span>(<span class="number">10</span>, i + <span class="number">1</span>); <span class="comment">//当前位上的数字</span></div><div class="line">                <span class="built_in">int</span> x = c / (<span class="built_in">int</span>)Math.<span class="built_in">pow</span>(<span class="number">10</span>, i); <span class="comment">//子队列的序号</span></div><div class="line">                <span class="comment">//System.out.println(x);</span></div><div class="line">                ArrayList&lt;Integer&gt; subQueue = queue.<span class="built_in">get</span>(x);  <span class="comment">//从父队列获取子队列</span></div><div class="line">                subQueue.<span class="built_in">add</span>(a[j]);</div><div class="line">                queue.<span class="built_in">set</span>(x, subQueue);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//分配结束后，记录新的顺序</span></div><div class="line">            <span class="built_in">int</span> k = <span class="number">0</span>;</div><div class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> n = <span class="number">0</span>; n &lt; <span class="number">10</span>; n++) &#123;</div><div class="line">                <span class="comment">//取出有元素的子队列</span></div><div class="line">                <span class="keyword">while</span> (queue.<span class="built_in">get</span>(n).<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</div><div class="line">                    ArrayList&lt;Integer&gt; subQueue = queue.<span class="built_in">get</span>(n);</div><div class="line">                    a[k ++] = subQueue.<span class="built_in">get</span>(<span class="number">0</span>);  <span class="comment">//头部元素</span></div><div class="line">                    subQueue.remove(<span class="number">0</span>);  <span class="comment">//移除元素</span></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//打印每次排序后的新数组</span></div><div class="line"><span class="comment">//            for (int m : a) &#123;</span></div><div class="line"><span class="comment">//                System.out.print(m + " ");</span></div><div class="line"><span class="comment">//            &#125;</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">//打印最终排好序的数组</span></div><div class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> m : a) &#123;</div><div class="line">            System.out.<span class="built_in">print</span>(m + <span class="string">" "</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</div><div class="line">        <span class="built_in">int</span>[] a = &#123;<span class="number">53</span>, <span class="number">542</span>, <span class="number">3</span>, <span class="number">63</span>, <span class="number">14</span>, <span class="number">214</span>, <span class="number">154</span>, <span class="number">748</span>, <span class="number">616</span>&#125;;</div><div class="line">        radisSort(a);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">3 </span><span class="number">14</span> <span class="number">53</span> <span class="number">63</span> <span class="number">154</span> <span class="number">214</span> <span class="number">542</span> <span class="number">616</span> <span class="number">748</span></div></pre></td></tr></table></figure>
<p>以上，就是基数排序的大致过程。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;基数排序&quot;&gt;&lt;a href=&quot;#基数排序&quot; class=&quot;headerlink&quot; title=&quot;基数排序&quot;&gt;&lt;/a&gt;基数排序&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;基数排序是一种基于分配的排序（空间换时间）&lt;/strong&gt;，不同于常见的基于比较的排序（冒泡、快排、归并…
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="基数排序" scheme="http://yoursite.com/tags/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>ActiveMQ结合Spring收发消息</title>
    <link href="http://yoursite.com/2018/02/15/ActiveMQ%E7%BB%93%E5%90%88Spring%E6%94%B6%E5%8F%91%E6%B6%88%E6%81%AF/"/>
    <id>http://yoursite.com/2018/02/15/ActiveMQ结合Spring收发消息/</id>
    <published>2018-02-15T07:12:12.000Z</published>
    <updated>2018-04-14T16:29:31.778Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ActiveMQ结合Spring收发消息"><a href="#ActiveMQ结合Spring收发消息" class="headerlink" title="ActiveMQ结合Spring收发消息"></a>ActiveMQ结合Spring收发消息</h3><p>直接使用ActiveMQ的方式需要重复写很多代码，且不利于管理，Spring 提供了一种更加简便的方式————Spring JMS ，通过它可以更加方便地使用ActiveMQ。</p>
<h4 id="Maven-依赖"><a href="#Maven-依赖" class="headerlink" title="Maven 依赖"></a>Maven 依赖</h4><p>结合Spring使用ActiveMQ的依赖如下：<br><figure class="highlight dust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="xml"><span class="comment">&lt;!-- Spring JMS --&gt;</span></span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jms<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$<span class="template-variable">&#123;spring.version&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="comment">&lt;!-- xbean 如&lt;amq:connectionFactory /&gt; --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.xbean<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xbean-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="comment">&lt;!-- ActiiveMQ --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.activemq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>activemq-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.activemq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>activemq-pool<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h4 id="ActiveMQ-xml-文件"><a href="#ActiveMQ-xml-文件" class="headerlink" title="ActiveMQ.xml 文件"></a>ActiveMQ.xml 文件</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></div><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">       <span class="attr">xmlns:amq</span>=<span class="string">"http://activemq.apache.org/schema/core"</span></div><div class="line">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></div><div class="line">        http://www.springframework.org/schema/beans/spring-beans-4.0.xsd</div><div class="line">        http://activemq.apache.org/schema/core</div><div class="line">        http://activemq.apache.org/schema/core/activemq-core-5.12.1.xsd"&gt;</div><div class="line">    <span class="comment">&lt;!-- ActiveMQ 连接工厂 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">amq:connectionFactory</span> <span class="attr">id</span>=<span class="string">"amqConnectionFactory"</span></span></div><div class="line">                           <span class="attr">brokerURL</span>=<span class="string">"tcp://localhost:61616"</span></div><div class="line">                           <span class="attr">userName</span>=<span class="string">"admin"</span></div><div class="line">                           <span class="attr">password</span>=<span class="string">"admin"</span> /&gt;</div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- 提高效率，配置JMS连接工厂 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"connectionFactory"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jms.connection.CachingConnectionFactory"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"amqConnectionFactory"</span> /&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sessionCacheSize"</span> <span class="attr">value</span>=<span class="string">"100"</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 定义消息队列（Queue）--&gt;</span></div><div class="line">   <span class="comment">&lt;!-- &lt;bean id="QueueDestination" class="org.apache.activemq.command.ActiveMQQueue"&gt;</span></div><div class="line">        &amp;lt;!&amp;ndash; 设置消息队列的名字 &amp;ndash;&amp;gt;</div><div class="line">        &lt;constructor-arg value="Queue-zy"/&gt;</div><div class="line">    &lt;/bean&gt;--&gt;</div><div class="line">    <span class="comment">&lt;!--定义主题(Topic)--&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"topicDestination"</span> <span class="attr">class</span>=<span class="string">"org.apache.activemq.command.ActiveMQTopic"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"Topic-zy"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 配置JMS模板（Queue），Spring提供的JMS工具类，利用它发送、接收消息。 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jmsTemplate"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jms.core.JmsTemplate"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connectionFactory"</span> <span class="attr">ref</span>=<span class="string">"connectionFactory"</span> /&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"defaultDestination"</span> <span class="attr">ref</span>=<span class="string">"topicDestination"</span> /&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"receiveTimeout"</span> <span class="attr">value</span>=<span class="string">"10000"</span> /&gt;</span></div><div class="line">        <span class="comment">&lt;!-- true是topic，false是queue，默认是false --&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"pubSubDomain"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 配置消息队列监听者（Queue or Topic） --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"messageListener"</span> <span class="attr">class</span>=<span class="string">"com.service.TopicMessageListener"</span> /&gt;</span></div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- 显示注入消息监听容器，配置连接工厂，监听的目标是QueueDestination，监听器是上面定义的监听器 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"ListenerContainer"</span></span></div><div class="line">          <span class="attr">class</span>=<span class="string">"org.springframework.jms.listener.DefaultMessageListenerContainer"</span>&gt;</div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connectionFactory"</span> <span class="attr">ref</span>=<span class="string">"connectionFactory"</span> /&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"destination"</span> <span class="attr">ref</span>=<span class="string">"topicDestination"</span> /&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"messageListener"</span> <span class="attr">ref</span>=<span class="string">"messageListener"</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure>
<h5 id="配置connectionFactory"><a href="#配置connectionFactory" class="headerlink" title="配置connectionFactory"></a>配置connectionFactory</h5><p>connectionFactory是Spring用于创建到JMS服务器链接的，Spring提供了多种connectionFactory.</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- ActiveMQ 连接工厂 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">amq:connectionFactory</span> <span class="attr">id</span>=<span class="string">"amqConnectionFactory"</span></span></div><div class="line">                       <span class="attr">brokerURL</span>=<span class="string">"tcp://localhost:61616"</span></div><div class="line">                       <span class="attr">userName</span>=<span class="string">"admin"</span></div><div class="line">                       <span class="attr">password</span>=<span class="string">"admin"</span> /&gt;</div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 提高效率，配置JMS连接工厂 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"connectionFactory"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jms.connection.CachingConnectionFactory"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"amqConnectionFactory"</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sessionCacheSize"</span> <span class="attr">value</span>=<span class="string">"100"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<h5 id="配置Queue"><a href="#配置Queue" class="headerlink" title="配置Queue"></a>配置Queue</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=<span class="string">"QueueDestination"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.apache.activemq.command.ActiveMQQueue"</span>&gt;</div><div class="line">       <span class="xml"><span class="comment">&lt;!-- 设置消息队列的名字 --&gt;</span></span></div><div class="line">       <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"Queue-zy"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<h5 id="配置Topic"><a href="#配置Topic" class="headerlink" title="配置Topic"></a>配置Topic</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=<span class="string">"topicDestination"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.apache.activemq.command.ActiveMQTopic"</span>&gt;</div><div class="line">        <span class="xml"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"Topic-zy"</span>/&gt;</span></span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<h5 id="配置JMS消息模板——jmsTemplate"><a href="#配置JMS消息模板——jmsTemplate" class="headerlink" title="配置JMS消息模板——jmsTemplate"></a>配置JMS消息模板——jmsTemplate</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 配置JMS模板，Spring提供的JMS工具类，利用它发送、接收消息--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jmsTemplate"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jms.core.JmsTemplate"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connectionFactory"</span> <span class="attr">ref</span>=<span class="string">"connectionFactory"</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"defaultDestination"</span> <span class="attr">ref</span>=<span class="string">"QueueDestination"</span> /&gt;</span></div><div class="line">    <span class="comment">&lt;!--&lt;property name="defaultDestination" ref="topicDestination" /&gt;--&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"receiveTimeout"</span> <span class="attr">value</span>=<span class="string">"10000"</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"pubSubDomain"</span> <span class="attr">value</span>=<span class="string">"false"</span> /&gt;</span><span class="comment">&lt;!-- true是topic，false是queue，默认是false --&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<p>最后，在applicationContext.xml中引入配置好的ActiveMQ.xml<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;<span class="keyword">import</span> resource=<span class="string">"ActiveMQ.xml"</span> /&gt;</div></pre></td></tr></table></figure></p>
<p>以上就是配置文件相关的，下面是具体的业务代码。</p>
<h4 id="消息生产者服务"><a href="#消息生产者服务" class="headerlink" title="消息生产者服务"></a>消息生产者服务</h4><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Service</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerService</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> JmsTemplate jmsTemplate;</div><div class="line"></div><div class="line">    <span class="comment">//使用默认目的地</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">sendMessageDefault</span><span class="params">(<span class="keyword">final</span> String msg)</span></span>&#123;</div><div class="line">        Destination destination = jmsTemplate.getDefaultDestination();</div><div class="line">        System.out.println(<span class="string">"向队列： "</span> + destination + <span class="string">" 成功发送一条消息"</span>);</div><div class="line">        jmsTemplate.send(<span class="keyword">new</span> MessageCreator() &#123;</div><div class="line">            <span class="keyword">public</span> <span class="function">Message <span class="title">createMessage</span><span class="params">(Session session)</span> <span class="keyword">throws</span> JMSException </span>&#123;</div><div class="line">                <span class="function"><span class="keyword">return</span> session.<span class="title">createTextMessage</span><span class="params">(msg)</span></span>;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//可指定目的地</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(Destination destination,<span class="keyword">final</span> String msg)</span></span>&#123;</div><div class="line"></div><div class="line">        jmsTemplate.send(destination, <span class="keyword">new</span> MessageCreator() &#123;</div><div class="line">            <span class="keyword">public</span> <span class="function">Message <span class="title">createMessage</span><span class="params">(Session session)</span> <span class="keyword">throws</span> JMSException </span>&#123;</div><div class="line">                <span class="function"><span class="keyword">return</span> session.<span class="title">createTextMessage</span><span class="params">(msg)</span></span>;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="消息消费者服务"><a href="#消息消费者服务" class="headerlink" title="消息消费者服务"></a>消息消费者服务</h4><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">@Service</div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ConsumerService</span> &#123;</div><div class="line"></div><div class="line">    @Autowired</div><div class="line">    <span class="keyword">private</span> JmsTemplate jmsTemplate;</div><div class="line"></div><div class="line">    <span class="comment">//从指定的Destination接收消息</span></div><div class="line">    <span class="function"><span class="keyword">public</span> TextMessage <span class="title">recive</span>(<span class="params">Destination destination</span>)</span>&#123;</div><div class="line">        TextMessage message = (TextMessage) jmsTemplate.receive(destination);</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            System.<span class="keyword">out</span>.println(<span class="string">"从队列"</span> + destination.toString() + <span class="string">"收到了消息"</span> + message.getText());</div><div class="line">        &#125; <span class="keyword">catch</span> (JMSException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> message;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//从默认的Destination接收消息</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reciveDefault</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    </div><div class="line">        Destination destination = jmsTemplate.getDefaultDestination();</div><div class="line">        jmsTemplate.setReceiveTimeout(<span class="number">5000</span>);</div><div class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</div><div class="line">            TextMessage message = (TextMessage) jmsTemplate.receive(destination);</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">//这里还是同一个消费者</span></div><div class="line">                System.<span class="keyword">out</span>.println(<span class="string">"消费者  从目的地 "</span> + destination.toString() + <span class="string">" 收到了消息"</span> + message.getText());</div><div class="line">            &#125; <span class="keyword">catch</span> (JMSException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h4><p>直接在main方法中获取ApplicationContext运行，便于测试。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MsgProducer</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> ProducerService producerService;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"生产者开始发送消息："</span>);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">11</span>; i++)&#123;</div><div class="line">            String msg = <span class="string">"生产者发出的消息"</span>;</div><div class="line">            producerService.sendMessageDefault(msg + <span class="string">"-----"</span> + i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"classpath:/applicationContext.xml"</span>);</div><div class="line">        MsgProducer msgProducer = context.getBean(MsgProducer.class);</div><div class="line">        msgProducer.send();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MsgConsumer</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> ConsumerService consumerService;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recive</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"消费者 1 开始接收消息："</span>);</div><div class="line">        consumerService.reciveDefault();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"classpath:/applicationContext.xml"</span>);</div><div class="line">        MsgConsumer msgConsumer = context.getBean(MsgConsumer.class);</div><div class="line">        msgConsumer.recive();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来就可以启动项目。同样是使用两种方式测试。</p>
<h4 id="第一种方式————点对点（Queue）"><a href="#第一种方式————点对点（Queue）" class="headerlink" title="第一种方式————点对点（Queue）"></a>第一种方式————点对点（Queue）</h4><h4 id="同步的方式"><a href="#同步的方式" class="headerlink" title="同步的方式"></a>同步的方式</h4><p>先启动生产者  发送10条消息， 再启动消费者，可以看到控制台显示成功收到10条消息  </p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/%E7%82%B9%E5%AF%B9%E7%82%B9%E7%94%9F%E4%BA%A7.png" alt="image"></p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/%E7%82%B9%E5%AF%B9%E7%82%B9%E6%B6%88%E8%B4%B9.jpg" alt="image"></p>
<h4 id="异步监听的方式"><a href="#异步监听的方式" class="headerlink" title="异步监听的方式"></a>异步监听的方式</h4><p>通过监听器即可实现异步接收消息的效果，而不是像上面使用while()轮询同步的方式。<br>项目中一般都是使用异步监听的方式，<strong>在A服务中发送了一条消息，B服务可以利用消息监听器监听，当收到消息后，进行相应的操作</strong>。</p>
<h5 id="消息监听器（3种）"><a href="#消息监听器（3种）" class="headerlink" title="消息监听器（3种）"></a>消息监听器（3种）</h5><p>通过继承JMS中的<strong>MessageListener接口</strong>，实现onMessage()方法，就可以自定义监听器。这是最基本的监听器。（可根据业务实现自定义的功能）</p>
<p>另外spring也给我们提供了其他类型的消息监听器，比如 <strong>SessionAwareMessageListener</strong>，它的作用不仅可以接收消息，还可以发送一条消息通知对方表示自己收到了消息。（还有一种是<strong>MessageListenerAdapter</strong>）</p>
<p>一个简单的自定义监听器如下:收到消息后打印消息<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueMessageListener</span> <span class="keyword">implements</span> <span class="title">MessageListener</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message)</span> </span>&#123;</div><div class="line">        <span class="comment">//如果有消息</span></div><div class="line">        TextMessage tmessage = (TextMessage) message;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">if</span>(tmessage != <span class="keyword">null</span>)&#123;</div><div class="line">                System.out.println(<span class="string">"监听器监听消息："</span>+tmessage.getText());</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (JMSException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在ActiveMQ.xml中引入消息监听器：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 配置消息队列监听者（Queue） --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"queueMessageListener"</span> <span class="attr">class</span>=<span class="string">"com.service.QueueMessageListener"</span> /&gt;</span></div><div class="line">    </div><div class="line"> <span class="comment">&lt;!-- 显示注入消息监听容器，配置连接工厂，监听的目标是QueueDestination 或 topicDestination，监听器是上面自定义的监听器 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"queueListenerContainer"</span></span></div><div class="line">          <span class="attr">class</span>=<span class="string">"org.springframework.jms.listener.DefaultMessageListenerContainer"</span>&gt;</div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connectionFactory"</span> <span class="attr">ref</span>=<span class="string">"connectionFactory"</span> /&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"destination"</span> <span class="attr">ref</span>=<span class="string">"QueueDestination"</span> /&gt;</span></div><div class="line">        <span class="comment">&lt;!--&lt;property name="destination" ref="topicDestination" /&gt;--&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"messageListener"</span> <span class="attr">ref</span>=<span class="string">"queueMessageListener"</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>可以看到，当使用消息监听器之后，每发送一条消息立马就会被监听到：  </p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/%E7%82%B9%E5%AF%B9%E7%82%B9%E7%9B%91%E5%90%AC%E5%99%A8.jpg" alt="image"></p>
<h4 id="第二种方式————发布-订阅（Topic）"><a href="#第二种方式————发布-订阅（Topic）" class="headerlink" title="第二种方式————发布/订阅（Topic）"></a>第二种方式————发布/订阅（Topic）</h4><h4 id="同步的方式-1"><a href="#同步的方式-1" class="headerlink" title="同步的方式"></a>同步的方式</h4><p>类似点对点中同步的方式，只是每个消费者都能收到生产者发出的全部消息，不再赘述。</p>
<h4 id="异步监听的方式-1"><a href="#异步监听的方式-1" class="headerlink" title="异步监听的方式"></a>异步监听的方式</h4><p>启动两个监听器（两个消费者），对消息进行异步监听。看是否各自能收到生产者发送的消息。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 配置两个监听器 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"messageListener"</span> <span class="attr">class</span>=<span class="string">"com.service.TopicMessageListener"</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"messageListener2"</span> <span class="attr">class</span>=<span class="string">"com.service.TopicMessageListener2"</span> /&gt;</span></div></pre></td></tr></table></figure>
<p><img src="http://osuskkx7k.bkt.clouddn.com/%E4%B8%A4%E4%B8%AA%E7%9B%91%E5%90%AC%E5%99%A8.jpg" alt="image"></p>
<p>可以看到，每个监听器各自都收到了生产者发送的10条消息。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;ActiveMQ结合Spring收发消息&quot;&gt;&lt;a href=&quot;#ActiveMQ结合Spring收发消息&quot; class=&quot;headerlink&quot; title=&quot;ActiveMQ结合Spring收发消息&quot;&gt;&lt;/a&gt;ActiveMQ结合Spring收发消息&lt;/h3&gt;&lt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="ActiveMQ" scheme="http://yoursite.com/tags/ActiveMQ/"/>
    
      <category term="消息队列" scheme="http://yoursite.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>ActiveMQ的简单使用</title>
    <link href="http://yoursite.com/2018/02/12/ActiveMQ%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/02/12/ActiveMQ的简单使用/</id>
    <published>2018-02-12T07:12:12.000Z</published>
    <updated>2018-05-22T13:57:19.010Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ActiveMQ的简单使用"><a href="#ActiveMQ的简单使用" class="headerlink" title="ActiveMQ的简单使用"></a>ActiveMQ的简单使用</h3><p>ActiveMQ 是一种消息队列，是Apache提供的一个开源消息系统，完全采用Java实现，因此，它能很好地支持J2EE提出的JMS（Java Message Service,即Java消息服务）规范。</p>
<h4 id="第一种方式（点对点）——Queue"><a href="#第一种方式（点对点）——Queue" class="headerlink" title="第一种方式（点对点）——Queue"></a>第一种方式（点对点）——Queue</h4><h5 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.apache.activemq.ActiveMQConnectionFactory;</div><div class="line"><span class="keyword">import</span> javax.jms.*;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">//连接工厂</span></div><div class="line">        ConnectionFactory connectionFactory;</div><div class="line">        <span class="comment">//连接</span></div><div class="line">        Connection connection = <span class="keyword">null</span>;</div><div class="line">        <span class="comment">//会话</span></div><div class="line">        Session session;</div><div class="line">        <span class="comment">//目的地</span></div><div class="line">        Destination destination;</div><div class="line">        <span class="comment">//消息生产者</span></div><div class="line">        MessageProducer messageProducer;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            connectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(ActiveMQConnectionFactory.DEFAULT_USER,ActiveMQConnectionFactory.DEFAULT_PASSWORD,</div><div class="line">                    ActiveMQConnectionFactory.DEFAULT_BROKER_URL);</div><div class="line">            connection = connectionFactory.createConnection();</div><div class="line">            connection.start();</div><div class="line">            session = connection.createSession(<span class="keyword">false</span>,Session.AUTO_ACKNOWLEDGE);   <span class="comment">//不开启事务</span></div><div class="line"></div><div class="line">            destination = session.createQueue(<span class="string">"Queue-zy"</span>);</div><div class="line">            messageProducer = session.createProducer(destination);</div><div class="line">            messageProducer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);       <span class="comment">//是否持久化（默认持久化）</span></div><div class="line"></div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;<span class="number">11</span>; i++)&#123;</div><div class="line">                System.out.println(<span class="string">"生产者成功发出消息——Queue-zy：序号---"</span>+i);</div><div class="line">                TextMessage message = session.createTextMessage(<span class="string">"消息-----"</span>+i+<span class="string">"-------hello,MQ!"</span>);</div><div class="line">                messageProducer.send(message);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125; <span class="keyword">catch</span> (JMSException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">finally</span>&#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                connection.close();</div><div class="line">            &#125; <span class="keyword">catch</span> (JMSException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>控制台打印出发送消息成功的语句，总计10条消息：</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">生产者成功发出消息——Queue-zy：序号<span class="comment">---1</span></div><div class="line">生产者成功发出消息——Queue-zy：序号<span class="comment">---2</span></div><div class="line">生产者成功发出消息——Queue-zy：序号<span class="comment">---3</span></div><div class="line">生产者成功发出消息——Queue-zy：序号<span class="comment">---4</span></div><div class="line">生产者成功发出消息——Queue-zy：序号<span class="comment">---5</span></div><div class="line">生产者成功发出消息——Queue-zy：序号<span class="comment">---6</span></div><div class="line">生产者成功发出消息——Queue-zy：序号<span class="comment">---7</span></div><div class="line">生产者成功发出消息——Queue-zy：序号<span class="comment">---8</span></div><div class="line">生产者成功发出消息——Queue-zy：序号<span class="comment">---9</span></div><div class="line">生产者成功发出消息——Queue-zy：序号<span class="comment">---10</span></div></pre></td></tr></table></figure>
<p><img src="http://osuskkx7k.bkt.clouddn.com/Queue1%20%282%29.jpg" alt="image"><br>此时，打开ActiveMQ的管理页面，点击Queues，便可看到一个名为 Queue-zy 的队列：<br>Number Of Pending Messages ：表示等待被消费的消息数为 10  </p>
<p>Messages Enqueued：  表示进入队列的消息数为 10  （可叠加）</p>
<p>Messages Dequeued：  表示出队列的消息，此时为0  </p>
<h5 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h5><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="meta"><span class="meta-keyword">import</span> org.apache.activemq.ActiveMQConnectionFactory;</span></div><div class="line"><span class="meta"><span class="meta-keyword">import</span> javax.jms.*;</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</div><div class="line"></div><div class="line">        <span class="comment">//连接工厂</span></div><div class="line">        ConnectionFactory connectionFactory;</div><div class="line">        <span class="comment">//连接</span></div><div class="line">        Connection connection = <span class="literal">null</span>;</div><div class="line">        <span class="comment">//会话</span></div><div class="line">        Session session;</div><div class="line">        <span class="comment">//目的地</span></div><div class="line">        Destination destination;</div><div class="line">        <span class="comment">//消息生产者</span></div><div class="line">        MessageConsumer messageConsumer ;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            connectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(ActiveMQConnectionFactory.DEFAULT_USER,ActiveMQConnectionFactory.DEFAULT_PASSWORD,</div><div class="line">                    ActiveMQConnectionFactory.DEFAULT_BROKER_URL);</div><div class="line">            connection = connectionFactory.createConnection();</div><div class="line">            connection.start();</div><div class="line"></div><div class="line">            session = connection.createSession(<span class="literal">false</span>,Session.AUTO_ACKNOWLEDGE);</div><div class="line">            destination = session.createQueue(<span class="string">"Queue-zy"</span>);</div><div class="line">            messageConsumer = session.createConsumer(destination);</div><div class="line"></div><div class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</div><div class="line">                TextMessage textMessage = (TextMessage) messageConsumer.receive(<span class="number">10000</span>);</div><div class="line">                <span class="keyword">if</span>(textMessage != <span class="literal">null</span>)&#123;</div><div class="line">                    System.out.println(<span class="string">"消费者成功接收到消息： "</span>+textMessage.getText());</div><div class="line">                &#125;<span class="keyword">else</span>&#123;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">finally</span>&#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                connection.close();</div><div class="line">            &#125; <span class="keyword">catch</span> (JMSException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>点击Run启动消费者Main()，可以看到控制台输出，成功接收10条消息：<br><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">消费者成功接收到消息：</span> <span class="comment">消息</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">1</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">hello</span><span class="string">,</span><span class="comment">MQ!</span></div><div class="line"><span class="comment">消费者成功接收到消息：</span> <span class="comment">消息</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">2</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">hello</span><span class="string">,</span><span class="comment">MQ!</span></div><div class="line"><span class="comment">消费者成功接收到消息：</span> <span class="comment">消息</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">3</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">hello</span><span class="string">,</span><span class="comment">MQ!</span></div><div class="line"><span class="comment">消费者成功接收到消息：</span> <span class="comment">消息</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">4</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">hello</span><span class="string">,</span><span class="comment">MQ!</span></div><div class="line"><span class="comment">消费者成功接收到消息：</span> <span class="comment">消息</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">5</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">hello</span><span class="string">,</span><span class="comment">MQ!</span></div><div class="line"><span class="comment">消费者成功接收到消息：</span> <span class="comment">消息</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">6</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">hello</span><span class="string">,</span><span class="comment">MQ!</span></div><div class="line"><span class="comment">消费者成功接收到消息：</span> <span class="comment">消息</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">7</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">hello</span><span class="string">,</span><span class="comment">MQ!</span></div><div class="line"><span class="comment">消费者成功接收到消息：</span> <span class="comment">消息</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">8</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">hello</span><span class="string">,</span><span class="comment">MQ!</span></div><div class="line"><span class="comment">消费者成功接收到消息：</span> <span class="comment">消息</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">9</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">hello</span><span class="string">,</span><span class="comment">MQ!</span></div><div class="line"><span class="comment">消费者成功接收到消息：</span> <span class="comment">消息</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">10</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">hello</span><span class="string">,</span><span class="comment">MQ!</span></div></pre></td></tr></table></figure></p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/Queue-2.jpg" alt="image"></p>
<p>再次查看ActiveMQ的管理页面，点击Queues  </p>
<p>Number Of Pending Messages ：等待被消费的消息数变为 0，此时消息已经全部被消费  </p>
<p>Messages Enqueued： 进入队列的消息数为 10  （叠加）  </p>
<p>Messages Dequeued： 出队列的消息，此时为10  </p>
<h4 id="第二种方式（发布-订阅）——Topic"><a href="#第二种方式（发布-订阅）——Topic" class="headerlink" title="第二种方式（发布/订阅）——Topic"></a>第二种方式（发布/订阅）——Topic</h4><p><strong>两种方式的代码只有一处区别：由Session创建的目的地不同</strong></p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//Queue</div><div class="line"><span class="attribute">destination</span> = session.createQueue(<span class="string">"Queue-zy"</span>)<span class="comment">;</span></div><div class="line">//Topic</div><div class="line"><span class="attribute">destination</span> = session.createTopic(<span class="string">"Topic-zy"</span>)<span class="comment">;</span></div></pre></td></tr></table></figure>
<p>注意：<strong>先启动订阅者（消费者），再启动发布者（生产者）————因为在没有实现订阅消息持久化的情况下，只能在订阅者上线后才能接收到发布者发布的消息。</strong></p>
<h5 id="生产者-1"><a href="#生产者-1" class="headerlink" title="生产者"></a>生产者</h5><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="meta"><span class="meta-keyword">import</span> org.apache.activemq.ActiveMQConnectionFactory;</span></div><div class="line"><span class="meta"><span class="meta-keyword">import</span> javax.jms.*;</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</div><div class="line"></div><div class="line">        <span class="comment">//连接工厂</span></div><div class="line">        ConnectionFactory connectionFactory;</div><div class="line">        <span class="comment">//连接</span></div><div class="line">        Connection connection = <span class="literal">null</span>;</div><div class="line">        <span class="comment">//会话</span></div><div class="line">        Session session;</div><div class="line">        <span class="comment">//目的地</span></div><div class="line">        Destination destination;</div><div class="line">        <span class="comment">//消息生产者</span></div><div class="line">        MessageProducer messageProducer;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            connectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(ActiveMQConnectionFactory.DEFAULT_USER,ActiveMQConnectionFactory.DEFAULT_PASSWORD,</div><div class="line">                    ActiveMQConnectionFactory.DEFAULT_BROKER_URL);</div><div class="line">            connection = connectionFactory.createConnection();</div><div class="line">            connection.start();</div><div class="line">            session = connection.createSession(<span class="literal">false</span>,Session.AUTO_ACKNOWLEDGE);   <span class="comment">//不开启事务</span></div><div class="line"></div><div class="line">            <span class="comment">//destination = session.createQueue("Queue-zy");</span></div><div class="line">            destination = session.createTopic(<span class="string">"Topic-zy"</span>);</div><div class="line">            messageProducer = session.createProducer(destination);</div><div class="line">            messageProducer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);       <span class="comment">//是否持久化（默认持久化）</span></div><div class="line"></div><div class="line">            <span class="keyword">for</span>(int i = <span class="number">1</span>; i&lt;<span class="number">11</span>; i++)&#123;</div><div class="line">                System.out.println(<span class="string">"生产者成功发出消息——Topic-zy：序号---"</span>+i);</div><div class="line">                TextMessage message = session.createTextMessage(<span class="string">"消息-----"</span>+i+<span class="string">"-------hello,MQ!"</span>);</div><div class="line">                messageProducer.send(message);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (JMSException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">finally</span>&#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                connection.close();</div><div class="line">            &#125; <span class="keyword">catch</span> (JMSException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="消费者-1"><a href="#消费者-1" class="headerlink" title="消费者 1"></a>消费者 1</h5><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="meta"><span class="meta-keyword">import</span> org.apache.activemq.ActiveMQConnectionFactory;</span></div><div class="line"></div><div class="line"><span class="meta"><span class="meta-keyword">import</span> javax.jms.*;</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</div><div class="line"></div><div class="line">        <span class="comment">//连接工厂</span></div><div class="line">        ConnectionFactory connectionFactory;</div><div class="line">        <span class="comment">//连接</span></div><div class="line">        Connection connection = <span class="literal">null</span>;</div><div class="line">        <span class="comment">//会话</span></div><div class="line">        Session session;</div><div class="line">        <span class="comment">//目的地</span></div><div class="line">        Destination destination;</div><div class="line">        <span class="comment">//消息生产者</span></div><div class="line">        MessageConsumer messageConsumer ;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            connectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(ActiveMQConnectionFactory.DEFAULT_USER,ActiveMQConnectionFactory.DEFAULT_PASSWORD,</div><div class="line">                    ActiveMQConnectionFactory.DEFAULT_BROKER_URL);</div><div class="line">            connection = connectionFactory.createConnection();</div><div class="line">            connection.start();</div><div class="line">            session = connection.createSession(<span class="literal">false</span>,Session.AUTO_ACKNOWLEDGE);</div><div class="line"></div><div class="line">            <span class="comment">//destination = session.createQueue("Queue-zy");</span></div><div class="line">            destination = session.createTopic(<span class="string">"Topic-zy"</span>);</div><div class="line">            messageConsumer = session.createConsumer(destination);</div><div class="line"></div><div class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</div><div class="line">                TextMessage textMessage = (TextMessage) messageConsumer.receive(<span class="number">10000</span>);</div><div class="line">                <span class="keyword">if</span>(textMessage != <span class="literal">null</span>)&#123;</div><div class="line">                    System.out.println(<span class="string">"消费者 1 成功接收到消息： "</span>+textMessage.getText());</div><div class="line">                &#125;<span class="keyword">else</span>&#123;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="消费者-2"><a href="#消费者-2" class="headerlink" title="消费者 2"></a>消费者 2</h5><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="meta"><span class="meta-keyword">import</span> org.apache.activemq.ActiveMQConnectionFactory;</span></div><div class="line"><span class="meta"><span class="meta-keyword">import</span> javax.jms.*;</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer2</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</div><div class="line"></div><div class="line">        <span class="comment">//连接工厂</span></div><div class="line">        ConnectionFactory connectionFactory;</div><div class="line">        <span class="comment">//连接</span></div><div class="line">        Connection connection = <span class="literal">null</span>;</div><div class="line">        <span class="comment">//会话</span></div><div class="line">        Session session;</div><div class="line">        <span class="comment">//目的地</span></div><div class="line">        Destination destination;</div><div class="line">        <span class="comment">//消息生产者</span></div><div class="line">        MessageConsumer messageConsumer ;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            connectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(ActiveMQConnectionFactory.DEFAULT_USER,ActiveMQConnectionFactory.DEFAULT_PASSWORD,</div><div class="line">                    ActiveMQConnectionFactory.DEFAULT_BROKER_URL);</div><div class="line">            connection = connectionFactory.createConnection();</div><div class="line">            connection.start();</div><div class="line">            session = connection.createSession(<span class="literal">false</span>,Session.AUTO_ACKNOWLEDGE);</div><div class="line"></div><div class="line">            <span class="comment">//destination = session.createQueue("Queue-zy");</span></div><div class="line">            destination = session.createTopic(<span class="string">"Topic-zy"</span>);</div><div class="line">            messageConsumer = session.createConsumer(destination);</div><div class="line"></div><div class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</div><div class="line">                TextMessage textMessage = (TextMessage) messageConsumer.receive(<span class="number">10000</span>);</div><div class="line">                <span class="keyword">if</span>(textMessage != <span class="literal">null</span>)&#123;</div><div class="line">                    System.out.println(<span class="string">"消费者 2 成功接收到消息： "</span>+textMessage.getText());</div><div class="line">                &#125;<span class="keyword">else</span>&#123;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>先启动消费者 1 和 2，再启动生产者，可以看到控制台输出，消费者 1 、2都接收到了消息:</p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/c1.jpg" alt="image"></p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/c2.jpg" alt="image"></p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/Topic-2.jpg" alt="image"></p>
<p>查看ActiveMQ的管理页面，点击Topics，查看名为 Topic-zy 的主题：    </p>
<p>Number Of Consumers ：表示消费者数目为 2    </p>
<p>Messages Enqueued： 进入队列的消息数为 10    </p>
<p>Messages Dequeued： 出队列的消息，为20 （因为2个消费者） </p>
<p>以上就是直接使用 ActiveMQ 在<strong>点对点</strong>和<strong>发布订阅</strong> 两种模式下收发消息的过程。</p>
<p>下一篇，将介绍<a href="http://youngforzy.top/2018/02/15/ActiveMQ%E7%BB%93%E5%90%88Spring%E6%94%B6%E5%8F%91%E6%B6%88%E6%81%AF/" target="_blank" rel="external">ActiveMQ结合Spring收发消息</a>的过程。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;ActiveMQ的简单使用&quot;&gt;&lt;a href=&quot;#ActiveMQ的简单使用&quot; class=&quot;headerlink&quot; title=&quot;ActiveMQ的简单使用&quot;&gt;&lt;/a&gt;ActiveMQ的简单使用&lt;/h3&gt;&lt;p&gt;ActiveMQ 是一种消息队列，是Apache提供
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="ActiveMQ" scheme="http://yoursite.com/tags/ActiveMQ/"/>
    
      <category term="消息队列" scheme="http://yoursite.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Mysql自动还原脚本（.sh文件）</title>
    <link href="http://yoursite.com/2018/01/25/Mysql%E8%87%AA%E5%8A%A8%E8%BF%98%E5%8E%9F%E8%84%9A%E6%9C%AC/"/>
    <id>http://yoursite.com/2018/01/25/Mysql自动还原脚本/</id>
    <published>2018-01-25T07:12:12.000Z</published>
    <updated>2018-05-27T02:44:12.397Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Mysql自动还原脚本（-sh文件）"><a href="#Mysql自动还原脚本（-sh文件）" class="headerlink" title="Mysql自动还原脚本（.sh文件）"></a>Mysql自动还原脚本（.sh文件）</h3><h4 id="还原数据库的基本指令"><a href="#还原数据库的基本指令" class="headerlink" title="还原数据库的基本指令"></a>还原数据库的基本指令</h4><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">source</span> d:/<span class="keyword">abc</span>.sql</div></pre></td></tr></table></figure>
<p>当连接数据库之后，可以直接使用 以上命令来还原指定数据库。</p>
<h4 id="自动还原脚本"><a href="#自动还原脚本" class="headerlink" title="自动还原脚本"></a>自动还原脚本</h4><p>那么能不能使用脚本的方式自动还原呢？<br><strong>当每次都是还原同一个数据库，或者还原同一个数据库中的指定表时，便可以采用脚本的方式执行。</strong></p>
<p>当数据库备份文件存储在云端时，可采用以下脚本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"></div><div class="line">HOSTNAME = <span class="string">"bd.gameplat2dev.db"</span>         <span class="comment">#数据库信息    </span></div><div class="line">PORT = <span class="string">"1516"</span>                                  <span class="comment">#端口</span></div><div class="line">USERNAME = <span class="string">"username"</span>                          <span class="comment">#用户名</span></div><div class="line">PASSWORD = <span class="string">"123456"</span>                            <span class="comment">#密码</span></div><div class="line"></div><div class="line">DBNAME = <span class="string">"game_product"</span>                        <span class="comment">#数据库名称</span></div><div class="line"><span class="comment">#TABLENAME1 = "t_approve"                      #表名</span></div><div class="line"><span class="comment">#TABLENAME2 = "t_approve_role"  </span></div><div class="line"></div><div class="line"><span class="comment">#sql文件下载路径</span></div><div class="line">URL = <span class="string">"http://osuskkx7k.bkt.clouddn.com/ab.sql"</span></div><div class="line"></div><div class="line"><span class="comment">#定义文件名（自定义）</span></div><div class="line">FILE = <span class="string">"sqlfile.sql"</span></div><div class="line"></div><div class="line"><span class="comment">#下载sql文件</span></div><div class="line">wget <span class="variable">$&#123;URL&#125;</span> -O <span class="variable">$&#123;FILE&#125;</span></div><div class="line"></div><div class="line"><span class="comment">#输出(可无)</span></div><div class="line"><span class="built_in">echo</span> <span class="variable">$&#123;FILE&#125;</span></div><div class="line"></div><div class="line"><span class="comment">#定义 source 命令</span></div><div class="line">restore_sql = <span class="string">"source  <span class="variable">$&#123;FILE&#125;</span>"</span></div><div class="line"></div><div class="line"><span class="comment">#还原指令</span></div><div class="line">mysql -h<span class="variable">$&#123;HOSTNAME&#125;</span>  -P<span class="variable">$&#123;PORT&#125;</span>  -u<span class="variable">$&#123;USERNAME&#125;</span> -p<span class="variable">$&#123;PASSWORD&#125;</span> <span class="variable">$&#123;DBNAME&#125;</span> -e<span class="string">"<span class="variable">$&#123;restore_sql&#125;</span>"</span></div></pre></td></tr></table></figure>
<p><strong>记得另存为时，后缀是 .sh，双击即可运行</strong></p>
<h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><ul>
<li>若为本地数据库可将数据库名改为 localhost ，端口无需指定</li>
<li>脚本中 wget 工具需要安装</li>
<li>若sql文件不是存储云端，可直接指定路径</li>
<li>FILE文件名可自定义</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Mysql自动还原脚本（-sh文件）&quot;&gt;&lt;a href=&quot;#Mysql自动还原脚本（-sh文件）&quot; class=&quot;headerlink&quot; title=&quot;Mysql自动还原脚本（.sh文件）&quot;&gt;&lt;/a&gt;Mysql自动还原脚本（.sh文件）&lt;/h3&gt;&lt;h4 id=&quot;还
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Mysql" scheme="http://yoursite.com/tags/Mysql/"/>
    
      <category term="自动还原脚本" scheme="http://yoursite.com/tags/%E8%87%AA%E5%8A%A8%E8%BF%98%E5%8E%9F%E8%84%9A%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>Map 的4种遍历方式及比较</title>
    <link href="http://yoursite.com/2018/01/07/Map%20%E7%9A%844%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%E5%8F%8A%E6%AF%94%E8%BE%83/"/>
    <id>http://yoursite.com/2018/01/07/Map 的4种遍历方式及比较/</id>
    <published>2018-01-07T07:12:12.000Z</published>
    <updated>2018-04-14T16:37:56.168Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Map-的4种遍历方式及比较"><a href="#Map-的4种遍历方式及比较" class="headerlink" title="Map 的4种遍历方式及比较"></a>Map 的4种遍历方式及比较</h3><h4 id="KeySet"><a href="#KeySet" class="headerlink" title="KeySet"></a>KeySet</h4><p>第一种方式：   <strong>keySet 其实遍历了两次，第一次获取Iterator，第二次根据key获取value，因此性能较差。</strong><br><figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> testKetSet(Map&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt; <span class="built_in">map</span>) &#123;</div><div class="line">    Set&lt;<span class="keyword">String</span>&gt; keys = <span class="built_in">map</span>.keySet();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">String</span> <span class="built_in">key</span> : keys) &#123;</div><div class="line">        <span class="keyword">String</span> value =  <span class="built_in">map</span>.<span class="built_in">get</span>(<span class="built_in">key</span>);</div><div class="line">        System.out.<span class="built_in">println</span>(<span class="string">"key: "</span>+ <span class="built_in">key</span> + <span class="string">"  value: "</span> + value );</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="EntrySet"><a href="#EntrySet" class="headerlink" title="EntrySet"></a>EntrySet</h4><p>第二种方式: <strong>entrySet 优于keySet，因为一次就把key和value放入了entry)</strong><br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">public</span> void testEntrySet(<span class="meta">Map</span>&lt;<span class="keyword">String, </span><span class="keyword">String&gt; </span><span class="meta">map</span>) &#123;</div><div class="line">      Set&lt;<span class="meta">Map</span>.Entry&lt;<span class="keyword">String, </span><span class="keyword">String&gt;&gt; </span><span class="meta">entry</span> = <span class="meta">map</span>.entrySet()<span class="comment">;</span></div><div class="line">      for (<span class="meta">Map</span>.Entry&lt;<span class="keyword">String, </span><span class="keyword">String&gt; </span><span class="keyword">stringEntry </span>: <span class="meta">entry</span>) &#123;</div><div class="line">          System.out.println(<span class="string">"key: "</span>+ <span class="keyword">stringEntry.getKey() </span>+ <span class="string">"  value: "</span> + <span class="keyword">stringEntry.getValue());</span></div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<h4 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h4><p>第三种方式：<strong>Iterator （可用 it.remove()在遍历时删除）</strong><br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"> public void testIterator(<span class="meta">Map</span>&lt;<span class="keyword">String, </span><span class="keyword">String&gt; </span><span class="meta">map</span>) &#123;</div><div class="line">        <span class="keyword">Iterator&lt;Map.Entry&lt;String, </span><span class="keyword">String&gt;&gt; </span><span class="keyword">it </span>= <span class="meta">map</span>.entrySet().<span class="keyword">iterator();</span></div><div class="line">        <span class="meta">while</span> (<span class="keyword">it.hasNext()) </span>&#123;</div><div class="line">            <span class="meta">Map</span>.Entry&lt;<span class="keyword">String, </span><span class="keyword">String&gt; </span>entry1 = <span class="keyword">it.next();</span></div><div class="line">            System.out.println(<span class="string">"key: "</span>+ entry1.getKey() + <span class="string">"  value: "</span> + entry1.getValue())<span class="comment">;</span></div><div class="line">//            <span class="meta">if</span> (<span class="string">"1"</span>.equals(entry1.getKey())) &#123;</div><div class="line">//                <span class="keyword">it.remove();</span></div><div class="line">//            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h4 id="Lambda-（JDK8）"><a href="#Lambda-（JDK8）" class="headerlink" title="Lambda （JDK8）"></a>Lambda （JDK8）</h4><p>第四种方式：Lambda （<strong>本质是 entrySet</strong>）<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> testLambda(Map&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt; <span class="built_in">map</span>) &#123;</div><div class="line">       <span class="built_in">map</span>.forEach((<span class="built_in">key</span>, value) -&gt; &#123;</div><div class="line">           System.out.<span class="built_in">println</span>(<span class="string">"key: "</span>+ <span class="built_in">key</span> + <span class="string">"  value: "</span> + value );</div><div class="line">       &#125;);</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<h4 id="Values"><a href="#Values" class="headerlink" title="Values"></a>Values</h4><p>获取map所有的值，values()返回的是一个集合 <strong>Collection（可转List/Set）</strong><br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> testValues(Map&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt; <span class="built_in">map</span>) &#123;</div><div class="line">       Collection&lt;<span class="keyword">String</span>&gt; collection = <span class="built_in">map</span>.values();</div><div class="line">       <span class="built_in">for</span> (<span class="keyword">String</span> s : collection) &#123;</div><div class="line">           System.out.<span class="built_in">println</span>(<span class="string">"value: "</span> + s);</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Map-的4种遍历方式及比较&quot;&gt;&lt;a href=&quot;#Map-的4种遍历方式及比较&quot; class=&quot;headerlink&quot; title=&quot;Map 的4种遍历方式及比较&quot;&gt;&lt;/a&gt;Map 的4种遍历方式及比较&lt;/h3&gt;&lt;h4 id=&quot;KeySet&quot;&gt;&lt;a href=&quot;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="HashMap" scheme="http://yoursite.com/tags/HashMap/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java(spring)实现Mysql的定时备份与还原</title>
    <link href="http://yoursite.com/2017/12/25/Java(spring)%E5%AE%9E%E7%8E%B0Mysql%E7%9A%84%E5%AE%9A%E6%97%B6%E5%A4%87%E4%BB%BD%E4%B8%8E%E8%BF%98%E5%8E%9F/"/>
    <id>http://yoursite.com/2017/12/25/Java(spring)实现Mysql的定时备份与还原/</id>
    <published>2017-12-25T11:23:12.000Z</published>
    <updated>2018-02-24T18:19:31.342Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、数据库的定时备份"><a href="#一、数据库的定时备份" class="headerlink" title="一、数据库的定时备份"></a>一、数据库的定时备份</h3><h4 id="备份命令"><a href="#备份命令" class="headerlink" title="备份命令"></a>备份命令</h4><p>Mysql的备份指令：</p>
<ol>
<li>指定数据库：<figure class="highlight subunit"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysqldump -h localhost -uroot -proot  tuser&gt;d:\user_2017<span class="string">-12</span><span class="string">-25</span>_15<span class="string">-42</span><span class="string">-10</span>.sql</div></pre></td></tr></table></figure>
</li>
</ol>
<p>tuser：数据库名<br>user_2017-12-25_15-42-10.sql：文件名</p>
<ol>
<li>指定数据库中的多个表：</li>
</ol>
<figure class="highlight subunit"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysqldump -h localhost -uroot -proot --databases tuser --tables t_user t_user2&gt;d:\user_2017<span class="string">-12</span><span class="string">-25</span>_15<span class="string">-42</span>-two.sql</div></pre></td></tr></table></figure>
<p>在 –tables 之后加上所需备份的表名</p>
<h4 id="定时（Spring-Task）"><a href="#定时（Spring-Task）" class="headerlink" title="定时（Spring-Task）"></a>定时（Spring-Task）</h4><p>了解了mysql的备份命令，那么如何实现定时呢？<br><strong>这里采用Spring的定时任务来实现，基于注解的方式。</strong></p>
<p>主要有两点注意：</p>
<h5 id="1-Spring-xml中开启定时任务注解的配置："><a href="#1-Spring-xml中开启定时任务注解的配置：" class="headerlink" title="1. Spring.xml中开启定时任务注解的配置："></a>1. Spring.xml中开启定时任务注解的配置：</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">&lt;!--开启定时任务注解--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">task:annotation-driven</span> /&gt;</span></div></pre></td></tr></table></figure>
<p>注意在头部引入task的标签及描述</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">xmlns:</span>task=<span class="string">"http://www.springframework.org/schema/task"</span></div><div class="line"><span class="symbol">http:</span>//www.springframework<span class="meta">.org</span>/schema/task</div><div class="line"><span class="symbol">http:</span>//www.springframework<span class="meta">.org</span>/schema/task/spring-task<span class="number">-4.0</span>.xsd</div></pre></td></tr></table></figure>
<h5 id="2-在相应的方法中添加注解-Scheduled"><a href="#2-在相应的方法中添加注解-Scheduled" class="headerlink" title="2.在相应的方法中添加注解@Scheduled"></a>2.在相应的方法中添加注解@Scheduled</h5><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Scheduled</span>(cron=<span class="string">"0/5 * *  * * ? "</span>)   <span class="comment">//每5秒执行一次</span></div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">task1</span><span class="params">()</span></span>&#123;</div><div class="line">    System.out.println(<span class="string">"北京时间："</span>+<span class="keyword">new</span> Date());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意(cron=”0/5 <em> </em>  <em> </em> ? “)  表达式</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">cron=<span class="string">"0/5 * *  * * ? "</span>   表示每隔5s执行一次</div><div class="line">cron=<span class="string">" * * 0/1 * * ? "</span>   表示每隔1小时执行一次</div><div class="line"></div><div class="line">关于cronExpression的配置可以百度</div></pre></td></tr></table></figure>
<p>对数据库  tuser  中的两张表 t_user 和 t_user2 进行备份:<br>代码如下：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//定时备份方案</span></div><div class="line">   @Scheduled(cron=<span class="string">"0/5 * *  * * ? "</span>)   <span class="comment">//每5秒执行一次  @Scheduled(cron=" * * 0/1 * * ? ") 每小时一次</span></div><div class="line">   <span class="keyword">public</span> <span class="keyword">void</span> back()&#123;</div><div class="line">       System.out.<span class="built_in">println</span>(<span class="string">"现在时间是"</span>+<span class="keyword">new</span> Date());</div><div class="line">       Runtime runtime = Runtime.getRuntime();  <span class="comment">//获取Runtime实例</span></div><div class="line">       <span class="keyword">String</span> user = <span class="string">"root"</span>;</div><div class="line">       <span class="keyword">String</span> password = <span class="string">"root"</span>;</div><div class="line">       <span class="keyword">String</span> database1 = <span class="string">"tuser"</span>; <span class="comment">// 需要备份的数据库名</span></div><div class="line">       <span class="keyword">String</span> table1 = <span class="string">"t_user"</span>;</div><div class="line">       <span class="keyword">String</span> table2 = <span class="string">"t_user2"</span>;</div><div class="line">       Date currentDate = <span class="keyword">new</span> Date();</div><div class="line">       SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd_HH-mm-ss"</span>);</div><div class="line">       <span class="keyword">String</span> sdfDate = sdf.format(currentDate);</div><div class="line">       <span class="keyword">String</span> filepath = <span class="string">"d:\\time_"</span> + sdfDate + <span class="string">".sql"</span>; <span class="comment">// 备份的路径地址</span></div><div class="line">       <span class="comment">//执行命令</span></div><div class="line">       <span class="keyword">String</span> stmt = <span class="string">"mysqldump  -h localhost -u "</span>+user+<span class="string">" -p"</span>+password+<span class="string">" --databases "</span>+database1+<span class="string">" --tables "</span>+table1+<span class="string">" "</span>+table2 +<span class="string">" &gt; "</span>+filepath;   </div><div class="line">       System.out.<span class="built_in">println</span>(stmt);</div><div class="line">       <span class="built_in">try</span> &#123;</div><div class="line">           <span class="keyword">String</span>[] command = &#123; <span class="string">"cmd"</span>, <span class="string">"/c"</span>, stmt&#125;;</div><div class="line">           <span class="built_in">Process</span> <span class="built_in">process</span> = runtime.exec(command);</div><div class="line">           InputStream input = <span class="built_in">process</span>.getInputStream();</div><div class="line">           System.out.<span class="built_in">println</span>(IOUtils.toString(input, <span class="string">"UTF-8"</span>));</div><div class="line">           <span class="comment">//若有错误信息则输出</span></div><div class="line">           InputStream errorStream = <span class="built_in">process</span>.getErrorStream();</div><div class="line">           System.out.<span class="built_in">println</span>(IOUtils.toString(errorStream, <span class="string">"UTF-8"</span>));</div><div class="line">       &#125; <span class="built_in">catch</span> (IOException e) &#123;</div><div class="line">           e.printStackTrace();</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h3 id="二、数据库的还原"><a href="#二、数据库的还原" class="headerlink" title="二、数据库的还原"></a>二、数据库的还原</h3><h4 id="还原命令"><a href="#还原命令" class="headerlink" title="还原命令"></a>还原命令</h4><p>可以通过两种方式来进行还原操作。</p>
<h5 id="1-mysql-利用sql文件还原数据库"><a href="#1-mysql-利用sql文件还原数据库" class="headerlink" title="1. mysql 利用sql文件还原数据库"></a>1. mysql 利用sql文件还原数据库</h5><figure class="highlight subunit"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql -h localhost -uroot -proot tuser&lt; D:\user_2017<span class="string">-12</span><span class="string">-25</span>_15<span class="string">-42</span><span class="string">-10</span>.sql</div></pre></td></tr></table></figure>
<h5 id="2-source-命令"><a href="#2-source-命令" class="headerlink" title="2. source 命令"></a>2. source 命令</h5><p>这也是导入sql文件的方式，登录mysql之后，输入：<br><figure class="highlight subunit"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">source d:/game_product2018<span class="string">-01</span><span class="string">-02</span>_10<span class="string">-41</span><span class="string">-30</span>.sql</div></pre></td></tr></table></figure></p>
<p>注意反斜杠的方向，“source d:\ab.sql” 这样会执行失败。<br><strong>注：在Navicat中无法使用 source 命令</strong></p>
<h4 id="还原"><a href="#还原" class="headerlink" title="还原"></a>还原</h4><p>在代码中采用第一种方式实现还原操作</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> restore() &#123;</div><div class="line">    <span class="keyword">String</span> user = <span class="string">"root"</span>;</div><div class="line">    <span class="keyword">String</span> password = <span class="string">"root"</span>;</div><div class="line">    <span class="keyword">String</span> database = <span class="string">"tuser"</span>; <span class="comment">// 需要备份的数据库名</span></div><div class="line">    System.out.<span class="built_in">println</span>(<span class="string">"现在时间是"</span> + <span class="keyword">new</span> Date());</div><div class="line">    Runtime runtime = Runtime.getRuntime();</div><div class="line"></div><div class="line">    <span class="keyword">String</span> cmd = <span class="string">"mysql  -h localhost"</span> + <span class="string">" -u "</span> + user + <span class="string">" -p"</span> + password + <span class="string">" "</span> + database;</div><div class="line">    System.out.<span class="built_in">println</span>(cmd);</div><div class="line">    <span class="built_in">try</span> &#123;</div><div class="line">        <span class="keyword">String</span> filePath =  <span class="string">"D:\\user_2017-12-25_15-42-10.sql"</span>; <span class="comment">// sql文件路径</span></div><div class="line">        <span class="keyword">String</span> stmt = cmd + <span class="string">" &lt; "</span> + filePath;</div><div class="line">        <span class="keyword">String</span>[] command = &#123;<span class="string">"cmd"</span>, <span class="string">"/c"</span>, stmt&#125;;</div><div class="line">        <span class="built_in">Process</span> <span class="built_in">process</span> = runtime.exec(command);</div><div class="line">        <span class="comment">//若有错误信息则输出</span></div><div class="line">        InputStream errorStream = <span class="built_in">process</span>.getErrorStream();</div><div class="line">        System.out.<span class="built_in">println</span>(IOUtils.toString(errorStream, <span class="string">"utf-8"</span>));</div><div class="line">        <span class="comment">//等待操作</span></div><div class="line">        <span class="keyword">int</span> processComplete = <span class="built_in">process</span>.waitFor();</div><div class="line">        <span class="built_in">if</span> (processComplete == <span class="number">0</span>) &#123;</div><div class="line">            System.out.<span class="built_in">println</span>(<span class="string">"还原成功."</span>);</div><div class="line">        &#125; <span class="built_in">else</span> &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"还原数据库失败."</span>);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="built_in">catch</span> (Exception e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、数据库的定时备份&quot;&gt;&lt;a href=&quot;#一、数据库的定时备份&quot; class=&quot;headerlink&quot; title=&quot;一、数据库的定时备份&quot;&gt;&lt;/a&gt;一、数据库的定时备份&lt;/h3&gt;&lt;h4 id=&quot;备份命令&quot;&gt;&lt;a href=&quot;#备份命令&quot; class=&quot;head
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="spring定时任务" scheme="http://yoursite.com/tags/spring%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    
      <category term="Mysql备份还原" scheme="http://yoursite.com/tags/Mysql%E5%A4%87%E4%BB%BD%E8%BF%98%E5%8E%9F/"/>
    
  </entry>
  
  <entry>
    <title>中缀表达式转后缀表达式（逆波兰）</title>
    <link href="http://yoursite.com/2017/12/18/%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E9%80%86%E6%B3%A2%E5%85%B0%EF%BC%89/"/>
    <id>http://yoursite.com/2017/12/18/中缀表达式转后缀表达式（逆波兰）/</id>
    <published>2017-12-18T11:23:12.000Z</published>
    <updated>2018-02-24T18:13:36.958Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、中缀表达式转后缀表达式"><a href="#一、中缀表达式转后缀表达式" class="headerlink" title="一、中缀表达式转后缀表达式"></a>一、中缀表达式转后缀表达式</h3><p>中缀表达式就是普通的表达式。如：9+（3-1）*3+10/2<br>后缀表达式是一种不需要括号的表示法，又叫逆波兰表达式。</p>
<p>上面的式子用后缀法表示：9 3 1 - 3 * + 10 2 / +</p>
<p>那么如何转化成后缀表达式？</p>
<h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>从左往右遍历：<br><strong>1. 如果是数字则直接输出</strong><br><strong>2. 如果是符号则入栈，但要通过以下判断</strong></p>
<ul>
<li><strong>若该符号c是右括号或者c的优先级≤栈顶符号，则栈中元素依次出栈输出，c入栈</strong></li>
</ul>
<p>代码实现：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//中缀转后缀表达式（逆波兰）------栈实现</span></div><div class="line"><span class="keyword">public</span> class NiPoLan2 &#123;</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</div><div class="line">		<span class="comment">//创建栈</span></div><div class="line">		Stack&lt;<span class="keyword">String</span>&gt; s = <span class="keyword">new</span> Stack&lt;<span class="keyword">String</span>&gt;();</div><div class="line">		<span class="keyword">String</span> s1 = <span class="string">"9+(3-1)*3+10/2"</span>; 	<span class="comment">//例子  (1-2)*(4+5)   9+(3-1)*3+10/2</span></div><div class="line">		<span class="keyword">char</span>[] o = s1.toCharArray();</div><div class="line">		<span class="keyword">String</span> r = <span class="string">""</span>;	<span class="comment">//字符串r记录输出</span></div><div class="line">		<span class="comment">//遍历</span></div><div class="line">		<span class="built_in">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;o.length;i++)&#123;</div><div class="line">		<span class="comment">//符号是数字</span></div><div class="line">		<span class="built_in">if</span>(Character.isDigit(o[i]))&#123;</div><div class="line">			<span class="comment">//判断两位整数，如10</span></div><div class="line">			<span class="built_in">if</span>(i&lt;o.length<span class="number">-1</span>&amp;&amp;Character.isDigit(o[i+<span class="number">1</span>]))&#123;</div><div class="line">				r = r+o[i]+o[i+<span class="number">1</span>]+<span class="string">" "</span>;</div><div class="line">				i++; <span class="comment">//减少一次循环</span></div><div class="line">				<span class="built_in">continue</span>;</div><div class="line">			&#125;</div><div class="line">			r = r+o[i]+<span class="string">" "</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="comment">//符号是 (</span></div><div class="line">		<span class="built_in">if</span>(o[i]==<span class="string">'('</span>)&#123;</div><div class="line">			s.push(o[i]+<span class="string">""</span>);</div><div class="line">		&#125;</div><div class="line">		<span class="comment">//符号是+ or -</span></div><div class="line">		<span class="built_in">if</span>(o[i]==<span class="string">'+'</span>|o[i]==<span class="string">'-'</span>)&#123;</div><div class="line">			<span class="comment">//栈不为空，且有乘除符号，则弹出</span></div><div class="line">			<span class="built_in">if</span>(!s.isEmpty()&amp;&amp;(s.<span class="built_in">peek</span>().equals(<span class="string">"*"</span>)|s.<span class="built_in">peek</span>().equals(<span class="string">"/"</span>)))&#123;</div><div class="line">				<span class="comment">//全部出栈</span></div><div class="line">				<span class="built_in">while</span>(!s.isEmpty())&#123;</div><div class="line">					r = r + s.pop()+<span class="string">" "</span>;</div><div class="line">				&#125;</div><div class="line">				<span class="comment">//出栈后，再将+-入栈</span></div><div class="line">				s.push(o[i]+<span class="string">""</span>);</div><div class="line">				<span class="comment">//栈为空</span></div><div class="line">			&#125;<span class="built_in">else</span>&#123;</div><div class="line">				s.push(o[i]+<span class="string">""</span>);</div><div class="line">				System.out.<span class="built_in">println</span>(o[i]+<span class="string">""</span>);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="comment">//符号是右括号则配对</span></div><div class="line">		<span class="built_in">if</span>(o[i]==<span class="string">')'</span>)&#123;</div><div class="line">			<span class="keyword">String</span> a = s.pop();</div><div class="line">			System.out.<span class="built_in">println</span>(a);</div><div class="line">			r = r + a+<span class="string">" "</span>;</div><div class="line">			s.pop();</div><div class="line">		&#125;</div><div class="line">		<span class="comment">//符号是乘除</span></div><div class="line">		<span class="built_in">if</span>(o[i]==<span class="string">'*'</span>|o[i]==<span class="string">'/'</span>)&#123;</div><div class="line">			System.out.<span class="built_in">println</span>(s.<span class="built_in">peek</span>());</div><div class="line">			<span class="comment">//栈顶是加减、括号</span></div><div class="line">			<span class="built_in">if</span>(s.isEmpty())&#123;</div><div class="line">				s.push(o[i]+<span class="string">""</span>);</div><div class="line">			&#125;<span class="built_in">else</span> <span class="built_in">if</span>(s.<span class="built_in">peek</span>().equals(<span class="string">"+"</span>)|s.<span class="built_in">peek</span>().equals(<span class="string">"-"</span>)|s.<span class="built_in">peek</span>().equals(<span class="string">"("</span>))&#123;	<span class="comment">//s.peek()=="-"|s.peek()=="+"|s.peek()=="("</span></div><div class="line">				s.push(o[i]+<span class="string">""</span>);</div><div class="line">			&#125;</div><div class="line">		    <span class="comment">//栈顶是乘除，则出栈</span></div><div class="line">			<span class="built_in">else</span> <span class="built_in">if</span>(s.<span class="built_in">peek</span>()==<span class="string">"*"</span>|s.<span class="built_in">peek</span>()==<span class="string">"/"</span>)&#123;</div><div class="line">				<span class="comment">//全部出栈</span></div><div class="line">				<span class="built_in">while</span>(!s.isEmpty())&#123;</div><div class="line">					r = r + s.pop();</div><div class="line">				&#125;</div><div class="line">				s.push(o[i]+<span class="string">""</span>);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="comment">//最后栈中不为空，全部出栈</span></div><div class="line">		<span class="built_in">while</span>(!s.isEmpty())&#123;</div><div class="line">			r = r + s.pop()+<span class="string">" "</span>; </div><div class="line">		&#125;</div><div class="line">		System.out.<span class="built_in">println</span>(r);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">9 </span><span class="number">3</span> <span class="number">1</span> - <span class="number">3</span> * + <span class="number">10</span> <span class="number">2</span> / +</div></pre></td></tr></table></figure></p>
<h3 id="二、计算后缀表达式"><a href="#二、计算后缀表达式" class="headerlink" title="二、计算后缀表达式"></a>二、计算后缀表达式</h3><p>中缀表达式容易计算：9+（3-1）*3+10/2=20<br>那么后缀表达式如何计算呢？</p>
<p>还是上面的例子： 9 3 1 - 3 * + 10 2 / + </p>
<h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h4><p><strong>从左往右遍历：</strong>   </p>
<ol>
<li><strong>遇到数字就入栈</strong>  </li>
<li><strong>遇到符号就将栈顶的两个元素取出计算，将结果入栈；最后栈中的数就是最终结果</strong></li>
</ol>
<p>代码实现：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> class NiPoLan &#123;</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</div><div class="line">		</div><div class="line">		Stack&lt;Integer&gt; s = <span class="keyword">new</span> Stack&lt;Integer&gt;();</div><div class="line">		<span class="keyword">String</span> s1 = <span class="string">"9 3 1 - 3 * + 10 2 / +"</span>;</div><div class="line">		<span class="keyword">String</span>[] r = s1.<span class="built_in">split</span>(<span class="string">" "</span>);				<span class="comment">//转为字符串数组</span></div><div class="line">		System.out.<span class="built_in">println</span>(s1);</div><div class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;r.length;i++)&#123;</div><div class="line">			<span class="comment">//判断字符串r[i]是数字还是符号</span></div><div class="line">			<span class="comment">//r[i]是数字，入栈</span></div><div class="line">			<span class="keyword">if</span>(Character.isDigit(r[i].charAt(<span class="number">0</span>)))&#123;</div><div class="line">				<span class="built_in">int</span> c = Integer.valueOf(r[i]);</div><div class="line">				s.push(c);</div><div class="line">			&#125;<span class="keyword">else</span>&#123;</div><div class="line">				<span class="comment">//r[i]是符号，则运算</span></div><div class="line">				<span class="keyword">switch</span> (r[i]) &#123;</div><div class="line">				<span class="keyword">case</span> <span class="string">"-"</span>:</div><div class="line">					<span class="built_in">int</span> a = s.pop();  </div><div class="line">					<span class="built_in">int</span> b = s.pop();  </div><div class="line">					s.push(b-a);</div><div class="line">					<span class="keyword">break</span>;</div><div class="line">				<span class="keyword">case</span> <span class="string">"+"</span>:</div><div class="line">					 a = s.pop();  </div><div class="line">					 b = s.pop();  </div><div class="line">					s.push(b+a); </div><div class="line">					<span class="keyword">break</span>;</div><div class="line">				<span class="keyword">case</span> <span class="string">"/"</span>:</div><div class="line">					 a = s.pop();  </div><div class="line">					 b = s.pop();  </div><div class="line">					s.push(b/a);</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">				<span class="keyword">case</span> <span class="string">"*"</span>:</div><div class="line">					 a = s.pop();  </div><div class="line">					 b = s.pop();  </div><div class="line">					s.push(b*a);</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">				<span class="keyword">default</span>:</div><div class="line">					<span class="keyword">break</span>;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">	&#125;</div><div class="line">		<span class="comment">//输出结果</span></div><div class="line">		System.out.<span class="built_in">println</span>(s.pop());</div><div class="line">	&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>输出结果：<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">9 </span><span class="number">3</span> <span class="number">1</span> - <span class="number">3</span> * + <span class="number">10</span> <span class="number">2</span> / +</div><div class="line"><span class="number">20</span></div></pre></td></tr></table></figure></p>
<p>结果为 20。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、中缀表达式转后缀表达式&quot;&gt;&lt;a href=&quot;#一、中缀表达式转后缀表达式&quot; class=&quot;headerlink&quot; title=&quot;一、中缀表达式转后缀表达式&quot;&gt;&lt;/a&gt;一、中缀表达式转后缀表达式&lt;/h3&gt;&lt;p&gt;中缀表达式就是普通的表达式。如：9+（3-1）*3+
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="逆波兰表达式" scheme="http://yoursite.com/tags/%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java并发工具类之Semaphore</title>
    <link href="http://yoursite.com/2017/12/12/Java%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%B9%8BSemaphore/"/>
    <id>http://yoursite.com/2017/12/12/Java并发工具类之Semaphore/</id>
    <published>2017-12-12T09:42:18.000Z</published>
    <updated>2018-02-24T18:08:10.476Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、Semaphore的概念"><a href="#一、Semaphore的概念" class="headerlink" title="一、Semaphore的概念"></a>一、Semaphore的概念</h3><p><strong>Semaphore又叫信号量，用来控制同时访问特定资源的线程数量</strong>。它通过协调各个线程，以保证合理地使用公共资源。</p>
<p><strong>Semaphore和CountDownLatch一样，也是维护了一个计数器，其本质是一个共享锁。</strong></p>
<p><strong>Semaphore有公平性和非公平性之分。</strong></p>
<p><strong>Semaphore的工作过程：</strong></p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/timg.jpg" alt="image">  </p>
<ol>
<li>当一个线程想要访问某个共享资源时，它必须要先获取Semaphore；</li>
<li>当Semaphore &gt; 0 时，获取该资源并使Semaphore – 1；</li>
<li>当Semaphore = 0，则表示全部的共享资源已经被其他线程全部占用，线程必须要等待其他线程释放资源；</li>
<li>当有线程释放资源时，Semaphore+1，其他线程可以争抢资源；</li>
</ol>
<h3 id="二、Semaphore的实现分析"><a href="#二、Semaphore的实现分析" class="headerlink" title="二、Semaphore的实现分析"></a>二、Semaphore的实现分析</h3><p>前面分析可知，<strong>Semaphore的实现是共享锁。</strong></p>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>Semaphore有两个构造函数。<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</div><div class="line">        sync = <span class="keyword">new</span> NonfairSync(permits);</div><div class="line">    &#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span> </span>&#123;</div><div class="line">    sync = fair ? <span class="keyword">new</span> FairSync(permits) : <span class="keyword">new</span> NonfairSync(permits);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>第一个构造函数中传入的是资源许可的数量，默认是非公平锁。<br>第二个构造函数传入资源许可的数量和一个boolean变量，该变量可实现公平锁。</p>
<p>Semaphore在使用时有两个主要方法，acquire()方法表示获取一个资源许可，而 release()方法表示释放一个资源许可。</p>
<h4 id="资源获取：acquire-方法"><a href="#资源获取：acquire-方法" class="headerlink" title="资源获取：acquire()方法"></a>资源获取：acquire()方法</h4><p>调用acquire()方法获取一个资源：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        sync.acquireSharedInterruptibly(<span class="number">1</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>该方法调用AQS的acquireSharedInterruptibly()方法，以共享的模式获取同步状态：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></div><div class="line">            <span class="keyword">throws</span> InterruptedException &#123;</div><div class="line">        <span class="keyword">if</span> (Thread.interrupted())</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div><div class="line">        <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</div><div class="line">            doAcquireSharedInterruptibly(arg);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>然后调用tryAcquireShared()方法，该方法由Sync的子类来实现：</p>
<ul>
<li>如果是非公平模式，调用NonfairSync的tryAcquireShared()方法；</li>
<li>如果是公平模式，调用FairSync的tryAcquireShared()方法。</li>
</ul>
<p>在前面的文章 <a href="http://blog.csdn.net/babylove_bale/article/details/78317204" target="_blank" rel="external">ReentrantLock重入锁</a> 中有提到公平与非公平的实现。</p>
<p><strong>非公平模式</strong><br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">final <span class="keyword">int</span> nonfairTryAcquireShared(<span class="keyword">int</span> acquires) &#123;</div><div class="line">            <span class="built_in">for</span> (;;) &#123;</div><div class="line">                <span class="keyword">int</span> <span class="built_in">available</span> = getState();</div><div class="line">                <span class="keyword">int</span> remaining = <span class="built_in">available</span> - acquires;</div><div class="line">                <span class="built_in">if</span> (remaining &lt; <span class="number">0</span> ||</div><div class="line">                    compareAndSetState(<span class="built_in">available</span>, remaining))</div><div class="line">                    <span class="built_in">return</span> remaining;</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p>
<p>remaining 表示剩余的资源许可，如果&lt; 0，表示目前没有剩余的许可。当前线程继续等待。如果remaining &gt;0 则执行CAS操作获取资源许可。</p>
<p><strong>公平模式</strong></p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> <span class="keyword">int</span> tryAcquireShared(<span class="keyword">int</span> acquires) &#123;</div><div class="line">            <span class="built_in">for</span> (;;) &#123;</div><div class="line">                <span class="built_in">if</span> (hasQueuedPredecessors())</div><div class="line">                    <span class="built_in">return</span> <span class="number">-1</span>;</div><div class="line">                <span class="keyword">int</span> <span class="built_in">available</span> = getState();</div><div class="line">                <span class="keyword">int</span> remaining = <span class="built_in">available</span> - acquires;</div><div class="line">                <span class="built_in">if</span> (remaining &lt; <span class="number">0</span> ||</div><div class="line">                    compareAndSetState(<span class="built_in">available</span>, remaining))</div><div class="line">                    <span class="built_in">return</span> remaining;</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p><strong>在公平模式的方法中，增加了一个判断，判断同步队列中是否有等待的线程：</strong></p>
<ul>
<li>有，则插入作为尾节点，线程阻塞；</li>
<li>没有，则参与资源竞争；</li>
</ul>
<p>简而言之，公平模式就是要按等待队列中的顺序获取资源许可。</p>
<h4 id="资源释放：release-方法"><a href="#资源释放：release-方法" class="headerlink" title="资源释放：release()方法"></a>资源释放：release()方法</h4><p>Semaphore调用release()方法释放资源许可，默认释放1个。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</div><div class="line">        sync.releaseShared(<span class="number">1</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>调用AQS的releaseShared()方法：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</div><div class="line">            doReleaseShared();</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>调用Sync中重写的tryReleaseShared()方法（<strong>公平与非公平都是调用该方法</strong>），<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> tryReleaseShared(<span class="keyword">int</span> releases) &#123;</div><div class="line">            <span class="keyword">for</span> (;;) &#123;</div><div class="line">                <span class="keyword">int</span> current = getState();</div><div class="line">                <span class="keyword">int</span> <span class="keyword">next</span> = current + releases;</div><div class="line">                <span class="keyword">if</span> (<span class="keyword">next</span> &lt; current) <span class="comment">// overflow</span></div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum permit count exceeded"</span>);</div><div class="line">                <span class="keyword">if</span> (compareAndSetState(current, <span class="keyword">next</span>))</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p>
<p><strong>next代表如果许可释放成功，可用资源许可的数量。<br>这里可能有多个线程同时释放，因此利用CAS操作将资源许可数量置为next。<br>释放成功后，进入doReleaseShared()唤醒队列中等待的线程。</strong></p>
<p><strong>注：公平模式与非公平模式都是调用该release()方法。</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、Semaphore的概念&quot;&gt;&lt;a href=&quot;#一、Semaphore的概念&quot; class=&quot;headerlink&quot; title=&quot;一、Semaphore的概念&quot;&gt;&lt;/a&gt;一、Semaphore的概念&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Semaphore又叫信号量
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="Semaphore" scheme="http://yoursite.com/tags/Semaphore/"/>
    
  </entry>
  
  <entry>
    <title>Java并发工具类之CyclicBarrier</title>
    <link href="http://yoursite.com/2017/12/08/Java%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%B9%8BCyclicBarrier/"/>
    <id>http://yoursite.com/2017/12/08/Java并发工具类之CyclicBarrier/</id>
    <published>2017-12-08T10:42:18.000Z</published>
    <updated>2018-02-24T18:06:39.939Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、CyclicBarrier的概念"><a href="#一、CyclicBarrier的概念" class="headerlink" title="一、CyclicBarrier的概念"></a>一、CyclicBarrier的概念</h3><p>CyclicBarrier的意思是可循环使用的屏障。<strong>它可以让一组线程到达一个屏障时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有阻塞的线程才会继续执行。</strong></p>
<p>它就好像一道关卡，只有所有的部队（线程）都到了才能放行。</p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/cycle.png" alt="image"></p>
<h3 id="二、CyclicBarrier的实现分析"><a href="#二、CyclicBarrier的实现分析" class="headerlink" title="二、CyclicBarrier的实现分析"></a>二、CyclicBarrier的实现分析</h3><p><strong>部分源码：</strong><br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrier</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition trip = lock.newCondition();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> parties;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Runnable barrierCommand;</div><div class="line">    <span class="keyword">private</span> Generation generation = <span class="keyword">new</span> Generation();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> <span class="keyword">count</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Generation</span> </span>&#123;</div><div class="line">        <span class="keyword">boolean</span> broken = <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    ....</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到，<strong>CyclicBarrier是基于ReentrantLock和Condition实现的。</strong></p>
<ul>
<li>parties 表示拦截线程的数量</li>
<li>barrierCommand 表示所有线程到达屏障后优先执行的命令</li>
<li>Generation 表示屏障循环利用</li>
</ul>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>CyclicBarrier有两个构造函数：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(parties, <span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</div><div class="line">        <span class="keyword">this</span>.parties = parties;</div><div class="line">        <span class="keyword">this</span>.count = parties;</div><div class="line">        <span class="keyword">this</span>.barrierCommand = barrierAction;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>第一个构造函数调用的其实也是第二个构造函数，只是第二个参数barrierAction为null。这个参数其实是一个线程任务命令，用于在所有线程到达屏障时，优先执行该线程任务，方便处理更加复杂的业务场景。</p>
<h4 id="await-方法："><a href="#await-方法：" class="headerlink" title="await()方法："></a>await()方法：</h4><p>每当一个线程调用await()方法表示该线程到达屏障，</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="function"><span class="keyword">return</span> <span class="title">dowait</span><span class="params">(<span class="keyword">false</span>, <span class="number">0</span>L)</span></span>;</div><div class="line">        &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(toe); </div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>进入dowait()方法：</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> dowait(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</div><div class="line">        throws InterruptedException, BrokenBarrierException,</div><div class="line">               TimeoutException &#123;</div><div class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</div><div class="line">        lock.lock();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">final</span> Generation g = generation;</div><div class="line">            </div><div class="line">            <span class="comment">//当前generation“已损坏”，抛出异常</span></div><div class="line">            <span class="keyword">if</span> (g.broken)</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</div><div class="line">                </div><div class="line">            <span class="comment">//如果线程中断，终止CyclicBarrier</span></div><div class="line">            <span class="keyword">if</span> (Thread.interrupted()) &#123;</div><div class="line">                breakBarrier();</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//每当线程进入，计数-1</span></div><div class="line">            <span class="keyword">int</span> <span class="keyword">index</span> = --<span class="keyword">count</span>;</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">index</span> == <span class="number">0</span>) &#123;  <span class="comment">//计数为0时，进入</span></div><div class="line">                <span class="keyword">boolean</span> ranAction = <span class="keyword">false</span>;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    <span class="keyword">final</span> Runnable command = barrierCommand;</div><div class="line">                    <span class="keyword">if</span> (command != <span class="keyword">null</span>)   <span class="comment">//如果有barrierCommand，则优先执行该任务</span></div><div class="line">                        command.run();</div><div class="line">                    ranAction = <span class="keyword">true</span>;</div><div class="line">                    nextGeneration();<span class="comment">//唤醒所有等待线程，并更新generation</span></div><div class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">                &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                    <span class="keyword">if</span> (!ranAction)</div><div class="line">                        breakBarrier();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// loop until tripped, broken, interrupted, or timed out</span></div><div class="line">            <span class="comment">//自旋</span></div><div class="line">            <span class="keyword">for</span> (;;) &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    <span class="keyword">if</span> (!timed)<span class="comment">//如果不是超时等待，则调用Condition.await()方法等待</span></div><div class="line">                        trip.await();</div><div class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0</span>L)<span class="comment">//超时等待，调用Condition.awaitNanos()方法等待</span></div><div class="line">                        nanos = trip.awaitNanos(nanos);</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</div><div class="line">                    <span class="comment">//如果等待过程中，线程被中断，则执行下面的函数。</span></div><div class="line">                    <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</div><div class="line">                        breakBarrier();</div><div class="line">                        <span class="keyword">throw</span> ie;</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                </div><div class="line">                <span class="comment">//当前generation“已损坏”，抛出异常</span></div><div class="line">                <span class="keyword">if</span> (g.broken)</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</div><div class="line">                    </div><div class="line">                <span class="comment">//generation已经更新，返回index</span></div><div class="line">                <span class="keyword">if</span> (g != generation)</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">index</span>;</div><div class="line"></div><div class="line">                <span class="comment">//“超时等待”，并且时间已到,终止CyclicBarrier，并抛出异常</span></div><div class="line">                <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0</span>L) &#123;</div><div class="line">                    breakBarrier();</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            lock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>dowait()的主要处理逻辑如下：如果该线程不是到达的最后一个线程，则它会一直处于等待状态，除非发生以下情况：</p>
<ol>
<li>最后一个线程到达，即index == 0</li>
<li>超出了指定时间（超时等待）</li>
<li>其他的某个线程中断当前线程</li>
<li>其他的某个线程中断另一个等待的线程</li>
<li>其他的某个线程在等待barrier超时</li>
<li>其他的某个线程在此barrier调用reset()方法。reset()方法用于将屏障重置为初始状态。</li>
</ol>
<p>Generation对象描述着CyclicBarrier的更新换代。在CyclicBarrier中，同一批线程属于同一代。当有parties个线程到达barrier，generation就会被更新换代。</p>
<h3 id="三、CyclicBarrier与CountDownLatch的对比"><a href="#三、CyclicBarrier与CountDownLatch的对比" class="headerlink" title="三、CyclicBarrier与CountDownLatch的对比"></a>三、CyclicBarrier与CountDownLatch的对比</h3><p><strong>CyclicBarrier允许一系列线程相互等待对方到达屏障，先到达的线程被阻塞在屏障前，必须等到所有线程都到达了屏障，所有线程才能运行；CountDownLatch允许一个或多个线程等待一些特定的操作完成，而这些操作是在其它的线程中进行的，只有“被等的线程”的操作完成后，“等待的线程”才能执行；</strong></p>
<p><strong>CyclicBarrier强调的是n个线程互相等待，CountDownLatch强调的是1个线程或n个线程等待其他线程操作。</strong></p>
<p><strong>CyclicBarrier的计数器可以循环使用（出现错误可重置计数），CountDownLatch的计数器只能用一次；</strong></p>
<p><strong>CyclicBarrier可以在所有线程到达屏障后先执行一个线程任务，再运行所有线程，用于处理复杂的业务，CountDownLatch不可以。</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、CyclicBarrier的概念&quot;&gt;&lt;a href=&quot;#一、CyclicBarrier的概念&quot; class=&quot;headerlink&quot; title=&quot;一、CyclicBarrier的概念&quot;&gt;&lt;/a&gt;一、CyclicBarrier的概念&lt;/h3&gt;&lt;p&gt;Cyclic
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="CyclicBarrier" scheme="http://yoursite.com/tags/CyclicBarrier/"/>
    
  </entry>
  
  <entry>
    <title>Java并发工具类之CountDownLatch</title>
    <link href="http://yoursite.com/2017/12/03/Java%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%B9%8BCountDownLatch/"/>
    <id>http://yoursite.com/2017/12/03/Java并发工具类之CountDownLatch/</id>
    <published>2017-12-03T10:42:18.000Z</published>
    <updated>2018-02-24T18:04:34.623Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h3><p>CountDownLatch也叫闭锁，是并发包的工具类之一，允许一个或多个线程等待其他线程完成操作后再执行。</p>
<p>回忆之前，我们知道Join方法，用于让当前线程等待join的线程执行结束。</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span><span class="comment">(isAlive()</span>)&#123;</div><div class="line">    wait<span class="comment">(0)</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其原理就是不停地检查join线程是否存活，如果存活则一直等待。<br>CountDownLatch也可以实现join的功能，且功能更多。  </p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/CountDownLatch.png" alt="image"></p>
<p>CountDownLatch是通过一个计数器来实现的，当new 一个CountDownLatch对象的时候需要传入该计数器值。<br>CountDownLatch有两个最主要的方法await()和countDown()。</p>
<p>当一个线程调用await()时会阻塞；每当一个其他线程完成自己的任务调用countDown()后，计数器的值就会减1。当计数器的值为0时，就表示所有的线程均已经完成了任务，然后阻塞的线程就可以继续执行了。</p>
<h3 id="二、实现分析"><a href="#二、实现分析" class="headerlink" title="二、实现分析"></a>二、实现分析</h3><p><strong>部分源码</strong>：<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatch</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</div><div class="line">    <span class="comment">//内部类Sync（继承AQS）</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</div><div class="line">        Sync(<span class="keyword">int</span> <span class="keyword">count</span>) &#123;</div><div class="line">            setState(<span class="keyword">count</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//重写</span></div><div class="line">        <span class="keyword">protected</span> <span class="keyword">int</span> tryAcquireShared(<span class="keyword">int</span> acquires) &#123;</div><div class="line">            <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">-1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">protected</span> <span class="keyword">boolean</span> tryReleaseShared(<span class="keyword">int</span> releases) &#123;</div><div class="line">            <span class="keyword">for</span> (;;) &#123;</div><div class="line">                <span class="keyword">int</span> c = getState();</div><div class="line">                <span class="keyword">if</span> (c == <span class="number">0</span>)</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">                <span class="keyword">int</span> nextc = c<span class="number">-1</span>;</div><div class="line">                <span class="keyword">if</span> (compareAndSetState(c, nextc))</div><div class="line">                    <span class="keyword">return</span> nextc == <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//构造方法</span></div><div class="line">     <span class="keyword">public</span> CountDownLatch(<span class="keyword">int</span> <span class="keyword">count</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">count</span> &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"count &lt; 0"</span>);</div><div class="line">        <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(<span class="keyword">count</span>);</div><div class="line">    &#125;</div><div class="line">    ....</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到，CountDownLatch的实现同样依赖AQS，可见AQS作用之大。<br>观察Sync重写的方法（tryAcquireShared、tryReleaseShared），我们可以断定：<br><strong>CountDownLatch使用的是共享锁。</strong></p>
<h4 id="await-的实现"><a href="#await-的实现" class="headerlink" title="await()的实现"></a>await()的实现</h4><p>调用await()方法会阻塞当前线程，直到计数器为0或被中断。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        sync.acquireSharedInterruptibly(<span class="number">1</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>可以看到，其实调用了AQS的acquireSharedInterruptibly()方法：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></div><div class="line">            <span class="keyword">throws</span> InterruptedException &#123;</div><div class="line">        <span class="keyword">if</span> (Thread.interrupted())</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div><div class="line">        <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</div><div class="line">            doAcquireSharedInterruptibly(arg);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>该方法中，如果线程被中断则抛出异常；否则尝试获取锁。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">-1</span>;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>尝试获取锁时调用了Sync重写的tryAcquireShared()方法：<br>很简单只有一行代码，但却是CountDownLatch的原理：<strong>如果同步状态为0（计数器值为0）那么返回1，表示获取锁成功；否则返回-1，获取锁失败</strong>，并进入doAcquireSharedInterruptibly()方法：</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">private void doAcquireSharedInterruptibly(int arg)</div><div class="line">        throws InterruptedException &#123;</div><div class="line">        final <span class="keyword">Node</span> <span class="title">node</span> = addWaiter(<span class="keyword">Node</span>.<span class="title">SHARED</span>);</div><div class="line">        boolean failed = <span class="literal">true</span>;</div><div class="line">        try &#123;</div><div class="line">            for (;;) &#123;</div><div class="line">                final <span class="keyword">Node</span> <span class="title">p</span> = <span class="keyword">node</span>.<span class="title">predecessor</span>();</div><div class="line">                if (p == head) &#123;</div><div class="line">                    int r = tryAcquireShared(arg);</div><div class="line">                    //注意r只会等于 <span class="number">0</span> <span class="keyword">or</span> -<span class="number">1</span>；</div><div class="line">                    if (r &gt;= <span class="number">0</span>) &#123;</div><div class="line">                        setHeadAndPropagate(<span class="keyword">node</span><span class="title">, r</span>);</div><div class="line">                        p.next = null; // help GC</div><div class="line">                        failed = <span class="literal">false</span>;</div><div class="line">                        return;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                if (shouldParkAfterFailedAcquire(p, <span class="keyword">node</span><span class="title">) &amp;&amp;</span></div><div class="line">                    parkAndCheckInterrupt())</div><div class="line">                    throw new InterruptedException();</div><div class="line">            &#125;</div><div class="line">        &#125; finally &#123;</div><div class="line">            if (failed)</div><div class="line">                cancelAcquire(<span class="keyword">node</span><span class="title">);</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>该方法在前面共享锁的文章中有提到，它是一个自旋尝试获取锁的方法，这里不再赘述。<strong>注意18行的代码：int r = tryAcquireShared(arg)，在获取同步状态时只会返回两个值0和-1。</strong></p>
<h4 id="countDown-的实现"><a href="#countDown-的实现" class="headerlink" title="countDown()的实现"></a>countDown()的实现</h4><p>每次调用countDown()时，计数器的数量就会减1。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</div><div class="line">        sync.releaseShared(<span class="number">1</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>调用的是AQS的releaseShared()方法，释放同步状态：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</div><div class="line">            doReleaseShared();</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>进入releaseShared()方法，调用Sync重写的tryReleaseShared()方法：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</div><div class="line">            <span class="keyword">for</span> (;;) &#123;</div><div class="line">                <span class="keyword">int</span> c = getState();</div><div class="line">                <span class="keyword">if</span> (c == <span class="number">0</span>)</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">                <span class="keyword">int</span> nextc = c<span class="number">-1</span>;</div><div class="line">                <span class="keyword">if</span> (compareAndSetState(c, nextc))</div><div class="line">                    <span class="keyword">return</span> nextc == <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p>
<p>可以看到，<strong>该方法自旋CAS操作释放同步状态（可能多个线程同时调用countDown()方法，所以用CAS保证原子性），计数器每次-1，但是直到同步状态为0（计数器为0）时，才返回true</strong>。然后进入doReleaseShared()方法，唤醒阻塞的线程，使其从await()方法退出。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>CountDownLatch的内部实现是共享锁。</strong></p>
<p><strong>创建CountDownLatch时，需要传入计数器的初始值，可以理解为共享锁的总次数。</strong><br><strong>当一个线程调用await()方法，会检查计数器的值，不为0则阻塞直到为0。<br>当其他线程调用countDown()方法时（可以一个线程调用多次），会释放共享状态，计数器-1。</strong><br><strong>当计数器减为0时，阻塞的线程才会运行。</strong></p>
<h3 id="三、应用场景"><a href="#三、应用场景" class="headerlink" title="三、应用场景"></a>三、应用场景</h3><p>CountDownLatch的应用场景：<strong>主线程等到N个子线程执行完毕之后，再继续往下执行。</strong> 如跑步比赛统计排名、启动程序等。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> </span>&#123;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> <span class="type">CountDownLatch</span> cd = <span class="keyword">new</span> <span class="type">CountDownLatch</span>(<span class="number">5</span>);</div><div class="line">	<span class="comment">/*</span></div><div class="line">	 * 飞船类</div><div class="line">	 */</div><div class="line">	 <span class="class"><span class="keyword">class</span> <span class="title">Plane</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</div><div class="line">		 <span class="meta">@Override</span></div><div class="line">		public void run() &#123;</div><div class="line">			<span class="type">System</span>.out.println(<span class="string">"飞船准备就绪，倒计时5s："</span>);</div><div class="line">			<span class="type">System</span>.out.println(cd.getCount());<span class="comment">//计数器的值</span></div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				cd.await();</div><div class="line">			&#125; <span class="keyword">catch</span> (<span class="type">InterruptedException</span> e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">			<span class="type">System</span>.out.println(<span class="string">"飞船起飞啦！！！！"</span>);</div><div class="line">		&#125;</div><div class="line">	 &#125;</div><div class="line">	 <span class="comment">/*</span></div><div class="line">	 * 倒计时类</div><div class="line">	 */</div><div class="line">	 <span class="class"><span class="keyword">class</span> <span class="title">Time</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</div><div class="line">		 <span class="meta">@Override</span></div><div class="line">		public void run() &#123;</div><div class="line">			 <span class="keyword">for</span>(int i=<span class="number">5</span>;i&gt;<span class="number">0</span>;i--)&#123;</div><div class="line">				 <span class="type">System</span>.out.println(<span class="string">"起飞倒计时："</span>+i+<span class="string">"s"</span>);</div><div class="line">				 cd.countDown();</div><div class="line">			 &#125;</div><div class="line">		&#125;</div><div class="line">	 &#125;</div><div class="line">	</div><div class="line">	public static void main(<span class="type">String</span>[] args) &#123;</div><div class="line">		<span class="type">CountDownLatchDemo</span> cdemo = <span class="keyword">new</span> <span class="type">CountDownLatchDemo</span>();</div><div class="line">		<span class="type">Plane</span> p = cdemo.<span class="keyword">new</span> <span class="type">Plane</span>();</div><div class="line">		p.start();</div><div class="line">		<span class="type">Time</span> t = cdemo.<span class="keyword">new</span> <span class="type">Time</span>();</div><div class="line">		t.start();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出结果：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">飞船准备就绪，倒计时<span class="number">5</span>s：</div><div class="line"><span class="number">5</span></div><div class="line">起飞倒计时：<span class="number">5</span>s</div><div class="line">起飞倒计时：<span class="number">4</span>s</div><div class="line">起飞倒计时：<span class="number">3</span>s</div><div class="line">起飞倒计时：<span class="number">2</span>s</div><div class="line">起飞倒计时：<span class="number">1</span>s</div><div class="line">飞船起飞啦！！！！</div></pre></td></tr></table></figure></p>
<p><strong>当调用CountDownLatch的countDown方法时，计数器N就会-1，无论是在多个线程调用，还是一个线程调用多次（上面的例子就是在一个线程中多次调用）。</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、概念&quot;&gt;&lt;a href=&quot;#一、概念&quot; class=&quot;headerlink&quot; title=&quot;一、概念&quot;&gt;&lt;/a&gt;一、概念&lt;/h3&gt;&lt;p&gt;CountDownLatch也叫闭锁，是并发包的工具类之一，允许一个或多个线程等待其他线程完成操作后再执行。&lt;/p&gt;
&lt;p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="CountDownLatch" scheme="http://yoursite.com/tags/CountDownLatch/"/>
    
  </entry>
  
  <entry>
    <title>Java并发之Condition的实现分析</title>
    <link href="http://yoursite.com/2017/12/01/Java%E5%B9%B6%E5%8F%91%E4%B9%8BCondition%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2017/12/01/Java并发之Condition的实现分析/</id>
    <published>2017-12-01T07:42:18.000Z</published>
    <updated>2018-02-24T18:01:24.796Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、Condition的概念"><a href="#一、Condition的概念" class="headerlink" title="一、Condition的概念"></a>一、Condition的概念</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>回忆synchronized关键字，它配合Object的wait()、notify()系列方法可以实现等待/通知模式。</p>
<p>对于Lock，通过Condition也可以实现等待/通知模式。</p>
<p>Condition是一个接口。<br>Condition接口的实现类是Lock（AQS）中的ConditionObject。<br>Lock接口中有个 newCondition()方法，通过这个方法可以获得Condition对象（其实就是ConditionObject）。<br>因此，<strong>通过Lock对象可以获得Condition对象。</strong><br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Lock lock  = <span class="keyword">new</span> <span class="type">ReentrantLock</span>();</div><div class="line">Condition c1 = lock.<span class="keyword">new</span><span class="type">Condition</span>();</div><div class="line">Condition c2 = lock.<span class="keyword">new</span><span class="type">Condition</span>();</div></pre></td></tr></table></figure></p>
<h3 id="二、Condition的实现分析"><a href="#二、Condition的实现分析" class="headerlink" title="二、Condition的实现分析"></a>二、Condition的实现分析</h3><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>ConditionObject类是AQS的内部类，实现了Condition接口。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionObject</span> <span class="keyword">implements</span> <span class="title">Condition</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> &#123;</span></div><div class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</div><div class="line">        ...</div></pre></td></tr></table></figure>
<p>可以看到，等待队列和同步队列一样，使用的都是同步器AQS中的节点类Node。<br>同样拥有首节点和尾节点，<br>每个Condition对象都包含着一个FIFO队列。<br>结构图：</p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/condition.jpg" alt="image"></p>
<h4 id="等待"><a href="#等待" class="headerlink" title="等待"></a>等待</h4><p>调用Condition的await()方法会使线程进入等待队列，并释放锁，线程状态变为等待状态。<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public final void await() throws InterruptedException &#123;</div><div class="line">            if (Thread.interrupted())</div><div class="line">                throw new InterruptedException();</div><div class="line">            <span class="keyword">Node</span> <span class="title">node</span> = addConditionWaiter();</div><div class="line">            //释放同步状态（锁）</div><div class="line">            int savedState = fullyRelease(<span class="keyword">node</span><span class="title">);</span></div><div class="line">            int interruptMode = <span class="number">0</span>;</div><div class="line">            //判断节点是否放入同步对列</div><div class="line">            while (!isOnSyncQueue(<span class="keyword">node</span><span class="title">)) &#123;</span></div><div class="line">                //阻塞</div><div class="line">                LockSupport.park(this);</div><div class="line">                //如果已经中断了，则退出</div><div class="line">                if ((interruptMode = checkInterruptWhileWaiting(<span class="keyword">node</span><span class="title">)) != 0</span>)</div><div class="line">                    break;</div><div class="line">            &#125;</div><div class="line">            if (acquireQueued(<span class="keyword">node</span><span class="title">, savedState</span>) &amp;&amp; interruptMode != THROW_IE)</div><div class="line">                interruptMode = REINTERRUPT;</div><div class="line">            if (<span class="keyword">node</span>.<span class="title">nextWaiter</span> != null) // clean up if cancelled</div><div class="line">                unlinkCancelledWaiters();</div><div class="line">            if (interruptMode != <span class="number">0</span>)</div><div class="line">                reportInterruptAfterWait(interruptMode);</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p>
<p>分析上述方法的大概过程：</p>
<ol>
<li>将当前线程创建为节点，加入等待队列</li>
<li>释放锁，唤醒同步队列中的后继节点</li>
<li>while循环判断节点是否放入同步队列：</li>
</ol>
<ul>
<li>没有放入，则阻塞，继续while循环（如果已经中断了，则退出）</li>
<li>放入，则退出while循环，执行后面的判断</li>
</ul>
<ol>
<li>退出while说明节点已经在同步队列中，调用acquireQueued()方法加入同步状态竞争。</li>
<li>竞争到锁后从await()方法返回，即退出该方法。  </li>
</ol>
<p><img src="http://osuskkx7k.bkt.clouddn.com/enterCon.png" alt="image"></p>
<p><strong>addConditionWaiter()方法：</strong><br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">private <span class="keyword">Node</span> <span class="title">addConditionWaiter</span>() &#123;</div><div class="line">            <span class="keyword">Node</span> <span class="title">t</span> = lastWaiter;</div><div class="line">            if (t != null &amp;&amp; t.waitStatus != <span class="keyword">Node</span>.<span class="title">CONDITION</span>) &#123;</div><div class="line">                //清除条件队列中所有状态不为Condition的节点</div><div class="line">                unlinkCancelledWaiters();</div><div class="line">                t = lastWaiter;</div><div class="line">            &#125;</div><div class="line">            //将该线程创建节点，放入等待队列</div><div class="line">            <span class="keyword">Node</span> <span class="title">node</span> = new <span class="keyword">Node</span><span class="title">(Thread</span>.currentThread(), <span class="keyword">Node</span>.<span class="title">CONDITION</span>);</div><div class="line">            if (t == null)</div><div class="line">                firstWaiter = <span class="keyword">node</span><span class="title">;</span></div><div class="line">            else</div><div class="line">                t.nextWaiter = <span class="keyword">node</span><span class="title">;</span></div><div class="line">            lastWaiter = <span class="keyword">node</span><span class="title">;</span></div><div class="line">            return <span class="keyword">node</span><span class="title">;</span></div><div class="line">        &#125;</div></pre></td></tr></table></figure></p>
<p>过程分析：同步队列的首节点移动到等待队列。加入尾节点之前会清除所有状态不为Condition的节点。</p>
<hr>
<h4 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h4><p>调用Condition的signal()方法，可以唤醒等待队列的首节点（等待时间最长），唤醒之前会将该节点移动到同步队列中。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="comment">//判断是否获取了锁</span></div><div class="line">            <span class="keyword">if</span> (!isHeldExclusively())</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</div><div class="line">            Node first = firstWaiter;</div><div class="line">            <span class="keyword">if</span> (first != <span class="keyword">null</span>)</div><div class="line">                doSignal(first);</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>过程：</p>
<ol>
<li>先判断当前线程是否获取了锁</li>
<li>然后对首节点调用doSignal()方法</li>
</ol>
<figure class="highlight q"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">private void doSignal(Node <span class="built_in">first</span>) &#123;</div><div class="line">            <span class="keyword">do</span> &#123;</div><div class="line">                if ( (firstWaiter = <span class="built_in">first</span>.nextWaiter) == <span class="built_in">null</span>)</div><div class="line">                    lastWaiter = <span class="built_in">null</span>;</div><div class="line">                <span class="built_in">first</span>.nextWaiter = <span class="built_in">null</span>;</div><div class="line">            &#125; <span class="keyword">while</span> (!transferForSignal(<span class="built_in">first</span>) &amp;&amp;</div><div class="line">                     (<span class="built_in">first</span> = firstWaiter) != <span class="built_in">null</span>);</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>过程：</p>
<ol>
<li>修改首节点</li>
<li>调用transferForSignal()方法将节点移动到同步队列</li>
</ol>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">final boolean transferForSignal(<span class="keyword">Node</span> <span class="title">node</span>) &#123;</div><div class="line">        //将节点状态变为<span class="number">0</span>   </div><div class="line">        if (!compareAndSetWaitStatus(<span class="keyword">node</span><span class="title">, Node</span>.CONDITION, <span class="number">0</span>))</div><div class="line">            return <span class="literal">false</span>;</div><div class="line">        //将该节点加入同步队列</div><div class="line">        <span class="keyword">Node</span> <span class="title">p</span> = enq(<span class="keyword">node</span><span class="title">);</span></div><div class="line">        int ws = p.waitStatus;</div><div class="line">        //如果结点p的状态为cancel 或者修改waitStatus失败，则直接唤醒</div><div class="line">        if (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, <span class="keyword">Node</span>.<span class="title">SIGNAL</span>))</div><div class="line">            LockSupport.unpark(<span class="keyword">node</span>.<span class="title">thread</span>);</div><div class="line">        return <span class="literal">true</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>调用同步器的enq方法，将节点移动到同步队列，<br>满足条件后使用LockSupport唤醒该线程。  </p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/signalcon.png" alt="image"></p>
<hr>
<p>当Condition调用signalAll()方法：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> signalAll() &#123;</div><div class="line">            <span class="keyword">if</span> (!isHeldExclusively())</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</div><div class="line">            Node first = firstWaiter;</div><div class="line">            <span class="keyword">if</span> (first != <span class="keyword">null</span>)</div><div class="line">                doSignalAll(first);</div><div class="line">        &#125;</div><div class="line"><span class="keyword">private</span> <span class="keyword">void</span> doSignalAll(Node first) &#123;</div><div class="line">            lastWaiter = firstWaiter = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">do</span> &#123;</div><div class="line">                Node <span class="keyword">next</span> = first.nextWaiter;</div><div class="line">                first.nextWaiter = <span class="keyword">null</span>;</div><div class="line">                transferForSignal(first);</div><div class="line">                first = <span class="keyword">next</span>;</div><div class="line">            &#125; <span class="keyword">while</span> (first != <span class="keyword">null</span>);</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p>
<p>可以看到doSignalAll()方法使用了do-while循环来唤醒每一个等待队列中的节点，直到first为null时，停止循环。</p>
<p>一句话总结signalAll()的作用：<strong>将等待队列中的全部节点移动到同步队列中，并唤醒每个节点的线程。</strong></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>整个过程可以分为三步：</p>
<p>第一步：一个线程获取锁后，通过调用Condition的await()方法，会将当前线程先加入到等待队列中，并释放锁。然后就在await()中的一个while循环中判断节点是否已经在同步队列，是则尝试获取锁，否则一直阻塞。</p>
<p>第二步：当线程调用signal()方法后，程序首先检查当前线程是否获取了锁，然后通过doSignal(Node first)方法将节点移动到同步队列，并唤醒节点中的线程。</p>
<p>第三步：被唤醒的线程，将从await()中的while循环中退出来，然后调用acquireQueued()方法竞争同步状态。竞争成功则退出await()方法，继续执行。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、Condition的概念&quot;&gt;&lt;a href=&quot;#一、Condition的概念&quot; class=&quot;headerlink&quot; title=&quot;一、Condition的概念&quot;&gt;&lt;/a&gt;一、Condition的概念&lt;/h3&gt;&lt;h4 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="Condition" scheme="http://yoursite.com/tags/Condition/"/>
    
  </entry>
  
  <entry>
    <title>Java并发之Executor框架</title>
    <link href="http://yoursite.com/2017/11/22/Java%E5%B9%B6%E5%8F%91%E4%B9%8BExecutor%E6%A1%86%E6%9E%B6/"/>
    <id>http://yoursite.com/2017/11/22/Java并发之Executor框架/</id>
    <published>2017-11-22T08:42:18.000Z</published>
    <updated>2018-02-24T17:54:29.392Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、Executor框架的介绍"><a href="#一、Executor框架的介绍" class="headerlink" title="一、Executor框架的介绍"></a>一、Executor框架的介绍</h3><p>Java中的线程既是工作单元又是执行机制。JDK1.5开始，把工作单元与执行机制分离开来。<strong>工作单元为Runnable（Thread实现该接口）和Callable，执行机制就是Executor框架。</strong> 使用Executor框架时不用显式的创建线程Thread。</p>
<p>Executor框架由三部分组成：  </p>
<ul>
<li><strong>任务</strong>：Runnable或Callable  </li>
<li><strong>任务的执行</strong>：ExecutorService接口及其实现。  </li>
<li><strong>异步计算的结果</strong>：Future接口或其实现类FutureTask</li>
</ul>
<h4 id="Executor的结构"><a href="#Executor的结构" class="headerlink" title="Executor的结构"></a>Executor的结构</h4><p><img src="http://osuskkx7k.bkt.clouddn.com/Executor1.png" alt="image"></p>
<h4 id="Executor接口"><a href="#Executor接口" class="headerlink" title="Executor接口"></a><strong>Executor接口</strong></h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public<span class="built_in"> interface </span>Executor &#123;</div><div class="line">        void execute(Runnable command);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>Executor接口中只有一个execute()方法，用来执行已经提交的Runnable实例，可见即使是Callable实例，最后也会被封装成Runnable来执行。</strong></p>
<h4 id="ExecutorService接口"><a href="#ExecutorService接口" class="headerlink" title="ExecutorService接口"></a><strong>ExecutorService接口</strong></h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public<span class="built_in"> interface </span>ExecutorService extends Executor &#123;</div><div class="line">        void shutdown();</div><div class="line">        List&lt;Runnable&gt; shutdownNow();</div><div class="line">        &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);</div><div class="line">        &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);</div><div class="line">        Future&lt;?&gt; submit(Runnable task);</div><div class="line">        <span class="built_in">..</span><span class="built_in">..</span></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><strong>ExecutorService扩展了Executor接口，添加了许多方法用于服务、管理和关闭线程池。</strong><br>submit()方法最终执行时也是调用了execute()方法。</p>
<p>ExecutorService接口有两个实现类，ThreadPoolExecutor（核心）和ScheduledThreadPoolExecutor（定时执行）。</p>
<h4 id="Executors工具类"><a href="#Executors工具类" class="headerlink" title="Executors工具类"></a><strong>Executors工具类</strong></h4><p><strong>Executors工具类中包含了许多静态工厂方法。采用了多方法静态工厂模式。</strong> 本质是根据不同的输入创建出不同类型的对象。</p>
<p>通过Executors工具类可以创建3种类型的线程池，即3种ThreadPoolExecutor对象。实质是创建ThreadPoolExecutor时传入的参数不同。</p>
<h3 id="二、3种常用线程池"><a href="#二、3种常用线程池" class="headerlink" title="二、3种常用线程池"></a>二、3种常用线程池</h3><h4 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h4><p><strong>FixedThreadPool是固定大小的线程池。内部线程可重用。</strong><br>Executors工具类中的静态方法：<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="keyword">new</span><span class="type">FixedThreadPool</span>(int nThreads) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">ThreadPoolExecutor</span>(nThreads, nThreads,</div><div class="line">                                      <span class="number">0</span>L, TimeUnit.MILLISECONDS,</div><div class="line">                                      <span class="keyword">new</span> <span class="type">LinkedBlockingQueue</span>&lt;Runnable&gt;());</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p><strong>特点</strong>：</p>
<ol>
<li>参数corePoolSize和maximumPoolSize大小都是nThreads，说明最大线程数就是核心线程数，所以线程大小固定</li>
<li>参数keepAliveTime为0L，说明不会有空闲的线程</li>
<li>参数BlockingQueue是无界队列LinkedBlockingQueue，说明任务会一直放入，不会采用饱和策略。</li>
</ol>
<p><strong>应用场景</strong>：需要限制线程数量，适用于负载较重的服务器</p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/fixed.png" alt="image"></p>
<p><strong>工作过程</strong>：</p>
<ol>
<li>当前线程数小于corePoolSize，创建新线程执行任务</li>
<li>当前线程数等于corePoolSize，任务加入阻塞队列</li>
<li>线程反复执行阻塞队列中的任务</li>
</ol>
<h4 id="SingleThreadExecutor"><a href="#SingleThreadExecutor" class="headerlink" title="SingleThreadExecutor"></a>SingleThreadExecutor</h4><p><strong>SingleThreadExecutor是只有一个线程的线程池。</strong></p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="keyword">new</span><span class="type">SingleThreadExecutor</span>() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">FinalizableDelegatedExecutorService</span></div><div class="line">            (<span class="keyword">new</span> <span class="type">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</div><div class="line">                                    <span class="number">0</span>L, TimeUnit.MILLISECONDS,</div><div class="line">                                    <span class="keyword">new</span> <span class="type">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><strong>特点</strong>：</p>
<ol>
<li>参数corePoolSize和maximumPoolSize大小都是1，说明线程数固定为1</li>
<li>参数keepAliveTime为0L，说明不会有空闲的线程</li>
<li>参数BlockingQueue是无界队列LinkedBlockingQueue，说明任务会一直放入，不会采用饱和策略。</li>
</ol>
<p><strong>应用场景</strong>：<strong>适用于执行的任务需要保证顺序；并且在任意时间点，不会有多个线程是活动的场景。</strong></p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/single1.png" alt="image"></p>
<p><strong>工作过程</strong>：</p>
<ol>
<li>当前线程数小于1，创建一个唯一的线程执行任务</li>
<li>当前线程数等于1，任务加入阻塞队列</li>
<li>这个唯一的线程反复执行阻塞队列中的任务</li>
</ol>
<h4 id="CachedThreadPool"><a href="#CachedThreadPool" class="headerlink" title="CachedThreadPool"></a>CachedThreadPool</h4><p><strong>CachedThreadPool是一个根据需要创建线程的线程池。</strong></p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="keyword">new</span><span class="type">CachedThreadPool</span>() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</div><div class="line">                                      <span class="number">60</span>L, TimeUnit.SECONDS,</div><div class="line">                                      <span class="keyword">new</span> <span class="type">SynchronousQueue</span>&lt;Runnable&gt;());</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><strong>特点</strong>：</p>
<ol>
<li>参数corePoolSize为0，maximumPoolSize为Integer.MAX_VALUE（2147483647），说明可创建的线程数巨大，且都是可销毁的</li>
<li>参数keepAliveTime为60L，说明空闲的线程等待时间最长60s</li>
<li>参数BlockingQueue是一个没有容量的阻塞队列SynchronousQueue，说明任务会一直被线程执行。</li>
</ol>
<p><strong>应用场景</strong>：<strong>大小无界的线程池，适用于执行很多的短期异步任务的小程序，或者负载较轻的服务器。<br>注：使用时需控制并发的任务数，否则创建大量的线程可能导致严重的性能问题。</strong></p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/cached1.png" alt="image"></p>
<p><strong>工作过程</strong>：</p>
<ol>
<li>首先执行SynchronousQueue.offer()，如果有空闲的线程在执行SynchronousQueue.poll()，表示配对成功，任务交给空闲线程执行。</li>
<li>初始化时，如果没有空闲的线程，那么创建一个新的线程执行任务。</li>
<li>步骤2中的线程任务完成后，会执行SynchronousQueue.poll()等待60s，若没有任务提交，则该空闲线程销毁。</li>
</ol>
<p>SynchronousQueue队列的每个插入操作都要等待一个移除操作，因此是没有容量的队列。</p>
<hr>
<p>除上述3种常用线程池外，Executors还可以创建以下几种线程池。</p>
<p><strong>newScheduledThreadPool</strong>：可以定时或周期性执行任务的线程池（线程数目指定）</p>
<p><strong>newSingleThreadScheduledExecutor：</strong> 可以定时或周期性执行任务的线程池。只有一个线程。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、Executor框架的介绍&quot;&gt;&lt;a href=&quot;#一、Executor框架的介绍&quot; class=&quot;headerlink&quot; title=&quot;一、Executor框架的介绍&quot;&gt;&lt;/a&gt;一、Executor框架的介绍&lt;/h3&gt;&lt;p&gt;Java中的线程既是工作单元又是执行
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="Executor框架" scheme="http://yoursite.com/tags/Executor%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Java线程池的实现分析</title>
    <link href="http://yoursite.com/2017/11/18/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2017/11/18/Java线程池的实现分析/</id>
    <published>2017-11-18T12:42:18.000Z</published>
    <updated>2018-02-24T17:52:30.529Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、线程池的介绍"><a href="#一、线程池的介绍" class="headerlink" title="一、线程池的介绍"></a>一、线程池的介绍</h3><p>线程池是一种并发框架。</p>
<p>优势：</p>
<ol>
<li><strong>降低资源消耗。</strong>（重复利用线程，减少开销）</li>
<li><strong>提高响应速度。</strong>（任务到达可直接执行，不需要等待创建线程）</li>
<li><strong>提高线程的可管理性</strong>。（统一分配、监控、调优）</li>
</ol>
<p><strong>ThreadPoolExecutor是线程池的核心实现类</strong>。可以通过ThreadPoolExecutor来创建一个线程池。</p>
<h3 id="二、线程池的实现分析"><a href="#二、线程池的实现分析" class="headerlink" title="二、线程池的实现分析"></a>二、线程池的实现分析</h3><p>线程池的实现是ThreadPoolExecutor类，因此重点描述ThreadPoolExecutor类的实现。  </p>
<h4 id="ThreadPoolExecutor的结构"><a href="#ThreadPoolExecutor的结构" class="headerlink" title="ThreadPoolExecutor的结构"></a>ThreadPoolExecutor的结构</h4><p>ThreadPoolExecutor的构造方法<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></div><div class="line">                              <span class="keyword">int</span> maximumPoolSize,</div><div class="line">                              <span class="keyword">long</span> keepAliveTime,</div><div class="line">                              TimeUnit unit,</div><div class="line">                              BlockingQueue&lt;Runnable&gt; workQueue,</div><div class="line">                              ThreadFactory threadFactory,</div><div class="line">                              RejectedExecutionHandler <span class="keyword">handler</span>) &#123;</div><div class="line">        ...(省略部分)</div><div class="line">        <span class="keyword">this</span>.corePoolSize = corePoolSize;</div><div class="line">        <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</div><div class="line">        <span class="keyword">this</span>.workQueue = workQueue;</div><div class="line">        <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</div><div class="line">        <span class="keyword">this</span>.threadFactory = threadFactory;</div><div class="line">        <span class="keyword">this</span>.<span class="keyword">handler</span> = <span class="keyword">handler</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>构造函数中省略了部分判断的代码。<br>主要有7个参数：  </p>
<p><strong>corePoolSize</strong>：核心线程池的大小  </p>
<p><strong>maximumPoolSize</strong>：线程池的大小  </p>
<p><strong>keepAliveTime</strong>：存活时间（超过核心数目的线程空闲后的存活时间）  </p>
<p><strong>TimeUnit</strong>：时间单位  </p>
<p><strong>BlockingQueue<runnable></runnable></strong>：任务队列（保存等待任务的阻塞队列）  </p>
<p><strong>ThreadFactory</strong>：创建线程的工厂类   </p>
<p><strong>RejectedExecutionHandler</strong> ：饱和策略（拒绝策略）</p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/%E7%BA%BF%E7%A8%8B%E6%B1%A0.png" alt="image"></p>
<h4 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h4><p>当提交一个新任务时，线程池的工作过程：</p>
<ol>
<li><p><strong>判断核心线程池（corePool）中的线程是否都在执行任务。如果不是，创建一个新的线程执行任务。核心线程池已满，进入2</strong>；  </p>
</li>
<li><p><strong>判断任务队列是否已满。未满，则将新的任务存入；满了，进入3；</strong></p>
</li>
<li><strong>判断线程池（maximumPoolSize）里的线程是否都在工作。如果没有，创建一个新的线程执行任务；否则，交给饱和策略4</strong>；</li>
<li><strong>根据不同的饱和策略处理这个任务</strong>。</li>
</ol>
<p><img src="http://osuskkx7k.bkt.clouddn.com/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B.png" alt="image"></p>
<p>饱和策略有4种：</p>
<ul>
<li><strong>AbortPolicy（默认）</strong>：直接抛出异常</li>
<li><strong>CallerRunsPolicy</strong>：只用调用者所在线程来处理</li>
<li><strong>DiscardOldestPolicy</strong>：丢弃任务队列中最后一个任务，执行当前任务</li>
<li><strong>DiscardPolicy</strong>：不处理丢弃掉</li>
</ul>
<p>线程池回收线程时，对所谓的“核心线程”和“非核心线程”是一视同仁的，直到线程池中线程的数量等于corePoolSize参数时，回收过程才会停止。<br>如果设置的corePoolSize参数和maximumPoolSize参数一致时，线程池在任何情况下都不会回收空闲线程。keepAliveTime和timeUnit也就失去了意义。<br>可以调用以下方法回收核心线程。<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">threadPoolExecutor.allowCoreThreadTimeOut(true)<span class="comment">;</span></div></pre></td></tr></table></figure></p>
<h4 id="线程池处理任务"><a href="#线程池处理任务" class="headerlink" title="线程池处理任务"></a>线程池处理任务</h4><p>线程池处理任务的方法主要有两种，execute()和submit()。</p>
<p><strong>execute()</strong>  </p>
<p><strong>execute()方法用于提交不需要返回值的任务</strong>，Runnable实例。所以无法判断任务是否被线程池执行成功。</p>
<p><strong>submit()</strong><br><strong>submit()方法用于提交需要返回值的任务</strong>。线程池会返回一个future类型的对象，通过这个对象可以判断任务是否执行成功。</p>
<p>future的get()方法会阻塞当前线程直到任务完成，返回结果。</p>
<p>submit()最终调用的也是execute(Runnable runable)，submit()只是将Callable或Runnable封装成一个FutureTask对象，因为FutureTask是个Runnable，所以调用的是execute()方法。</p>
<h4 id="线程池的关闭"><a href="#线程池的关闭" class="headerlink" title="线程池的关闭"></a>线程池的关闭</h4><p>线程池关闭的方法主要有两种，shutdown()和shutdownNow()。</p>
<p><strong>原理</strong>：遍历线程池中的工作线程，逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法停止。</p>
<p><strong>区别</strong>：<br><strong>shutdown()只是将线程池的状态设置成SHUTDOWN状态，然后中断没有在执行任务的线程。</strong></p>
<p><strong>shutdownNow()首先将线程池的状态设置成STOP，然后尝试停止所有正在执行或暂停任务的线程，并返回等待执行任务的列表。</strong></p>
<p>如果任务不一定要执行完，可以调用shutdownNow()方法。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、线程池的介绍&quot;&gt;&lt;a href=&quot;#一、线程池的介绍&quot; class=&quot;headerlink&quot; title=&quot;一、线程池的介绍&quot;&gt;&lt;/a&gt;一、线程池的介绍&lt;/h3&gt;&lt;p&gt;线程池是一种并发框架。&lt;/p&gt;
&lt;p&gt;优势：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;降低
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="Java线程池" scheme="http://yoursite.com/tags/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>ConcurrentHashMap在JDK1.8中的实现分析</title>
    <link href="http://yoursite.com/2017/11/10/ConcurrentHashMap%E5%9C%A8JDK1.8%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2017/11/10/ConcurrentHashMap在JDK1.8中的实现分析/</id>
    <published>2017-11-10T08:42:18.000Z</published>
    <updated>2018-02-24T17:40:51.020Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、ConcurrentHashMap的介绍"><a href="#一、ConcurrentHashMap的介绍" class="headerlink" title="一、ConcurrentHashMap的介绍"></a>一、ConcurrentHashMap的介绍</h3><p><strong>ConcurrentHashMap在JDK8中进行了巨大改动，它舍弃了锁分段的技术，大量引入了CAS操作，以此来实现并发操作。</strong>   </p>
<p>回忆JDK1.7中的ConcurrentHashmap，当hash碰撞频繁时，链表长度会拉长，而链表的增改删查操作都会消耗很长的时间，影响性能，因此和JDK1.8中的HashMap一样，当链表过长时，将其结构转化为红黑树，由此提高性能。</p>
<h3 id="二、ConcurrentHashMap的实现原理"><a href="#二、ConcurrentHashMap的实现原理" class="headerlink" title="二、ConcurrentHashMap的实现原理"></a>二、ConcurrentHashMap的实现原理</h3><p><strong>ConcurrentHashMap的结构图</strong></p>
<p>ConcurrentHashMap在JDK1.8的实现原理是“<strong>数组+链表+红黑树</strong>”。（与HashMap在1.8中的实现思想一致，但是<strong>红黑树的节点不同</strong>，HashMap是Node节点，ConcurrentHashMap是TreeBin对象）</p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/1.8hash.PNG" alt="image"></p>
<hr>
<p>下面介绍一下ConcurrentHashMap主要方法put()和get()的实现。</p>
<h4 id="put-方法"><a href="#put-方法" class="headerlink" title="put()方法"></a>put()方法</h4><figure class="highlight gauss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line">final V putVal(K <span class="built_in">key</span>, V value, boolean onlyIfAbsent) &#123;</div><div class="line">---第一部分</div><div class="line">        <span class="keyword">if</span> (<span class="built_in">key</span> == <span class="built_in">null</span> || value == <span class="built_in">null</span>) throw <span class="keyword">new</span> NullPointerException();</div><div class="line">        <span class="comment">//计算hash值</span></div><div class="line">        int hash = spread(<span class="built_in">key</span>.hashCode());</div><div class="line">        int binCount = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt;[] <span class="built_in">tab</span> = table;;) &#123;</div><div class="line">            Node&lt;K,V&gt; f; int n, i, fh;</div><div class="line">            <span class="comment">//如果tab为null，则初始化</span></div><div class="line">            <span class="keyword">if</span> (<span class="built_in">tab</span> == <span class="built_in">null</span> || (n = <span class="built_in">tab</span>.length) == <span class="number">0</span>)</div><div class="line">                <span class="built_in">tab</span> = initTable();</div><div class="line">            <span class="comment">//判断数组索引位置的元素是否为null</span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(<span class="built_in">tab</span>, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="built_in">null</span>) &#123;</div><div class="line">                <span class="comment">//CAS操作设置该数组索引位置为新节点Node</span></div><div class="line">                <span class="keyword">if</span> (casTabAt(<span class="built_in">tab</span>, i, <span class="built_in">null</span>,</div><div class="line">                             <span class="keyword">new</span> Node&lt;K,V&gt;(hash, <span class="built_in">key</span>, value, <span class="built_in">null</span>)))</div><div class="line">                    <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></div><div class="line">            &#125;</div><div class="line">            <span class="comment">//f节点是MOVED节点，表示有其他线程在扩容，帮助一起扩容</span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</div><div class="line">                <span class="built_in">tab</span> = helpTransfer(<span class="built_in">tab</span>, f);</div><div class="line">                </div><div class="line">---第二部分-----</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                V oldVal = <span class="built_in">null</span>;</div><div class="line">                synchronized (f) &#123;</div><div class="line">                    <span class="keyword">if</span> (tabAt(<span class="built_in">tab</span>, i) == f) &#123;</div><div class="line">                        <span class="comment">//表示是链表，还未转化成红黑树</span></div><div class="line">                        <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</div><div class="line">                            binCount = <span class="number">1</span>;</div><div class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</div><div class="line">                                K ek;</div><div class="line">                                <span class="comment">//如果key已存在，则替换value</span></div><div class="line">                                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                                    ((ek = e.<span class="built_in">key</span>) == <span class="built_in">key</span> ||</div><div class="line">                                     (ek != <span class="built_in">null</span> &amp;&amp; <span class="built_in">key</span>.equals(ek)))) &#123;</div><div class="line">                                    oldVal = e.val;</div><div class="line">                                    <span class="keyword">if</span> (!onlyIfAbsent)</div><div class="line">                                        e.val = value;</div><div class="line">                                    <span class="keyword">break</span>;</div><div class="line">                                &#125;</div><div class="line">                                Node&lt;K,V&gt; pred = e;</div><div class="line">                                <span class="comment">//将新的节点插入尾部</span></div><div class="line">                                <span class="keyword">if</span> ((e = e.next) == <span class="built_in">null</span>) &#123;</div><div class="line">                                    pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, <span class="built_in">key</span>,</div><div class="line">                                                              value, <span class="built_in">null</span>);</div><div class="line">                                    <span class="keyword">break</span>;</div><div class="line">                                &#125;</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                        <span class="comment">//节点f是TreeBin对象，表示链表转为了红黑树</span></div><div class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (f instanceof TreeBin) &#123;</div><div class="line">                            Node&lt;K,V&gt; p;</div><div class="line">                            binCount = <span class="number">2</span>;</div><div class="line">                            <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, <span class="built_in">key</span>,</div><div class="line">                                                           value)) != <span class="built_in">null</span>) &#123;</div><div class="line">                                oldVal = p.val;</div><div class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</div><div class="line">                                    p.val = value;</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</div><div class="line">                    <span class="comment">//如果大于8，转化为红黑树</span></div><div class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</div><div class="line">                        treeifyBin(<span class="built_in">tab</span>, i);</div><div class="line">                    <span class="keyword">if</span> (oldVal != <span class="built_in">null</span>)</div><div class="line">                        <span class="keyword">return</span> oldVal;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        addCount(<span class="number">1</span>L, binCount);</div><div class="line">        <span class="keyword">return</span> <span class="built_in">null</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>由于整个put()方法较长，分成两部分来分析。<br><strong>第一部分：</strong></p>
<ol>
<li>遍历数组tab，如果为null，初始化数组；</li>
<li><strong>调用tabAt()方法查找数组索引i处的节点f，如果f为null，说明该位置还没有节点，调用casTabAt()利用CAS操作插入新的节点</strong></li>
</ol>
<ul>
<li><strong>CAS成功</strong>：break跳出，直到最后的addCount(1L, binCount)方法，判断插入这一个节点后是否需要扩容; </li>
<li><strong>CAS失败</strong>：说明有其它线程提前插入了节点，自旋重新尝试在这个位置插入节点；<br>tabAt()和casTabAt()方法源码如下：<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"> private static final sun.misc.Unsafe U;</div><div class="line"> </div><div class="line">static final <span class="tag">&lt;K,V&gt;</span> <span class="keyword">Node</span><span class="title">&lt;K</span>,V&gt; tabAt(<span class="keyword">Node</span><span class="title">&lt;K</span>,V&gt;[] tab, int i) &#123;</div><div class="line">        return (<span class="keyword">Node</span><span class="title">&lt;K</span>,V&gt;)U.getObjectVolatile(tab, ((long)i <span class="tag">&lt;&lt; ASHIFT) + ABASE);</span></div><div class="line">    &#125;</div><div class="line">static final &lt;K,V&gt; boolean casTabAt(<span class="keyword">Node</span><span class="title">&lt;K</span>,V&gt;[] tab, int i,</div><div class="line">                                        <span class="keyword">Node</span><span class="title">&lt;K</span>,V&gt; c, <span class="keyword">Node</span><span class="title">&lt;K</span>,V&gt; v) &#123;</div><div class="line">        return U.compareAndSwapObject(tab, ((long)i <span class="tag">&lt;&lt; ASHIFT) + ABASE, c, v);</span></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>可以看到，都是<strong>调用Unsafe类的方法（原子性），Unsafe.getObjectVolatile可以直接获取指定内存的数据，保证了每次拿到数据都是最新的。</strong></p>
<ol>
<li><strong>若前面的情况都不满足，判断f节点是否为MOVED节点，是则表示有其他线程在扩容，帮助一起扩容</strong>；否则进入第二部分。  </li>
</ol>
<p><strong>第二部分：</strong>  </p>
<p>第二部分表示把新的节点Node插入链表或红黑树，可以看到使用了synchronized关键字实现同步。<strong>但是注意，只在节点f上进行同步，表示只能有一个线程访问该节点。</strong> 节点插入之前，再次利用 tabAt(tab, i) == f 判断头节点是否还是f，防止被其它线程修改。</p>
<ol>
<li>如果f.hash &gt;= 0，说明f是链表结构的头结点，遍历链表，如果key已存在，则修改value，否则在链表尾部插入节点。</li>
<li>如果f是TreeBin类型节点，说明链表变成红黑树，则在树结构上遍历元素，更新或增加节点。</li>
<li>最后判断链表中的节点数binCount &gt;= 8，则转化为红黑树。</li>
</ol>
<hr>
<h4 id="get-方法"><a href="#get-方法" class="headerlink" title="get()方法"></a>get()方法</h4><figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> V <span class="built_in">get</span>(<span class="keyword">Object</span> <span class="built_in">key</span>) &#123;</div><div class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="built_in">int</span> n, eh; K ek;</div><div class="line">        <span class="comment">//获取key的hash值</span></div><div class="line">        <span class="built_in">int</span> h = spread(<span class="built_in">key</span>.hashCode());</div><div class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</div><div class="line">            (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</div><div class="line">                <span class="keyword">if</span> ((ek = e.<span class="built_in">key</span>) == <span class="built_in">key</span> || (ek != <span class="keyword">null</span> &amp;&amp; <span class="built_in">key</span>.equals(ek)))</div><div class="line">                    <span class="keyword">return</span> e.val;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</div><div class="line">                <span class="keyword">return</span> (p = e.find(h, <span class="built_in">key</span>)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</div><div class="line">            <span class="comment">//遍历    </span></div><div class="line">            <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (e.hash == h &amp;&amp;</div><div class="line">                    ((ek = e.<span class="built_in">key</span>) == <span class="built_in">key</span> || (ek != <span class="keyword">null</span> &amp;&amp; <span class="built_in">key</span>.equals(ek))))</div><div class="line">                    <span class="keyword">return</span> e.val;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ol>
<li>如果table为null或者遍历之后没找到对应的value，返回null；</li>
<li>根据key的hash值找到table中指定的Node节点，遍历链表或红黑树找到对应的value值。<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4></li>
</ol>
<p>最后总结一下<strong>ConcurrentHashMap从JDK1.7（1.6）到JDK1.8的变化</strong>：</p>
<ol>
<li><strong>底层结构改变</strong>，从“<strong>数组+数组+链表</strong>”到“<strong>数组+链表+红黑树</strong>”</li>
<li><strong>锁方式改变，取消了Segment重入锁，变成CAS+Synchronized实现锁</strong></li>
<li><strong>锁粒度变小</strong>，<strong>由Segment数组变成table的元素</strong>。</li>
<li>JDK1.8中size()实现更简单</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、ConcurrentHashMap的介绍&quot;&gt;&lt;a href=&quot;#一、ConcurrentHashMap的介绍&quot; class=&quot;headerlink&quot; title=&quot;一、ConcurrentHashMap的介绍&quot;&gt;&lt;/a&gt;一、ConcurrentHashMap的
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="ConcurrentHashMap" scheme="http://yoursite.com/tags/ConcurrentHashMap/"/>
    
      <category term="JDK1.8" scheme="http://yoursite.com/tags/JDK1-8/"/>
    
  </entry>
  
  <entry>
    <title>ConcurrentHashMap在JDK1.7中的实现分析</title>
    <link href="http://yoursite.com/2017/11/06/ConcurrentHashMap%E5%9C%A8JDK1.7%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2017/11/06/ConcurrentHashMap在JDK1.7中的实现分析/</id>
    <published>2017-11-06T09:48:18.000Z</published>
    <updated>2018-02-24T17:36:40.387Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、ConcurrentHashMap的介绍"><a href="#一、ConcurrentHashMap的介绍" class="headerlink" title="一、ConcurrentHashMap的介绍"></a>一、ConcurrentHashMap的介绍</h3><p>ConcurrentHashMap是线程安全且高效的HashMap，可以在多线程的环境下使用。<br><strong>ConcurrentHashMap允许多个线程并发访问，其关键在于使用了锁分段技术。</strong><br>锁分段：首先将数据分成一段一段地存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个数据段的时候，其他数据段也能被其他线程访问。</p>
<h3 id="二、ConcurrentHashMap的实现原理"><a href="#二、ConcurrentHashMap的实现原理" class="headerlink" title="二、ConcurrentHashMap的实现原理"></a>二、ConcurrentHashMap的实现原理</h3><p><strong>ConcurrentHashMap的结构图</strong>  </p>
<p>ConcurrentHashMap在JDK1.8之前的实现原理是“<strong>数组+数组+链表</strong>”。（可能描述不妥）<br><img src="http://osuskkx7k.bkt.clouddn.com/concurrentHashmap.PNG" alt="image"></p>
<p>第一个数组是Segment[ ]，每一个Segment类似于HashMap；<br>第二个数组是HashEntry[ ]，每个元素可能是一个链表；<br>链表是HashEntry形成的链表，HashEntry是一个节点。</p>
<hr>
<h4 id="HashEntry类"><a href="#HashEntry类" class="headerlink" title="HashEntry类"></a>HashEntry类</h4><figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> HashEntry&lt;K,V&gt; &#123;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</div><div class="line">        <span class="keyword">final</span> K key;</div><div class="line">        <span class="keyword">volatile</span> V value;</div><div class="line">        <span class="keyword">volatile</span> HashEntry&lt;K,V&gt; <span class="keyword">next</span>;</div><div class="line">        ....</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>HashEntry类相当于HashMap中的Entry类（节点类），储存了key和value，并拥有指向下一个元素的引用next。<br>注：<strong>value采用volatile修饰，保证了线程之间的可见性</strong>。</p>
<h4 id="Segment类"><a href="#Segment类" class="headerlink" title="Segment类"></a>Segment类</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span> &#123;</span></div><div class="line"></div><div class="line">        <span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;</div><div class="line">        <span class="keyword">transient</span> <span class="keyword">int</span> count;</div><div class="line">        <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</div><div class="line">        <span class="keyword">transient</span> <span class="keyword">int</span> threshold;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">float</span> loadFactor; </div><div class="line">        ....</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>每个Segment都拥有一个HashEntry[]数组，还有threshold和loadFactor分别表示极限容量和负载因子，count表示元素个数，modCount表示修改的记录。如此看来，<strong>每个Segment就好比是一个缩小版的HashMap</strong>，从上面ConcurrentHashMap结构图也可以看出来。</p>
<p><strong>Segment继承自ReentrantLock重入锁，因此它支持一个线程重进入同一个Segment，访问其中的数据。</strong></p>
<hr>
<p>下面介绍一下ConcurrentHashMap主要的几个方法的实现:put()方法、get()方法、size()方法</p>
<h4 id="put-方法"><a href="#put-方法" class="headerlink" title="put()方法"></a>put()方法</h4><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span>(<span class="params">K key, V <span class="keyword">value</span></span>) </span>&#123;</div><div class="line">        Segment&lt;K,V&gt; s;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">value</span> == <span class="literal">null</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">        <span class="keyword">int</span> hash = hash(key);</div><div class="line">        <span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</div><div class="line">        <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject</div><div class="line">             (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="literal">null</span>) </div><div class="line">            <span class="comment">// 扩容 </span></div><div class="line">            s = ensureSegment(j);</div><div class="line">        <span class="keyword">return</span> s.put(key, hash, <span class="keyword">value</span>, <span class="literal">false</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>首先定位到相应的Segment。<br>如果需要扩容则进入ensureSegment(j)方法，<strong>注意ConcurrentHashMap不会对整个容器扩容，而只对当前的Segment进行扩容。</strong>  扩容为原来的2倍。<br>如果不需要扩容，调用Segment中的put()方法：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="function">final V <span class="title">put</span>(<span class="params">K key, <span class="keyword">int</span> hash, V <span class="keyword">value</span>, boolean onlyIfAbsent</span>) </span>&#123;</div><div class="line">            HashEntry&lt;K,V&gt; node = tryLock() ? <span class="literal">null</span> :</div><div class="line">                scanAndLockForPut(key, hash, <span class="keyword">value</span>);</div><div class="line">            V oldValue;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                HashEntry&lt;K,V&gt;[] tab = table;</div><div class="line">                <span class="keyword">int</span> index = (tab.length - <span class="number">1</span>) &amp; hash;</div><div class="line">                <span class="comment">//取出头节点</span></div><div class="line">                HashEntry&lt;K,V&gt; first = entryAt(tab, index);</div><div class="line">                <span class="comment">//遍历链表</span></div><div class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;</div><div class="line">                    <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</div><div class="line">                        K k;</div><div class="line">                        <span class="comment">//key已存在，替换value</span></div><div class="line">                        <span class="keyword">if</span> ((k = e.key) == key ||</div><div class="line">                            (e.hash == hash &amp;&amp; key.<span class="keyword">equals</span>(k))) &#123;</div><div class="line">                            oldValue = e.<span class="keyword">value</span>;</div><div class="line">                            <span class="keyword">if</span> (!onlyIfAbsent) &#123;</div><div class="line">                                e.<span class="keyword">value</span> = <span class="keyword">value</span>;</div><div class="line">                                ++modCount;</div><div class="line">                            &#125;</div><div class="line">                            <span class="keyword">break</span>;</div><div class="line">                        &#125;</div><div class="line">                        e = e.next;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">else</span> &#123;</div><div class="line">                        <span class="comment">//scanAndLockForPut()方法中已经返回了node，设置为first节点</span></div><div class="line">                        <span class="keyword">if</span> (node != <span class="literal">null</span>)</div><div class="line">                            node.setNext(first);</div><div class="line">                        <span class="keyword">else</span></div><div class="line">                            <span class="comment">//新建HashEntry节点作为头节点first</span></div><div class="line">                            node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, <span class="keyword">value</span>, first);</div><div class="line">                        <span class="keyword">int</span> c = count + <span class="number">1</span>;</div><div class="line">                        <span class="comment">//判断是否扩容</span></div><div class="line">                        <span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</div><div class="line">                            rehash(node);</div><div class="line">                        <span class="keyword">else</span></div><div class="line">                            setEntryAt(tab, index, node);</div><div class="line">                        ++modCount; <span class="comment">//记录修改次数</span></div><div class="line">                        count = c;  <span class="comment">//修改count值</span></div><div class="line">                        oldValue = <span class="literal">null</span>;</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                unlock();</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> oldValue;</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p>
<p>过程分析：  </p>
<ol>
<li>首先调用tryLock()方法尝试获取锁，如果获取失败，则进入scanAndLockForPut()方法，该方法实际上是先自旋一定的次数等待其他线程释放锁。若自旋过程中，其他线程释放了锁，导致本线程直接获得了锁，就避免了本线程进入等待锁的场景，提高了效率。若自旋一定次数后，仍未获取锁，则调用lock方法进入等待锁的场景。（这是JDK1.7的实现，如果是1.6则没有自旋，直接获取锁）</li>
<li>获取锁成功，找到对应的链表作相应的操作。具体见代码注释。</li>
</ol>
<h4 id="get-方法"><a href="#get-方法" class="headerlink" title="get()方法"></a>get()方法</h4><p>get()方法不需要锁。<strong>因为value字段是volatile修饰，保证了线程之间的可见性，可以被多线程同时读，但只能被单线程写。一句话，get操作只需要读共享变量value，所以不用加锁。</strong></p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> V <span class="built_in">get</span>(<span class="keyword">Object</span> <span class="built_in">key</span>) &#123;</div><div class="line">        Segment&lt;K,V&gt; s; <span class="comment">// manually integrate access methods to reduce overhead</span></div><div class="line">        HashEntry&lt;K,V&gt;[] tab;</div><div class="line">        <span class="built_in">int</span> h = hash(<span class="built_in">key</span>); <span class="comment">//第一次散列</span></div><div class="line">        <span class="comment">//第二次散列</span></div><div class="line">        <span class="keyword">long</span> u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</div><div class="line">        <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != <span class="keyword">null</span> &amp;&amp;</div><div class="line">            (tab = s.table) != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">//第三次散列（for循环中）</span></div><div class="line">            <span class="comment">//遍历链表</span></div><div class="line">            <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile</div><div class="line">                     (tab, ((<span class="keyword">long</span>)(((tab.length - <span class="number">1</span>) &amp; h)) &lt;&lt; TSHIFT) + TBASE);</div><div class="line">                 e != <span class="keyword">null</span>; e = e.next) &#123;</div><div class="line">                K k;</div><div class="line">                <span class="keyword">if</span> ((k = e.<span class="built_in">key</span>) == <span class="built_in">key</span> || (e.hash == h &amp;&amp; <span class="built_in">key</span>.equals(k)))</div><div class="line">                    <span class="keyword">return</span> e.value;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>（get()方法中用到了许多UNSAFE类的方法，这是在JDK1.6中没有的，主要是利用Native方法来快速的定位元素。）  </p>
<p>get()的过程经过了三次散列：  </p>
<p><strong>第一次：对key进行散列得到h<br>第二次：对h进行散列定位到哪个Segment<br>第三次：对h进行散列定位到哪个HashEntry</strong> </p>
<p>定位到HashEntry之后就对该链表遍历，查找key对应的value，若没有找到则返回null。  </p>
<h4 id="size-方法"><a href="#size-方法" class="headerlink" title="size()方法"></a>size()方法</h4><p><strong>size()方法需要跨Segment操作，因为要统计每个Segment中的count值。而count值是volatile变量，一般来说将所有的count变量相加就可以得到整个ConcurrentHashMap的大小。</strong> 但可能在累加前使用的count发生了变化，那么结果就不正确。那么该如何统计呢？</p>
<ol>
<li>第一种方法，将所有Segment的put、remove、clean方法都锁住，然后统计count值。做法可行，但是低效。</li>
<li><strong>第二种方法，先尝试连续2次不通过锁住Segment的方式计算各个count值的和：</strong></li>
</ol>
<ul>
<li>若没有发生变化，则作为size的大小。</li>
<li>若发生变化说明有线程在操作元素，则锁住Segment统计所有的count值。</li>
</ul>
<p><strong>如何判断容器大小没有发生变化？</strong>   </p>
<p><strong>modCount变量。这个变量记录了每个Segment中put、remove、clean等操作的次数，因此在连续两次统计count的值时，比较modCount是否变化，就可得知容器大小是否变化。</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、ConcurrentHashMap的介绍&quot;&gt;&lt;a href=&quot;#一、ConcurrentHashMap的介绍&quot; class=&quot;headerlink&quot; title=&quot;一、ConcurrentHashMap的介绍&quot;&gt;&lt;/a&gt;一、ConcurrentHashMap的
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="ConcurrentHashMap" scheme="http://yoursite.com/tags/ConcurrentHashMap/"/>
    
      <category term="JDK1.7" scheme="http://yoursite.com/tags/JDK1-7/"/>
    
  </entry>
  
  <entry>
    <title>HashMap引发的线程安全问题</title>
    <link href="http://yoursite.com/2017/11/03/HashMap%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2017/11/03/HashMap引发的线程安全问题/</id>
    <published>2017-11-03T09:48:18.000Z</published>
    <updated>2018-02-24T17:48:06.945Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、线程安全性"><a href="#一、线程安全性" class="headerlink" title="一、线程安全性"></a>一、线程安全性</h3><p>我们知道，HashMap是非线程安全的，只能在单线程的情况下使用。那么为什么不能在并发的情况下使用呢？<strong>因为在并发时，HashMap的扩容会产生错误而形成环形链表，导致读取数据时发生死循环</strong>。</p>
<p>回忆前面描述的扩容过程，调用了transfer()方法将旧链表转化为新链表：</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">void transfer(Entry[] <span class="keyword">new</span><span class="type">Table</span>) &#123;  </div><div class="line">    Entry[] src = table;  </div><div class="line">    int <span class="keyword">new</span><span class="type">Capacity</span> = <span class="keyword">new</span><span class="type">Table</span>.length;  </div><div class="line">    <span class="keyword">for</span> (int j = <span class="number">0</span>; j &lt; src.length; j++) &#123;  </div><div class="line">        Entry&lt;K,V&gt; e = src[j];  </div><div class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;  </div><div class="line">            src[j] = <span class="literal">null</span>;  </div><div class="line">            <span class="keyword">do</span> &#123;  </div><div class="line">                Entry&lt;K,V&gt; next = e.next;  </div><div class="line">                int i = indexFor(e.hash, <span class="keyword">new</span><span class="type">Capacity</span>);  </div><div class="line">                e.next = <span class="keyword">new</span><span class="type">Table</span>[i];  </div><div class="line">                <span class="keyword">new</span><span class="type">Table</span>[i] = e;  </div><div class="line">                e = next;  </div><div class="line">            &#125; <span class="keyword">while</span> (e != <span class="literal">null</span>);  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>关键代码如下：</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">do</span> &#123;  </div><div class="line">Entry&lt;K,V&gt; next = e.next;  </div><div class="line">int i = indexFor(e.hash, <span class="keyword">new</span><span class="type">Capacity</span>);  </div><div class="line">e.next = <span class="keyword">new</span><span class="type">Table</span>[i];  </div><div class="line"><span class="keyword">new</span><span class="type">Table</span>[i] = e;  </div><div class="line">e = next;  </div><div class="line">&#125; <span class="keyword">while</span> (e != <span class="literal">null</span>);</div></pre></td></tr></table></figure>
<p>循环操作将旧链表中的节点放入新链表，直到下一个节点next为null。<br>分别在单线程和多线程的环境下描述扩容过程。</p>
<h4 id="单线程扩容"><a href="#单线程扩容" class="headerlink" title="单线程扩容"></a>单线程扩容</h4><p>假设hash数组的大小为2，负载因子为1，即超过1×2=2个元素时扩容，添加3个元素5、7、3，数组大小扩大为4，扩容过程如下：</p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/h1.png?imageView2/2/w/900/h/450" alt="image"></p>
<p>原链表中3个元素，循环3次，具体如下：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">第一次循环</div><div class="line"><span class="attr">e</span> = <span class="number">3</span>,<span class="attr">next</span> = <span class="number">7</span></div><div class="line"><span class="number">3</span>.<span class="attr">next</span> = tab[i] = <span class="literal">null</span>  (此时数组tab[i]为空)</div><div class="line">tab[i] = <span class="number">3</span></div><div class="line"><span class="attr">e</span> = <span class="number">7</span> </div><div class="line"></div><div class="line">第二次循环</div><div class="line"><span class="attr">e</span> = <span class="number">7</span>,<span class="attr">next</span> = <span class="number">5</span></div><div class="line"><span class="number">7</span>.<span class="attr">next</span> = tab[i] = <span class="number">3</span></div><div class="line">tab[i] = <span class="number">7</span></div><div class="line"><span class="attr">e</span> = <span class="number">5</span></div><div class="line"></div><div class="line">第三次循环</div><div class="line"><span class="attr">e</span> = <span class="number">5</span>,<span class="attr">next</span> = <span class="literal">null</span></div><div class="line"><span class="number">5</span>.<span class="attr">next</span> = tab[i2] = <span class="literal">null</span>  (此时数组tab[i2]为空)</div><div class="line">tab[i2] = <span class="number">5</span></div><div class="line"><span class="attr">e</span> = <span class="literal">null</span> </div><div class="line"></div><div class="line">(停止循环)</div></pre></td></tr></table></figure></p>
<h4 id="多线程扩容"><a href="#多线程扩容" class="headerlink" title="多线程扩容"></a>多线程扩容</h4><p>为什么多线程环境下扩容会形成环形链表呢？<br>还是刚刚的例子，两个线程并发执行，线程1在进入do循环的第一行挂起，线程2继续执行</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">do</span> &#123;  </div><div class="line">    Entry&lt;K,V&gt; next = e.next;  <span class="comment">//线程1在此处挂起</span></div><div class="line">    int i = indexFor(e.hash, <span class="keyword">new</span><span class="type">Capacity</span>);  </div><div class="line">    e.next = <span class="keyword">new</span><span class="type">Table</span>[i];  </div><div class="line">    <span class="keyword">new</span><span class="type">Table</span>[i] = e;  </div><div class="line">    e = next;  </div><div class="line">    &#125; <span class="keyword">while</span> (e != <span class="literal">null</span>);</div></pre></td></tr></table></figure>
<p>由前面单线程的情况可知，线程2此时成功扩容，结果如下：</p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/h2.png" alt="image"></p>
<p>线程1恢复执行，已知线程1的 e 指向了key(3)，而next指向了key(7)，扩容过程如下：</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">第一次循环</div><div class="line">e = <span class="number">3</span>,next = <span class="number">7</span></div><div class="line"><span class="number">3.</span>next = tab[i] = null  (此时数组tab[i]为空)</div><div class="line">tab[i] = <span class="number">3</span></div><div class="line">e = <span class="number">7</span> </div><div class="line"></div><div class="line">第二次循环</div><div class="line">e = <span class="number">7</span>,next = <span class="number">3</span></div><div class="line"><span class="number">7.</span>next = tab[i] = <span class="number">3</span></div><div class="line">tab[i] = <span class="number">7</span></div><div class="line">e = <span class="number">3</span></div><div class="line"></div><div class="line">第三次循环</div><div class="line">e = <span class="number">3</span>,next = null</div><div class="line"><span class="number">3.</span>next = tab[i] = <span class="number">7</span></div><div class="line">tab[i] = <span class="number">3</span></div><div class="line">e = null</div><div class="line"></div><div class="line">(停止循环)</div></pre></td></tr></table></figure>
<p>第一次循环图：  </p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/h3.png" alt="image">  </p>
<p>第二次循环图：</p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/h22.png" alt="image"></p>
<p>第三次循环图：</p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/h4.png" alt="image"></p>
<p>在停止循环后，问题就出现了，如图所示，key(3)和key(7)构成了环形链表。<br><strong>于是，当我们调用HashMap的get方法时，由于查找链表节点时无法退出，就会产生无限循环。</strong></p>
<h3 id="二、解决方法"><a href="#二、解决方法" class="headerlink" title="二、解决方法"></a>二、解决方法</h3><p>解决方法就是采用同步的数据结构，主要有以下三种：</p>
<ol>
<li><strong>Hashtable</strong></li>
<li><strong>Collections.synchronizedMap()</strong></li>
<li><strong>ConcurrentHashMap</strong></li>
</ol>
<h4 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h4><p>Hashtable是线程安全的。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public synchronized V put(K key, V value) <span class="meta">&#123;...&#125;</span></div><div class="line"></div><div class="line">public synchronized V get(<span class="type">Object</span> key) <span class="meta">&#123;...&#125;</span></div></pre></td></tr></table></figure>
<p>可以看到，<strong>Hashtable是通过在方法上加上synchronized关键字来实现同步功能的</strong>。当一个线程访问时，其他线程都被阻塞住，这种方式效率很低，目前几乎不被使用。</p>
<h4 id="Collections-synchronizedMap"><a href="#Collections-synchronizedMap" class="headerlink" title="Collections.synchronizedMap()"></a>Collections.synchronizedMap()</h4><p>调用Collections的synchronizedMap()方法，传入一个Map，可以得到一个线程安全的SynchronizedMap。</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> class SynchronizedMap&lt;K,V&gt;</div><div class="line">        implements Map&lt;K,V&gt;, Serializable &#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K,V&gt; m;     </div><div class="line">        <span class="keyword">final</span> <span class="keyword">Object</span>      mutex;        <span class="comment">// Object on which to synchronize</span></div><div class="line"></div><div class="line">        SynchronizedMap(Map&lt;K,V&gt; m) &#123;</div><div class="line">            <span class="keyword">this</span>.m = Objects.requireNonNull(m);</div><div class="line">            mutex = <span class="keyword">this</span>;</div><div class="line">        &#125;</div><div class="line">        ....</div><div class="line">        <span class="keyword">public</span> V <span class="built_in">get</span>(<span class="keyword">Object</span> <span class="built_in">key</span>) &#123;</div><div class="line">            <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> m.<span class="built_in">get</span>(<span class="built_in">key</span>);&#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">public</span> V put(K <span class="built_in">key</span>, V value) &#123;</div><div class="line">            <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> m.put(<span class="built_in">key</span>, value);&#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>可以看到，<strong>它同步的原理同样也是使用了Synchronized关键字，不同的是Synchronized修饰代码块，并且将自身（this）作为了锁对象（mutex）。</strong></p>
<h4 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><p>ConcurrentHashMap是JDK1.5之后引入的，是为了替代上面提到的二者。<br>ConcurrentHashMap是线程安全且高效的HashMap，它使用了多个锁来控制对hash数组不同部分的修改。  </p>
<p>关于它的实现原理可以查看<a href="https://youngforzy.github.io/2017/11/10/ConcurrentHashMap在JDK1.8中的实现分析/" target="_blank" rel="external">ConcurrentHashMap</a>这篇文章中的分析。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、线程安全性&quot;&gt;&lt;a href=&quot;#一、线程安全性&quot; class=&quot;headerlink&quot; title=&quot;一、线程安全性&quot;&gt;&lt;/a&gt;一、线程安全性&lt;/h3&gt;&lt;p&gt;我们知道，HashMap是非线程安全的，只能在单线程的情况下使用。那么为什么不能在并发的情况下使用呢
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="HashMap" scheme="http://yoursite.com/tags/HashMap/"/>
    
      <category term="线程安全" scheme="http://yoursite.com/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
</feed>
