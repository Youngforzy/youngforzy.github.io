<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZY&#39;s Blog</title>
  <subtitle>Young for you.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-06-24T06:01:08.041Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Z Yong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>基数排序的简单实现</title>
    <link href="http://yoursite.com/2018/06/24/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2018/06/24/基数排序/</id>
    <published>2018-06-24T05:48:18.000Z</published>
    <updated>2018-06-24T06:01:08.041Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p><strong>基数排序是一种基于分配的排序（空间换时间）</strong>，不同于常见的基于比较的排序（冒泡、快排、归并…等）。  </p>
<p><strong>基于比较的排序时间复杂度通常是O（n^2）或者O（nlogn），下限是O（nlogn）；</strong>  </p>
<p><strong>基于分配的排序算法的时间复杂度可以达到O（n），但需要消耗额外空间；</strong></p>
<p>在某些时候，基数排序的效率高于其它基于比较的排序算法（快排、归并等）。</p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。进行了c次（c是整数的位数）比较之后，得到一个有序的数组。<br>基数排序是桶排序的扩展，每一次排序建立在桶排序的基础上。</p>
<h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><p><strong>1. 将每个数字统一位数长度（数位短的前面补0）；</strong><br><strong>2. 从最低位（个位）开始，依次进行每次排序；</strong><br><strong>3. 最高位排序完成后，数组就变成了有序数组。</strong></p>
<h4 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h4><p>通过基数排序对一个无序数组进行排序{53, 542, 3, 63, 14, 214, 154, 748, 616}，它的示意图如下：</p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F.jpg" alt="image"></p>
<h5 id="比较过程"><a href="#比较过程" class="headerlink" title="比较过程"></a>比较过程</h5><p>结合上图分析比较过程。<br><strong>每次比较，根据相应位数上的值，将元素放入对应的桶（0-10）中。</strong></p>
<h6 id="第一次比较-“按个位排序”"><a href="#第一次比较-“按个位排序”" class="headerlink" title="第一次比较 “按个位排序”"></a>第一次比较 “按个位排序”</h6><table>
<thead>
<tr>
<th>桶编号</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody>
<tr>
<td>数字</td>
<td></td>
<td></td>
<td>542</td>
<td>053</td>
<td>014</td>
<td></td>
<td>616</td>
<td></td>
<td>748</td>
</tr>
<tr>
<td>数字</td>
<td></td>
<td></td>
<td></td>
<td>003</td>
<td>214</td>
</tr>
<tr>
<td>数字</td>
<td></td>
<td></td>
<td></td>
<td>063</td>
<td>154</td>
</tr>
</tbody>
</table>
<p>将这些数字按新的顺序放入原数组，如图一，准备第二次排序</p>
<h6 id="第二次比较-“按十位比较”"><a href="#第二次比较-“按十位比较”" class="headerlink" title="第二次比较 “按十位比较”"></a>第二次比较 “按十位比较”</h6><table>
<thead>
<tr>
<th>桶编号</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody>
<tr>
<td>数字</td>
<td>003</td>
<td>014</td>
<td></td>
<td></td>
<td>542</td>
<td>053</td>
<td>063</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>数字</td>
<td></td>
<td>214</td>
<td></td>
<td></td>
<td>748</td>
<td>154</td>
</tr>
<tr>
<td>数字</td>
<td></td>
<td>616</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>同样，将这些数字按新的顺序放入原数组，如图一，准备第三次排序</p>
<h6 id="第三次比较-“按百位比较”"><a href="#第三次比较-“按百位比较”" class="headerlink" title="第三次比较 “按百位比较”"></a>第三次比较 “按百位比较”</h6><table>
<thead>
<tr>
<th>桶编号</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody>
<tr>
<td>数字</td>
<td>003</td>
<td>154</td>
<td>214</td>
<td></td>
<td>542</td>
<td>616</td>
<td>748</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>数字</td>
<td>014</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>数字</td>
<td>053</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>数字</td>
<td>063</td>
</tr>
</tbody>
</table>
<p>经过第三次排序，如图一，得到一个有序的数组。</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><h5 id="计算排序的次数"><a href="#计算排序的次数" class="headerlink" title="计算排序的次数"></a>计算排序的次数</h5><p>排序的次数即数组统一的位数（也是最大元素的位数），在这里是 3 位，总共需要比较3次。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//获取最大值</span></div><div class="line"><span class="type">int</span> <span class="built_in">max</span> = a[<span class="number">0</span>];</div><div class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">length</span>; i++) &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">max</span> &lt; a[i]) &#123;</div><div class="line">        <span class="built_in">max</span> = a[i];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//根据最大值确定排序的遍数（如369三位数，就是3遍）</span></div><div class="line"><span class="type">int</span> time = <span class="number">0</span>;</div><div class="line"><span class="keyword">while</span> (<span class="built_in">max</span> &gt; <span class="number">0</span>) &#123;</div><div class="line">    <span class="built_in">max</span> = <span class="built_in">max</span> / <span class="number">10</span>;</div><div class="line">    time ++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="排序过程"><a href="#排序过程" class="headerlink" title="排序过程"></a>排序过程</h5><p>每一次排序之后，都要根据排序的结果记录新的顺序，以便下一次排序。<br>思路如下：<br><strong>1. 将桶数组看成是一个只有10个元素（0-9）的队列，建立该队列（父队列）；</strong><br><strong>2. 父队列中的每一个元素都代表一个子队列，用于存放每个桶中的元素，可能0个也可能多个；</strong></p>
<p>注：采用数组ArrayList来代替子队列，也可以采用链表<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//建立一个主队列，包含10个子队列</span></div><div class="line">List&lt;ArrayList&gt; <span class="built_in">queue</span> = <span class="keyword">new</span> ArrayList&lt;ArrayList&gt;();</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">    ArrayList&lt;Integer&gt; subQueue = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    <span class="built_in">queue</span>.add(subQueue);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>3. 分配数组元素</strong></p>
<p>将每一个数组元素分配进入相应的桶中，即子队列中。<br>每次分配时，i 的值表示获取元素对应位数上的数字：<br>i = 0 ，表示个位；<br>i= 1，表示十位；<br>i = 2， 表示百位；<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//分配数组元素</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a.length; j++) &#123;</div><div class="line">    <span class="keyword">int</span> c = a[j] % (<span class="keyword">int</span>)Math.<span class="built_in">pow</span>(<span class="number">10</span>, i + <span class="number">1</span>); <span class="comment">//当前位上的数字</span></div><div class="line">    <span class="keyword">int</span> x = c / (<span class="keyword">int</span>)Math.<span class="built_in">pow</span>(<span class="number">10</span>, i); <span class="comment">//子队列的序号</span></div><div class="line">    <span class="comment">//System.out.println(x);</span></div><div class="line">    ArrayList&lt;Integer&gt; subQueue = <span class="built_in">queue</span>.get(x);  <span class="comment">//从父队列获取子队列</span></div><div class="line">    subQueue.add(a[j]);</div><div class="line">    <span class="built_in">queue</span>.<span class="built_in">set</span>(x, subQueue);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> radisSort(<span class="built_in">int</span>[] a) &#123;</div><div class="line"></div><div class="line">        <span class="comment">//获取最大值</span></div><div class="line">        <span class="built_in">int</span> <span class="built_in">max</span> = a[<span class="number">0</span>];</div><div class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (<span class="built_in">max</span> &lt; a[i]) &#123;</div><div class="line">                <span class="built_in">max</span> = a[i];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//根据最大值确定排序的遍数（如369三位数，3遍）</span></div><div class="line">        <span class="built_in">int</span> time = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (<span class="built_in">max</span> &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="built_in">max</span> = <span class="built_in">max</span> / <span class="number">10</span>;</div><div class="line">            time ++;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//建立一个主队列，包含10个子队列</span></div><div class="line">        List&lt;ArrayList&gt; queue = <span class="keyword">new</span> ArrayList&lt;ArrayList&gt;();</div><div class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">            ArrayList&lt;Integer&gt; subQueue = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">            queue.<span class="built_in">add</span>(subQueue);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//time次排序</span></div><div class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; time; i++) &#123;</div><div class="line"></div><div class="line">            <span class="comment">//分配数组元素</span></div><div class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; a.length; j++) &#123;</div><div class="line">                <span class="built_in">int</span> c = a[j] % (<span class="built_in">int</span>)Math.<span class="built_in">pow</span>(<span class="number">10</span>, i + <span class="number">1</span>); <span class="comment">//当前位上的数字</span></div><div class="line">                <span class="built_in">int</span> x = c / (<span class="built_in">int</span>)Math.<span class="built_in">pow</span>(<span class="number">10</span>, i); <span class="comment">//子队列的序号</span></div><div class="line">                <span class="comment">//System.out.println(x);</span></div><div class="line">                ArrayList&lt;Integer&gt; subQueue = queue.<span class="built_in">get</span>(x);  <span class="comment">//从父队列获取子队列</span></div><div class="line">                subQueue.<span class="built_in">add</span>(a[j]);</div><div class="line">                queue.<span class="built_in">set</span>(x, subQueue);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//分配结束后，记录新的顺序</span></div><div class="line">            <span class="built_in">int</span> k = <span class="number">0</span>;</div><div class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> n = <span class="number">0</span>; n &lt; <span class="number">10</span>; n++) &#123;</div><div class="line">                <span class="comment">//取出有元素的子队列</span></div><div class="line">                <span class="keyword">while</span> (queue.<span class="built_in">get</span>(n).<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</div><div class="line">                    ArrayList&lt;Integer&gt; subQueue = queue.<span class="built_in">get</span>(n);</div><div class="line">                    a[k ++] = subQueue.<span class="built_in">get</span>(<span class="number">0</span>);  <span class="comment">//头部元素</span></div><div class="line">                    subQueue.remove(<span class="number">0</span>);  <span class="comment">//移除元素</span></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//打印每次排序后的新数组</span></div><div class="line"><span class="comment">//            for (int m : a) &#123;</span></div><div class="line"><span class="comment">//                System.out.print(m + " ");</span></div><div class="line"><span class="comment">//            &#125;</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">//打印最终排好序的数组</span></div><div class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> m : a) &#123;</div><div class="line">            System.out.<span class="built_in">print</span>(m + <span class="string">" "</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</div><div class="line">        <span class="built_in">int</span>[] a = &#123;<span class="number">53</span>, <span class="number">542</span>, <span class="number">3</span>, <span class="number">63</span>, <span class="number">14</span>, <span class="number">214</span>, <span class="number">154</span>, <span class="number">748</span>, <span class="number">616</span>&#125;;</div><div class="line">        radisSort(a);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">3 </span><span class="number">14</span> <span class="number">53</span> <span class="number">63</span> <span class="number">154</span> <span class="number">214</span> <span class="number">542</span> <span class="number">616</span> <span class="number">748</span></div></pre></td></tr></table></figure>
<p>以上，就是基数排序的大致过程。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;基数排序&quot;&gt;&lt;a href=&quot;#基数排序&quot; class=&quot;headerlink&quot; title=&quot;基数排序&quot;&gt;&lt;/a&gt;基数排序&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;基数排序是一种基于分配的排序（空间换时间）&lt;/strong&gt;，不同于常见的基于比较的排序（冒泡、快排、归并…
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="基数排序" scheme="http://yoursite.com/tags/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>ActiveMQ结合Spring收发消息</title>
    <link href="http://yoursite.com/2018/02/15/ActiveMQ%E7%BB%93%E5%90%88Spring%E6%94%B6%E5%8F%91%E6%B6%88%E6%81%AF/"/>
    <id>http://yoursite.com/2018/02/15/ActiveMQ结合Spring收发消息/</id>
    <published>2018-02-15T07:12:12.000Z</published>
    <updated>2018-04-14T16:29:31.778Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ActiveMQ结合Spring收发消息"><a href="#ActiveMQ结合Spring收发消息" class="headerlink" title="ActiveMQ结合Spring收发消息"></a>ActiveMQ结合Spring收发消息</h3><p>直接使用ActiveMQ的方式需要重复写很多代码，且不利于管理，Spring 提供了一种更加简便的方式————Spring JMS ，通过它可以更加方便地使用ActiveMQ。</p>
<h4 id="Maven-依赖"><a href="#Maven-依赖" class="headerlink" title="Maven 依赖"></a>Maven 依赖</h4><p>结合Spring使用ActiveMQ的依赖如下：<br><figure class="highlight dust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="xml"><span class="comment">&lt;!-- Spring JMS --&gt;</span></span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jms<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$<span class="template-variable">&#123;spring.version&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="comment">&lt;!-- xbean 如&lt;amq:connectionFactory /&gt; --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.xbean<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xbean-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="comment">&lt;!-- ActiiveMQ --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.activemq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>activemq-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.activemq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>activemq-pool<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h4 id="ActiveMQ-xml-文件"><a href="#ActiveMQ-xml-文件" class="headerlink" title="ActiveMQ.xml 文件"></a>ActiveMQ.xml 文件</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></div><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">       <span class="attr">xmlns:amq</span>=<span class="string">"http://activemq.apache.org/schema/core"</span></div><div class="line">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></div><div class="line">        http://www.springframework.org/schema/beans/spring-beans-4.0.xsd</div><div class="line">        http://activemq.apache.org/schema/core</div><div class="line">        http://activemq.apache.org/schema/core/activemq-core-5.12.1.xsd"&gt;</div><div class="line">    <span class="comment">&lt;!-- ActiveMQ 连接工厂 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">amq:connectionFactory</span> <span class="attr">id</span>=<span class="string">"amqConnectionFactory"</span></span></div><div class="line">                           <span class="attr">brokerURL</span>=<span class="string">"tcp://localhost:61616"</span></div><div class="line">                           <span class="attr">userName</span>=<span class="string">"admin"</span></div><div class="line">                           <span class="attr">password</span>=<span class="string">"admin"</span> /&gt;</div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- 提高效率，配置JMS连接工厂 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"connectionFactory"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jms.connection.CachingConnectionFactory"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"amqConnectionFactory"</span> /&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sessionCacheSize"</span> <span class="attr">value</span>=<span class="string">"100"</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 定义消息队列（Queue）--&gt;</span></div><div class="line">   <span class="comment">&lt;!-- &lt;bean id="QueueDestination" class="org.apache.activemq.command.ActiveMQQueue"&gt;</span></div><div class="line">        &amp;lt;!&amp;ndash; 设置消息队列的名字 &amp;ndash;&amp;gt;</div><div class="line">        &lt;constructor-arg value="Queue-zy"/&gt;</div><div class="line">    &lt;/bean&gt;--&gt;</div><div class="line">    <span class="comment">&lt;!--定义主题(Topic)--&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"topicDestination"</span> <span class="attr">class</span>=<span class="string">"org.apache.activemq.command.ActiveMQTopic"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"Topic-zy"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 配置JMS模板（Queue），Spring提供的JMS工具类，利用它发送、接收消息。 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jmsTemplate"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jms.core.JmsTemplate"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connectionFactory"</span> <span class="attr">ref</span>=<span class="string">"connectionFactory"</span> /&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"defaultDestination"</span> <span class="attr">ref</span>=<span class="string">"topicDestination"</span> /&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"receiveTimeout"</span> <span class="attr">value</span>=<span class="string">"10000"</span> /&gt;</span></div><div class="line">        <span class="comment">&lt;!-- true是topic，false是queue，默认是false --&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"pubSubDomain"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 配置消息队列监听者（Queue or Topic） --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"messageListener"</span> <span class="attr">class</span>=<span class="string">"com.service.TopicMessageListener"</span> /&gt;</span></div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- 显示注入消息监听容器，配置连接工厂，监听的目标是QueueDestination，监听器是上面定义的监听器 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"ListenerContainer"</span></span></div><div class="line">          <span class="attr">class</span>=<span class="string">"org.springframework.jms.listener.DefaultMessageListenerContainer"</span>&gt;</div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connectionFactory"</span> <span class="attr">ref</span>=<span class="string">"connectionFactory"</span> /&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"destination"</span> <span class="attr">ref</span>=<span class="string">"topicDestination"</span> /&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"messageListener"</span> <span class="attr">ref</span>=<span class="string">"messageListener"</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure>
<h5 id="配置connectionFactory"><a href="#配置connectionFactory" class="headerlink" title="配置connectionFactory"></a>配置connectionFactory</h5><p>connectionFactory是Spring用于创建到JMS服务器链接的，Spring提供了多种connectionFactory.</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- ActiveMQ 连接工厂 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">amq:connectionFactory</span> <span class="attr">id</span>=<span class="string">"amqConnectionFactory"</span></span></div><div class="line">                       <span class="attr">brokerURL</span>=<span class="string">"tcp://localhost:61616"</span></div><div class="line">                       <span class="attr">userName</span>=<span class="string">"admin"</span></div><div class="line">                       <span class="attr">password</span>=<span class="string">"admin"</span> /&gt;</div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 提高效率，配置JMS连接工厂 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"connectionFactory"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jms.connection.CachingConnectionFactory"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"amqConnectionFactory"</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sessionCacheSize"</span> <span class="attr">value</span>=<span class="string">"100"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<h5 id="配置Queue"><a href="#配置Queue" class="headerlink" title="配置Queue"></a>配置Queue</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=<span class="string">"QueueDestination"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.apache.activemq.command.ActiveMQQueue"</span>&gt;</div><div class="line">       <span class="xml"><span class="comment">&lt;!-- 设置消息队列的名字 --&gt;</span></span></div><div class="line">       <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"Queue-zy"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<h5 id="配置Topic"><a href="#配置Topic" class="headerlink" title="配置Topic"></a>配置Topic</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=<span class="string">"topicDestination"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.apache.activemq.command.ActiveMQTopic"</span>&gt;</div><div class="line">        <span class="xml"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"Topic-zy"</span>/&gt;</span></span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<h5 id="配置JMS消息模板——jmsTemplate"><a href="#配置JMS消息模板——jmsTemplate" class="headerlink" title="配置JMS消息模板——jmsTemplate"></a>配置JMS消息模板——jmsTemplate</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 配置JMS模板，Spring提供的JMS工具类，利用它发送、接收消息--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jmsTemplate"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jms.core.JmsTemplate"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connectionFactory"</span> <span class="attr">ref</span>=<span class="string">"connectionFactory"</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"defaultDestination"</span> <span class="attr">ref</span>=<span class="string">"QueueDestination"</span> /&gt;</span></div><div class="line">    <span class="comment">&lt;!--&lt;property name="defaultDestination" ref="topicDestination" /&gt;--&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"receiveTimeout"</span> <span class="attr">value</span>=<span class="string">"10000"</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"pubSubDomain"</span> <span class="attr">value</span>=<span class="string">"false"</span> /&gt;</span><span class="comment">&lt;!-- true是topic，false是queue，默认是false --&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<p>最后，在applicationContext.xml中引入配置好的ActiveMQ.xml<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;<span class="keyword">import</span> resource=<span class="string">"ActiveMQ.xml"</span> /&gt;</div></pre></td></tr></table></figure></p>
<p>以上就是配置文件相关的，下面是具体的业务代码。</p>
<h4 id="消息生产者服务"><a href="#消息生产者服务" class="headerlink" title="消息生产者服务"></a>消息生产者服务</h4><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Service</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerService</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> JmsTemplate jmsTemplate;</div><div class="line"></div><div class="line">    <span class="comment">//使用默认目的地</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">sendMessageDefault</span><span class="params">(<span class="keyword">final</span> String msg)</span></span>&#123;</div><div class="line">        Destination destination = jmsTemplate.getDefaultDestination();</div><div class="line">        System.out.println(<span class="string">"向队列： "</span> + destination + <span class="string">" 成功发送一条消息"</span>);</div><div class="line">        jmsTemplate.send(<span class="keyword">new</span> MessageCreator() &#123;</div><div class="line">            <span class="keyword">public</span> <span class="function">Message <span class="title">createMessage</span><span class="params">(Session session)</span> <span class="keyword">throws</span> JMSException </span>&#123;</div><div class="line">                <span class="function"><span class="keyword">return</span> session.<span class="title">createTextMessage</span><span class="params">(msg)</span></span>;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//可指定目的地</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(Destination destination,<span class="keyword">final</span> String msg)</span></span>&#123;</div><div class="line"></div><div class="line">        jmsTemplate.send(destination, <span class="keyword">new</span> MessageCreator() &#123;</div><div class="line">            <span class="keyword">public</span> <span class="function">Message <span class="title">createMessage</span><span class="params">(Session session)</span> <span class="keyword">throws</span> JMSException </span>&#123;</div><div class="line">                <span class="function"><span class="keyword">return</span> session.<span class="title">createTextMessage</span><span class="params">(msg)</span></span>;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="消息消费者服务"><a href="#消息消费者服务" class="headerlink" title="消息消费者服务"></a>消息消费者服务</h4><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">@Service</div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ConsumerService</span> &#123;</div><div class="line"></div><div class="line">    @Autowired</div><div class="line">    <span class="keyword">private</span> JmsTemplate jmsTemplate;</div><div class="line"></div><div class="line">    <span class="comment">//从指定的Destination接收消息</span></div><div class="line">    <span class="function"><span class="keyword">public</span> TextMessage <span class="title">recive</span>(<span class="params">Destination destination</span>)</span>&#123;</div><div class="line">        TextMessage message = (TextMessage) jmsTemplate.receive(destination);</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            System.<span class="keyword">out</span>.println(<span class="string">"从队列"</span> + destination.toString() + <span class="string">"收到了消息"</span> + message.getText());</div><div class="line">        &#125; <span class="keyword">catch</span> (JMSException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> message;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//从默认的Destination接收消息</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reciveDefault</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    </div><div class="line">        Destination destination = jmsTemplate.getDefaultDestination();</div><div class="line">        jmsTemplate.setReceiveTimeout(<span class="number">5000</span>);</div><div class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</div><div class="line">            TextMessage message = (TextMessage) jmsTemplate.receive(destination);</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">//这里还是同一个消费者</span></div><div class="line">                System.<span class="keyword">out</span>.println(<span class="string">"消费者  从目的地 "</span> + destination.toString() + <span class="string">" 收到了消息"</span> + message.getText());</div><div class="line">            &#125; <span class="keyword">catch</span> (JMSException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h4><p>直接在main方法中获取ApplicationContext运行，便于测试。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MsgProducer</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> ProducerService producerService;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"生产者开始发送消息："</span>);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">11</span>; i++)&#123;</div><div class="line">            String msg = <span class="string">"生产者发出的消息"</span>;</div><div class="line">            producerService.sendMessageDefault(msg + <span class="string">"-----"</span> + i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"classpath:/applicationContext.xml"</span>);</div><div class="line">        MsgProducer msgProducer = context.getBean(MsgProducer.class);</div><div class="line">        msgProducer.send();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MsgConsumer</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> ConsumerService consumerService;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recive</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"消费者 1 开始接收消息："</span>);</div><div class="line">        consumerService.reciveDefault();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"classpath:/applicationContext.xml"</span>);</div><div class="line">        MsgConsumer msgConsumer = context.getBean(MsgConsumer.class);</div><div class="line">        msgConsumer.recive();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来就可以启动项目。同样是使用两种方式测试。</p>
<h4 id="第一种方式————点对点（Queue）"><a href="#第一种方式————点对点（Queue）" class="headerlink" title="第一种方式————点对点（Queue）"></a>第一种方式————点对点（Queue）</h4><h4 id="同步的方式"><a href="#同步的方式" class="headerlink" title="同步的方式"></a>同步的方式</h4><p>先启动生产者  发送10条消息， 再启动消费者，可以看到控制台显示成功收到10条消息  </p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/%E7%82%B9%E5%AF%B9%E7%82%B9%E7%94%9F%E4%BA%A7.png" alt="image"></p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/%E7%82%B9%E5%AF%B9%E7%82%B9%E6%B6%88%E8%B4%B9.jpg" alt="image"></p>
<h4 id="异步监听的方式"><a href="#异步监听的方式" class="headerlink" title="异步监听的方式"></a>异步监听的方式</h4><p>通过监听器即可实现异步接收消息的效果，而不是像上面使用while()轮询同步的方式。<br>项目中一般都是使用异步监听的方式，<strong>在A服务中发送了一条消息，B服务可以利用消息监听器监听，当收到消息后，进行相应的操作</strong>。</p>
<h5 id="消息监听器（3种）"><a href="#消息监听器（3种）" class="headerlink" title="消息监听器（3种）"></a>消息监听器（3种）</h5><p>通过继承JMS中的<strong>MessageListener接口</strong>，实现onMessage()方法，就可以自定义监听器。这是最基本的监听器。（可根据业务实现自定义的功能）</p>
<p>另外spring也给我们提供了其他类型的消息监听器，比如 <strong>SessionAwareMessageListener</strong>，它的作用不仅可以接收消息，还可以发送一条消息通知对方表示自己收到了消息。（还有一种是<strong>MessageListenerAdapter</strong>）</p>
<p>一个简单的自定义监听器如下:收到消息后打印消息<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueMessageListener</span> <span class="keyword">implements</span> <span class="title">MessageListener</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message)</span> </span>&#123;</div><div class="line">        <span class="comment">//如果有消息</span></div><div class="line">        TextMessage tmessage = (TextMessage) message;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">if</span>(tmessage != <span class="keyword">null</span>)&#123;</div><div class="line">                System.out.println(<span class="string">"监听器监听消息："</span>+tmessage.getText());</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (JMSException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在ActiveMQ.xml中引入消息监听器：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 配置消息队列监听者（Queue） --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"queueMessageListener"</span> <span class="attr">class</span>=<span class="string">"com.service.QueueMessageListener"</span> /&gt;</span></div><div class="line">    </div><div class="line"> <span class="comment">&lt;!-- 显示注入消息监听容器，配置连接工厂，监听的目标是QueueDestination 或 topicDestination，监听器是上面自定义的监听器 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"queueListenerContainer"</span></span></div><div class="line">          <span class="attr">class</span>=<span class="string">"org.springframework.jms.listener.DefaultMessageListenerContainer"</span>&gt;</div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connectionFactory"</span> <span class="attr">ref</span>=<span class="string">"connectionFactory"</span> /&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"destination"</span> <span class="attr">ref</span>=<span class="string">"QueueDestination"</span> /&gt;</span></div><div class="line">        <span class="comment">&lt;!--&lt;property name="destination" ref="topicDestination" /&gt;--&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"messageListener"</span> <span class="attr">ref</span>=<span class="string">"queueMessageListener"</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>可以看到，当使用消息监听器之后，每发送一条消息立马就会被监听到：  </p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/%E7%82%B9%E5%AF%B9%E7%82%B9%E7%9B%91%E5%90%AC%E5%99%A8.jpg" alt="image"></p>
<h4 id="第二种方式————发布-订阅（Topic）"><a href="#第二种方式————发布-订阅（Topic）" class="headerlink" title="第二种方式————发布/订阅（Topic）"></a>第二种方式————发布/订阅（Topic）</h4><h4 id="同步的方式-1"><a href="#同步的方式-1" class="headerlink" title="同步的方式"></a>同步的方式</h4><p>类似点对点中同步的方式，只是每个消费者都能收到生产者发出的全部消息，不再赘述。</p>
<h4 id="异步监听的方式-1"><a href="#异步监听的方式-1" class="headerlink" title="异步监听的方式"></a>异步监听的方式</h4><p>启动两个监听器（两个消费者），对消息进行异步监听。看是否各自能收到生产者发送的消息。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 配置两个监听器 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"messageListener"</span> <span class="attr">class</span>=<span class="string">"com.service.TopicMessageListener"</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"messageListener2"</span> <span class="attr">class</span>=<span class="string">"com.service.TopicMessageListener2"</span> /&gt;</span></div></pre></td></tr></table></figure>
<p><img src="http://osuskkx7k.bkt.clouddn.com/%E4%B8%A4%E4%B8%AA%E7%9B%91%E5%90%AC%E5%99%A8.jpg" alt="image"></p>
<p>可以看到，每个监听器各自都收到了生产者发送的10条消息。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;ActiveMQ结合Spring收发消息&quot;&gt;&lt;a href=&quot;#ActiveMQ结合Spring收发消息&quot; class=&quot;headerlink&quot; title=&quot;ActiveMQ结合Spring收发消息&quot;&gt;&lt;/a&gt;ActiveMQ结合Spring收发消息&lt;/h3&gt;&lt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="ActiveMQ" scheme="http://yoursite.com/tags/ActiveMQ/"/>
    
      <category term="消息队列" scheme="http://yoursite.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>ActiveMQ的简单使用</title>
    <link href="http://yoursite.com/2018/02/12/ActiveMQ%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/02/12/ActiveMQ的简单使用/</id>
    <published>2018-02-12T07:12:12.000Z</published>
    <updated>2018-05-22T13:57:19.010Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ActiveMQ的简单使用"><a href="#ActiveMQ的简单使用" class="headerlink" title="ActiveMQ的简单使用"></a>ActiveMQ的简单使用</h3><p>ActiveMQ 是一种消息队列，是Apache提供的一个开源消息系统，完全采用Java实现，因此，它能很好地支持J2EE提出的JMS（Java Message Service,即Java消息服务）规范。</p>
<h4 id="第一种方式（点对点）——Queue"><a href="#第一种方式（点对点）——Queue" class="headerlink" title="第一种方式（点对点）——Queue"></a>第一种方式（点对点）——Queue</h4><h5 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.apache.activemq.ActiveMQConnectionFactory;</div><div class="line"><span class="keyword">import</span> javax.jms.*;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">//连接工厂</span></div><div class="line">        ConnectionFactory connectionFactory;</div><div class="line">        <span class="comment">//连接</span></div><div class="line">        Connection connection = <span class="keyword">null</span>;</div><div class="line">        <span class="comment">//会话</span></div><div class="line">        Session session;</div><div class="line">        <span class="comment">//目的地</span></div><div class="line">        Destination destination;</div><div class="line">        <span class="comment">//消息生产者</span></div><div class="line">        MessageProducer messageProducer;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            connectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(ActiveMQConnectionFactory.DEFAULT_USER,ActiveMQConnectionFactory.DEFAULT_PASSWORD,</div><div class="line">                    ActiveMQConnectionFactory.DEFAULT_BROKER_URL);</div><div class="line">            connection = connectionFactory.createConnection();</div><div class="line">            connection.start();</div><div class="line">            session = connection.createSession(<span class="keyword">false</span>,Session.AUTO_ACKNOWLEDGE);   <span class="comment">//不开启事务</span></div><div class="line"></div><div class="line">            destination = session.createQueue(<span class="string">"Queue-zy"</span>);</div><div class="line">            messageProducer = session.createProducer(destination);</div><div class="line">            messageProducer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);       <span class="comment">//是否持久化（默认持久化）</span></div><div class="line"></div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;<span class="number">11</span>; i++)&#123;</div><div class="line">                System.out.println(<span class="string">"生产者成功发出消息——Queue-zy：序号---"</span>+i);</div><div class="line">                TextMessage message = session.createTextMessage(<span class="string">"消息-----"</span>+i+<span class="string">"-------hello,MQ!"</span>);</div><div class="line">                messageProducer.send(message);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125; <span class="keyword">catch</span> (JMSException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">finally</span>&#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                connection.close();</div><div class="line">            &#125; <span class="keyword">catch</span> (JMSException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>控制台打印出发送消息成功的语句，总计10条消息：</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">生产者成功发出消息——Queue-zy：序号<span class="comment">---1</span></div><div class="line">生产者成功发出消息——Queue-zy：序号<span class="comment">---2</span></div><div class="line">生产者成功发出消息——Queue-zy：序号<span class="comment">---3</span></div><div class="line">生产者成功发出消息——Queue-zy：序号<span class="comment">---4</span></div><div class="line">生产者成功发出消息——Queue-zy：序号<span class="comment">---5</span></div><div class="line">生产者成功发出消息——Queue-zy：序号<span class="comment">---6</span></div><div class="line">生产者成功发出消息——Queue-zy：序号<span class="comment">---7</span></div><div class="line">生产者成功发出消息——Queue-zy：序号<span class="comment">---8</span></div><div class="line">生产者成功发出消息——Queue-zy：序号<span class="comment">---9</span></div><div class="line">生产者成功发出消息——Queue-zy：序号<span class="comment">---10</span></div></pre></td></tr></table></figure>
<p><img src="http://osuskkx7k.bkt.clouddn.com/Queue1%20%282%29.jpg" alt="image"><br>此时，打开ActiveMQ的管理页面，点击Queues，便可看到一个名为 Queue-zy 的队列：<br>Number Of Pending Messages ：表示等待被消费的消息数为 10  </p>
<p>Messages Enqueued：  表示进入队列的消息数为 10  （可叠加）</p>
<p>Messages Dequeued：  表示出队列的消息，此时为0  </p>
<h5 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h5><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="meta"><span class="meta-keyword">import</span> org.apache.activemq.ActiveMQConnectionFactory;</span></div><div class="line"><span class="meta"><span class="meta-keyword">import</span> javax.jms.*;</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</div><div class="line"></div><div class="line">        <span class="comment">//连接工厂</span></div><div class="line">        ConnectionFactory connectionFactory;</div><div class="line">        <span class="comment">//连接</span></div><div class="line">        Connection connection = <span class="literal">null</span>;</div><div class="line">        <span class="comment">//会话</span></div><div class="line">        Session session;</div><div class="line">        <span class="comment">//目的地</span></div><div class="line">        Destination destination;</div><div class="line">        <span class="comment">//消息生产者</span></div><div class="line">        MessageConsumer messageConsumer ;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            connectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(ActiveMQConnectionFactory.DEFAULT_USER,ActiveMQConnectionFactory.DEFAULT_PASSWORD,</div><div class="line">                    ActiveMQConnectionFactory.DEFAULT_BROKER_URL);</div><div class="line">            connection = connectionFactory.createConnection();</div><div class="line">            connection.start();</div><div class="line"></div><div class="line">            session = connection.createSession(<span class="literal">false</span>,Session.AUTO_ACKNOWLEDGE);</div><div class="line">            destination = session.createQueue(<span class="string">"Queue-zy"</span>);</div><div class="line">            messageConsumer = session.createConsumer(destination);</div><div class="line"></div><div class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</div><div class="line">                TextMessage textMessage = (TextMessage) messageConsumer.receive(<span class="number">10000</span>);</div><div class="line">                <span class="keyword">if</span>(textMessage != <span class="literal">null</span>)&#123;</div><div class="line">                    System.out.println(<span class="string">"消费者成功接收到消息： "</span>+textMessage.getText());</div><div class="line">                &#125;<span class="keyword">else</span>&#123;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">finally</span>&#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                connection.close();</div><div class="line">            &#125; <span class="keyword">catch</span> (JMSException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>点击Run启动消费者Main()，可以看到控制台输出，成功接收10条消息：<br><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">消费者成功接收到消息：</span> <span class="comment">消息</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">1</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">hello</span><span class="string">,</span><span class="comment">MQ!</span></div><div class="line"><span class="comment">消费者成功接收到消息：</span> <span class="comment">消息</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">2</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">hello</span><span class="string">,</span><span class="comment">MQ!</span></div><div class="line"><span class="comment">消费者成功接收到消息：</span> <span class="comment">消息</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">3</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">hello</span><span class="string">,</span><span class="comment">MQ!</span></div><div class="line"><span class="comment">消费者成功接收到消息：</span> <span class="comment">消息</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">4</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">hello</span><span class="string">,</span><span class="comment">MQ!</span></div><div class="line"><span class="comment">消费者成功接收到消息：</span> <span class="comment">消息</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">5</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">hello</span><span class="string">,</span><span class="comment">MQ!</span></div><div class="line"><span class="comment">消费者成功接收到消息：</span> <span class="comment">消息</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">6</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">hello</span><span class="string">,</span><span class="comment">MQ!</span></div><div class="line"><span class="comment">消费者成功接收到消息：</span> <span class="comment">消息</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">7</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">hello</span><span class="string">,</span><span class="comment">MQ!</span></div><div class="line"><span class="comment">消费者成功接收到消息：</span> <span class="comment">消息</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">8</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">hello</span><span class="string">,</span><span class="comment">MQ!</span></div><div class="line"><span class="comment">消费者成功接收到消息：</span> <span class="comment">消息</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">9</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">hello</span><span class="string">,</span><span class="comment">MQ!</span></div><div class="line"><span class="comment">消费者成功接收到消息：</span> <span class="comment">消息</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">10</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">hello</span><span class="string">,</span><span class="comment">MQ!</span></div></pre></td></tr></table></figure></p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/Queue-2.jpg" alt="image"></p>
<p>再次查看ActiveMQ的管理页面，点击Queues  </p>
<p>Number Of Pending Messages ：等待被消费的消息数变为 0，此时消息已经全部被消费  </p>
<p>Messages Enqueued： 进入队列的消息数为 10  （叠加）  </p>
<p>Messages Dequeued： 出队列的消息，此时为10  </p>
<h4 id="第二种方式（发布-订阅）——Topic"><a href="#第二种方式（发布-订阅）——Topic" class="headerlink" title="第二种方式（发布/订阅）——Topic"></a>第二种方式（发布/订阅）——Topic</h4><p><strong>两种方式的代码只有一处区别：由Session创建的目的地不同</strong></p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//Queue</div><div class="line"><span class="attribute">destination</span> = session.createQueue(<span class="string">"Queue-zy"</span>)<span class="comment">;</span></div><div class="line">//Topic</div><div class="line"><span class="attribute">destination</span> = session.createTopic(<span class="string">"Topic-zy"</span>)<span class="comment">;</span></div></pre></td></tr></table></figure>
<p>注意：<strong>先启动订阅者（消费者），再启动发布者（生产者）————因为在没有实现订阅消息持久化的情况下，只能在订阅者上线后才能接收到发布者发布的消息。</strong></p>
<h5 id="生产者-1"><a href="#生产者-1" class="headerlink" title="生产者"></a>生产者</h5><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="meta"><span class="meta-keyword">import</span> org.apache.activemq.ActiveMQConnectionFactory;</span></div><div class="line"><span class="meta"><span class="meta-keyword">import</span> javax.jms.*;</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</div><div class="line"></div><div class="line">        <span class="comment">//连接工厂</span></div><div class="line">        ConnectionFactory connectionFactory;</div><div class="line">        <span class="comment">//连接</span></div><div class="line">        Connection connection = <span class="literal">null</span>;</div><div class="line">        <span class="comment">//会话</span></div><div class="line">        Session session;</div><div class="line">        <span class="comment">//目的地</span></div><div class="line">        Destination destination;</div><div class="line">        <span class="comment">//消息生产者</span></div><div class="line">        MessageProducer messageProducer;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            connectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(ActiveMQConnectionFactory.DEFAULT_USER,ActiveMQConnectionFactory.DEFAULT_PASSWORD,</div><div class="line">                    ActiveMQConnectionFactory.DEFAULT_BROKER_URL);</div><div class="line">            connection = connectionFactory.createConnection();</div><div class="line">            connection.start();</div><div class="line">            session = connection.createSession(<span class="literal">false</span>,Session.AUTO_ACKNOWLEDGE);   <span class="comment">//不开启事务</span></div><div class="line"></div><div class="line">            <span class="comment">//destination = session.createQueue("Queue-zy");</span></div><div class="line">            destination = session.createTopic(<span class="string">"Topic-zy"</span>);</div><div class="line">            messageProducer = session.createProducer(destination);</div><div class="line">            messageProducer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);       <span class="comment">//是否持久化（默认持久化）</span></div><div class="line"></div><div class="line">            <span class="keyword">for</span>(int i = <span class="number">1</span>; i&lt;<span class="number">11</span>; i++)&#123;</div><div class="line">                System.out.println(<span class="string">"生产者成功发出消息——Topic-zy：序号---"</span>+i);</div><div class="line">                TextMessage message = session.createTextMessage(<span class="string">"消息-----"</span>+i+<span class="string">"-------hello,MQ!"</span>);</div><div class="line">                messageProducer.send(message);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (JMSException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">finally</span>&#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                connection.close();</div><div class="line">            &#125; <span class="keyword">catch</span> (JMSException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="消费者-1"><a href="#消费者-1" class="headerlink" title="消费者 1"></a>消费者 1</h5><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="meta"><span class="meta-keyword">import</span> org.apache.activemq.ActiveMQConnectionFactory;</span></div><div class="line"></div><div class="line"><span class="meta"><span class="meta-keyword">import</span> javax.jms.*;</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</div><div class="line"></div><div class="line">        <span class="comment">//连接工厂</span></div><div class="line">        ConnectionFactory connectionFactory;</div><div class="line">        <span class="comment">//连接</span></div><div class="line">        Connection connection = <span class="literal">null</span>;</div><div class="line">        <span class="comment">//会话</span></div><div class="line">        Session session;</div><div class="line">        <span class="comment">//目的地</span></div><div class="line">        Destination destination;</div><div class="line">        <span class="comment">//消息生产者</span></div><div class="line">        MessageConsumer messageConsumer ;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            connectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(ActiveMQConnectionFactory.DEFAULT_USER,ActiveMQConnectionFactory.DEFAULT_PASSWORD,</div><div class="line">                    ActiveMQConnectionFactory.DEFAULT_BROKER_URL);</div><div class="line">            connection = connectionFactory.createConnection();</div><div class="line">            connection.start();</div><div class="line">            session = connection.createSession(<span class="literal">false</span>,Session.AUTO_ACKNOWLEDGE);</div><div class="line"></div><div class="line">            <span class="comment">//destination = session.createQueue("Queue-zy");</span></div><div class="line">            destination = session.createTopic(<span class="string">"Topic-zy"</span>);</div><div class="line">            messageConsumer = session.createConsumer(destination);</div><div class="line"></div><div class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</div><div class="line">                TextMessage textMessage = (TextMessage) messageConsumer.receive(<span class="number">10000</span>);</div><div class="line">                <span class="keyword">if</span>(textMessage != <span class="literal">null</span>)&#123;</div><div class="line">                    System.out.println(<span class="string">"消费者 1 成功接收到消息： "</span>+textMessage.getText());</div><div class="line">                &#125;<span class="keyword">else</span>&#123;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="消费者-2"><a href="#消费者-2" class="headerlink" title="消费者 2"></a>消费者 2</h5><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="meta"><span class="meta-keyword">import</span> org.apache.activemq.ActiveMQConnectionFactory;</span></div><div class="line"><span class="meta"><span class="meta-keyword">import</span> javax.jms.*;</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer2</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</div><div class="line"></div><div class="line">        <span class="comment">//连接工厂</span></div><div class="line">        ConnectionFactory connectionFactory;</div><div class="line">        <span class="comment">//连接</span></div><div class="line">        Connection connection = <span class="literal">null</span>;</div><div class="line">        <span class="comment">//会话</span></div><div class="line">        Session session;</div><div class="line">        <span class="comment">//目的地</span></div><div class="line">        Destination destination;</div><div class="line">        <span class="comment">//消息生产者</span></div><div class="line">        MessageConsumer messageConsumer ;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            connectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(ActiveMQConnectionFactory.DEFAULT_USER,ActiveMQConnectionFactory.DEFAULT_PASSWORD,</div><div class="line">                    ActiveMQConnectionFactory.DEFAULT_BROKER_URL);</div><div class="line">            connection = connectionFactory.createConnection();</div><div class="line">            connection.start();</div><div class="line">            session = connection.createSession(<span class="literal">false</span>,Session.AUTO_ACKNOWLEDGE);</div><div class="line"></div><div class="line">            <span class="comment">//destination = session.createQueue("Queue-zy");</span></div><div class="line">            destination = session.createTopic(<span class="string">"Topic-zy"</span>);</div><div class="line">            messageConsumer = session.createConsumer(destination);</div><div class="line"></div><div class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</div><div class="line">                TextMessage textMessage = (TextMessage) messageConsumer.receive(<span class="number">10000</span>);</div><div class="line">                <span class="keyword">if</span>(textMessage != <span class="literal">null</span>)&#123;</div><div class="line">                    System.out.println(<span class="string">"消费者 2 成功接收到消息： "</span>+textMessage.getText());</div><div class="line">                &#125;<span class="keyword">else</span>&#123;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>先启动消费者 1 和 2，再启动生产者，可以看到控制台输出，消费者 1 、2都接收到了消息:</p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/c1.jpg" alt="image"></p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/c2.jpg" alt="image"></p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/Topic-2.jpg" alt="image"></p>
<p>查看ActiveMQ的管理页面，点击Topics，查看名为 Topic-zy 的主题：    </p>
<p>Number Of Consumers ：表示消费者数目为 2    </p>
<p>Messages Enqueued： 进入队列的消息数为 10    </p>
<p>Messages Dequeued： 出队列的消息，为20 （因为2个消费者） </p>
<p>以上就是直接使用 ActiveMQ 在<strong>点对点</strong>和<strong>发布订阅</strong> 两种模式下收发消息的过程。</p>
<p>下一篇，将介绍<a href="http://youngforzy.top/2018/02/15/ActiveMQ%E7%BB%93%E5%90%88Spring%E6%94%B6%E5%8F%91%E6%B6%88%E6%81%AF/" target="_blank" rel="external">ActiveMQ结合Spring收发消息</a>的过程。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;ActiveMQ的简单使用&quot;&gt;&lt;a href=&quot;#ActiveMQ的简单使用&quot; class=&quot;headerlink&quot; title=&quot;ActiveMQ的简单使用&quot;&gt;&lt;/a&gt;ActiveMQ的简单使用&lt;/h3&gt;&lt;p&gt;ActiveMQ 是一种消息队列，是Apache提供
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="ActiveMQ" scheme="http://yoursite.com/tags/ActiveMQ/"/>
    
      <category term="消息队列" scheme="http://yoursite.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Mysql自动还原脚本（.sh文件）</title>
    <link href="http://yoursite.com/2018/01/25/Mysql%E8%87%AA%E5%8A%A8%E8%BF%98%E5%8E%9F%E8%84%9A%E6%9C%AC/"/>
    <id>http://yoursite.com/2018/01/25/Mysql自动还原脚本/</id>
    <published>2018-01-25T07:12:12.000Z</published>
    <updated>2018-05-27T02:44:12.397Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Mysql自动还原脚本（-sh文件）"><a href="#Mysql自动还原脚本（-sh文件）" class="headerlink" title="Mysql自动还原脚本（.sh文件）"></a>Mysql自动还原脚本（.sh文件）</h3><h4 id="还原数据库的基本指令"><a href="#还原数据库的基本指令" class="headerlink" title="还原数据库的基本指令"></a>还原数据库的基本指令</h4><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">source</span> d:/<span class="keyword">abc</span>.sql</div></pre></td></tr></table></figure>
<p>当连接数据库之后，可以直接使用 以上命令来还原指定数据库。</p>
<h4 id="自动还原脚本"><a href="#自动还原脚本" class="headerlink" title="自动还原脚本"></a>自动还原脚本</h4><p>那么能不能使用脚本的方式自动还原呢？<br><strong>当每次都是还原同一个数据库，或者还原同一个数据库中的指定表时，便可以采用脚本的方式执行。</strong></p>
<p>当数据库备份文件存储在云端时，可采用以下脚本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"></div><div class="line">HOSTNAME = <span class="string">"bd.gameplat2dev.db"</span>         <span class="comment">#数据库信息    </span></div><div class="line">PORT = <span class="string">"1516"</span>                                  <span class="comment">#端口</span></div><div class="line">USERNAME = <span class="string">"username"</span>                          <span class="comment">#用户名</span></div><div class="line">PASSWORD = <span class="string">"123456"</span>                            <span class="comment">#密码</span></div><div class="line"></div><div class="line">DBNAME = <span class="string">"game_product"</span>                        <span class="comment">#数据库名称</span></div><div class="line"><span class="comment">#TABLENAME1 = "t_approve"                      #表名</span></div><div class="line"><span class="comment">#TABLENAME2 = "t_approve_role"  </span></div><div class="line"></div><div class="line"><span class="comment">#sql文件下载路径</span></div><div class="line">URL = <span class="string">"http://osuskkx7k.bkt.clouddn.com/ab.sql"</span></div><div class="line"></div><div class="line"><span class="comment">#定义文件名（自定义）</span></div><div class="line">FILE = <span class="string">"sqlfile.sql"</span></div><div class="line"></div><div class="line"><span class="comment">#下载sql文件</span></div><div class="line">wget <span class="variable">$&#123;URL&#125;</span> -O <span class="variable">$&#123;FILE&#125;</span></div><div class="line"></div><div class="line"><span class="comment">#输出(可无)</span></div><div class="line"><span class="built_in">echo</span> <span class="variable">$&#123;FILE&#125;</span></div><div class="line"></div><div class="line"><span class="comment">#定义 source 命令</span></div><div class="line">restore_sql = <span class="string">"source  <span class="variable">$&#123;FILE&#125;</span>"</span></div><div class="line"></div><div class="line"><span class="comment">#还原指令</span></div><div class="line">mysql -h<span class="variable">$&#123;HOSTNAME&#125;</span>  -P<span class="variable">$&#123;PORT&#125;</span>  -u<span class="variable">$&#123;USERNAME&#125;</span> -p<span class="variable">$&#123;PASSWORD&#125;</span> <span class="variable">$&#123;DBNAME&#125;</span> -e<span class="string">"<span class="variable">$&#123;restore_sql&#125;</span>"</span></div></pre></td></tr></table></figure>
<p><strong>记得另存为时，后缀是 .sh，双击即可运行</strong></p>
<h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><ul>
<li>若为本地数据库可将数据库名改为 localhost ，端口无需指定</li>
<li>脚本中 wget 工具需要安装</li>
<li>若sql文件不是存储云端，可直接指定路径</li>
<li>FILE文件名可自定义</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Mysql自动还原脚本（-sh文件）&quot;&gt;&lt;a href=&quot;#Mysql自动还原脚本（-sh文件）&quot; class=&quot;headerlink&quot; title=&quot;Mysql自动还原脚本（.sh文件）&quot;&gt;&lt;/a&gt;Mysql自动还原脚本（.sh文件）&lt;/h3&gt;&lt;h4 id=&quot;还
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Mysql" scheme="http://yoursite.com/tags/Mysql/"/>
    
      <category term="自动还原脚本" scheme="http://yoursite.com/tags/%E8%87%AA%E5%8A%A8%E8%BF%98%E5%8E%9F%E8%84%9A%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>Map 的4种遍历方式及比较</title>
    <link href="http://yoursite.com/2018/01/07/Map%20%E7%9A%844%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%E5%8F%8A%E6%AF%94%E8%BE%83/"/>
    <id>http://yoursite.com/2018/01/07/Map 的4种遍历方式及比较/</id>
    <published>2018-01-07T07:12:12.000Z</published>
    <updated>2018-04-14T16:37:56.168Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Map-的4种遍历方式及比较"><a href="#Map-的4种遍历方式及比较" class="headerlink" title="Map 的4种遍历方式及比较"></a>Map 的4种遍历方式及比较</h3><h4 id="KeySet"><a href="#KeySet" class="headerlink" title="KeySet"></a>KeySet</h4><p>第一种方式：   <strong>keySet 其实遍历了两次，第一次获取Iterator，第二次根据key获取value，因此性能较差。</strong><br><figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> testKetSet(Map&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt; <span class="built_in">map</span>) &#123;</div><div class="line">    Set&lt;<span class="keyword">String</span>&gt; keys = <span class="built_in">map</span>.keySet();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">String</span> <span class="built_in">key</span> : keys) &#123;</div><div class="line">        <span class="keyword">String</span> value =  <span class="built_in">map</span>.<span class="built_in">get</span>(<span class="built_in">key</span>);</div><div class="line">        System.out.<span class="built_in">println</span>(<span class="string">"key: "</span>+ <span class="built_in">key</span> + <span class="string">"  value: "</span> + value );</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="EntrySet"><a href="#EntrySet" class="headerlink" title="EntrySet"></a>EntrySet</h4><p>第二种方式: <strong>entrySet 优于keySet，因为一次就把key和value放入了entry)</strong><br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">public</span> void testEntrySet(<span class="meta">Map</span>&lt;<span class="keyword">String, </span><span class="keyword">String&gt; </span><span class="meta">map</span>) &#123;</div><div class="line">      Set&lt;<span class="meta">Map</span>.Entry&lt;<span class="keyword">String, </span><span class="keyword">String&gt;&gt; </span><span class="meta">entry</span> = <span class="meta">map</span>.entrySet()<span class="comment">;</span></div><div class="line">      for (<span class="meta">Map</span>.Entry&lt;<span class="keyword">String, </span><span class="keyword">String&gt; </span><span class="keyword">stringEntry </span>: <span class="meta">entry</span>) &#123;</div><div class="line">          System.out.println(<span class="string">"key: "</span>+ <span class="keyword">stringEntry.getKey() </span>+ <span class="string">"  value: "</span> + <span class="keyword">stringEntry.getValue());</span></div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<h4 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h4><p>第三种方式：<strong>Iterator （可用 it.remove()在遍历时删除）</strong><br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"> public void testIterator(<span class="meta">Map</span>&lt;<span class="keyword">String, </span><span class="keyword">String&gt; </span><span class="meta">map</span>) &#123;</div><div class="line">        <span class="keyword">Iterator&lt;Map.Entry&lt;String, </span><span class="keyword">String&gt;&gt; </span><span class="keyword">it </span>= <span class="meta">map</span>.entrySet().<span class="keyword">iterator();</span></div><div class="line">        <span class="meta">while</span> (<span class="keyword">it.hasNext()) </span>&#123;</div><div class="line">            <span class="meta">Map</span>.Entry&lt;<span class="keyword">String, </span><span class="keyword">String&gt; </span>entry1 = <span class="keyword">it.next();</span></div><div class="line">            System.out.println(<span class="string">"key: "</span>+ entry1.getKey() + <span class="string">"  value: "</span> + entry1.getValue())<span class="comment">;</span></div><div class="line">//            <span class="meta">if</span> (<span class="string">"1"</span>.equals(entry1.getKey())) &#123;</div><div class="line">//                <span class="keyword">it.remove();</span></div><div class="line">//            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h4 id="Lambda-（JDK8）"><a href="#Lambda-（JDK8）" class="headerlink" title="Lambda （JDK8）"></a>Lambda （JDK8）</h4><p>第四种方式：Lambda （<strong>本质是 entrySet</strong>）<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> testLambda(Map&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt; <span class="built_in">map</span>) &#123;</div><div class="line">       <span class="built_in">map</span>.forEach((<span class="built_in">key</span>, value) -&gt; &#123;</div><div class="line">           System.out.<span class="built_in">println</span>(<span class="string">"key: "</span>+ <span class="built_in">key</span> + <span class="string">"  value: "</span> + value );</div><div class="line">       &#125;);</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<h4 id="Values"><a href="#Values" class="headerlink" title="Values"></a>Values</h4><p>获取map所有的值，values()返回的是一个集合 <strong>Collection（可转List/Set）</strong><br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> testValues(Map&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt; <span class="built_in">map</span>) &#123;</div><div class="line">       Collection&lt;<span class="keyword">String</span>&gt; collection = <span class="built_in">map</span>.values();</div><div class="line">       <span class="built_in">for</span> (<span class="keyword">String</span> s : collection) &#123;</div><div class="line">           System.out.<span class="built_in">println</span>(<span class="string">"value: "</span> + s);</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Map-的4种遍历方式及比较&quot;&gt;&lt;a href=&quot;#Map-的4种遍历方式及比较&quot; class=&quot;headerlink&quot; title=&quot;Map 的4种遍历方式及比较&quot;&gt;&lt;/a&gt;Map 的4种遍历方式及比较&lt;/h3&gt;&lt;h4 id=&quot;KeySet&quot;&gt;&lt;a href=&quot;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="HashMap" scheme="http://yoursite.com/tags/HashMap/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java(spring)实现Mysql的定时备份与还原</title>
    <link href="http://yoursite.com/2017/12/25/Java(spring)%E5%AE%9E%E7%8E%B0Mysql%E7%9A%84%E5%AE%9A%E6%97%B6%E5%A4%87%E4%BB%BD%E4%B8%8E%E8%BF%98%E5%8E%9F/"/>
    <id>http://yoursite.com/2017/12/25/Java(spring)实现Mysql的定时备份与还原/</id>
    <published>2017-12-25T11:23:12.000Z</published>
    <updated>2018-02-24T18:19:31.342Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、数据库的定时备份"><a href="#一、数据库的定时备份" class="headerlink" title="一、数据库的定时备份"></a>一、数据库的定时备份</h3><h4 id="备份命令"><a href="#备份命令" class="headerlink" title="备份命令"></a>备份命令</h4><p>Mysql的备份指令：</p>
<ol>
<li>指定数据库：<figure class="highlight subunit"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysqldump -h localhost -uroot -proot  tuser&gt;d:\user_2017<span class="string">-12</span><span class="string">-25</span>_15<span class="string">-42</span><span class="string">-10</span>.sql</div></pre></td></tr></table></figure>
</li>
</ol>
<p>tuser：数据库名<br>user_2017-12-25_15-42-10.sql：文件名</p>
<ol>
<li>指定数据库中的多个表：</li>
</ol>
<figure class="highlight subunit"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysqldump -h localhost -uroot -proot --databases tuser --tables t_user t_user2&gt;d:\user_2017<span class="string">-12</span><span class="string">-25</span>_15<span class="string">-42</span>-two.sql</div></pre></td></tr></table></figure>
<p>在 –tables 之后加上所需备份的表名</p>
<h4 id="定时（Spring-Task）"><a href="#定时（Spring-Task）" class="headerlink" title="定时（Spring-Task）"></a>定时（Spring-Task）</h4><p>了解了mysql的备份命令，那么如何实现定时呢？<br><strong>这里采用Spring的定时任务来实现，基于注解的方式。</strong></p>
<p>主要有两点注意：</p>
<h5 id="1-Spring-xml中开启定时任务注解的配置："><a href="#1-Spring-xml中开启定时任务注解的配置：" class="headerlink" title="1. Spring.xml中开启定时任务注解的配置："></a>1. Spring.xml中开启定时任务注解的配置：</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">&lt;!--开启定时任务注解--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">task:annotation-driven</span> /&gt;</span></div></pre></td></tr></table></figure>
<p>注意在头部引入task的标签及描述</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">xmlns:</span>task=<span class="string">"http://www.springframework.org/schema/task"</span></div><div class="line"><span class="symbol">http:</span>//www.springframework<span class="meta">.org</span>/schema/task</div><div class="line"><span class="symbol">http:</span>//www.springframework<span class="meta">.org</span>/schema/task/spring-task<span class="number">-4.0</span>.xsd</div></pre></td></tr></table></figure>
<h5 id="2-在相应的方法中添加注解-Scheduled"><a href="#2-在相应的方法中添加注解-Scheduled" class="headerlink" title="2.在相应的方法中添加注解@Scheduled"></a>2.在相应的方法中添加注解@Scheduled</h5><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Scheduled</span>(cron=<span class="string">"0/5 * *  * * ? "</span>)   <span class="comment">//每5秒执行一次</span></div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">task1</span><span class="params">()</span></span>&#123;</div><div class="line">    System.out.println(<span class="string">"北京时间："</span>+<span class="keyword">new</span> Date());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意(cron=”0/5 <em> </em>  <em> </em> ? “)  表达式</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">cron=<span class="string">"0/5 * *  * * ? "</span>   表示每隔5s执行一次</div><div class="line">cron=<span class="string">" * * 0/1 * * ? "</span>   表示每隔1小时执行一次</div><div class="line"></div><div class="line">关于cronExpression的配置可以百度</div></pre></td></tr></table></figure>
<p>对数据库  tuser  中的两张表 t_user 和 t_user2 进行备份:<br>代码如下：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//定时备份方案</span></div><div class="line">   @Scheduled(cron=<span class="string">"0/5 * *  * * ? "</span>)   <span class="comment">//每5秒执行一次  @Scheduled(cron=" * * 0/1 * * ? ") 每小时一次</span></div><div class="line">   <span class="keyword">public</span> <span class="keyword">void</span> back()&#123;</div><div class="line">       System.out.<span class="built_in">println</span>(<span class="string">"现在时间是"</span>+<span class="keyword">new</span> Date());</div><div class="line">       Runtime runtime = Runtime.getRuntime();  <span class="comment">//获取Runtime实例</span></div><div class="line">       <span class="keyword">String</span> user = <span class="string">"root"</span>;</div><div class="line">       <span class="keyword">String</span> password = <span class="string">"root"</span>;</div><div class="line">       <span class="keyword">String</span> database1 = <span class="string">"tuser"</span>; <span class="comment">// 需要备份的数据库名</span></div><div class="line">       <span class="keyword">String</span> table1 = <span class="string">"t_user"</span>;</div><div class="line">       <span class="keyword">String</span> table2 = <span class="string">"t_user2"</span>;</div><div class="line">       Date currentDate = <span class="keyword">new</span> Date();</div><div class="line">       SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd_HH-mm-ss"</span>);</div><div class="line">       <span class="keyword">String</span> sdfDate = sdf.format(currentDate);</div><div class="line">       <span class="keyword">String</span> filepath = <span class="string">"d:\\time_"</span> + sdfDate + <span class="string">".sql"</span>; <span class="comment">// 备份的路径地址</span></div><div class="line">       <span class="comment">//执行命令</span></div><div class="line">       <span class="keyword">String</span> stmt = <span class="string">"mysqldump  -h localhost -u "</span>+user+<span class="string">" -p"</span>+password+<span class="string">" --databases "</span>+database1+<span class="string">" --tables "</span>+table1+<span class="string">" "</span>+table2 +<span class="string">" &gt; "</span>+filepath;   </div><div class="line">       System.out.<span class="built_in">println</span>(stmt);</div><div class="line">       <span class="built_in">try</span> &#123;</div><div class="line">           <span class="keyword">String</span>[] command = &#123; <span class="string">"cmd"</span>, <span class="string">"/c"</span>, stmt&#125;;</div><div class="line">           <span class="built_in">Process</span> <span class="built_in">process</span> = runtime.exec(command);</div><div class="line">           InputStream input = <span class="built_in">process</span>.getInputStream();</div><div class="line">           System.out.<span class="built_in">println</span>(IOUtils.toString(input, <span class="string">"UTF-8"</span>));</div><div class="line">           <span class="comment">//若有错误信息则输出</span></div><div class="line">           InputStream errorStream = <span class="built_in">process</span>.getErrorStream();</div><div class="line">           System.out.<span class="built_in">println</span>(IOUtils.toString(errorStream, <span class="string">"UTF-8"</span>));</div><div class="line">       &#125; <span class="built_in">catch</span> (IOException e) &#123;</div><div class="line">           e.printStackTrace();</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h3 id="二、数据库的还原"><a href="#二、数据库的还原" class="headerlink" title="二、数据库的还原"></a>二、数据库的还原</h3><h4 id="还原命令"><a href="#还原命令" class="headerlink" title="还原命令"></a>还原命令</h4><p>可以通过两种方式来进行还原操作。</p>
<h5 id="1-mysql-利用sql文件还原数据库"><a href="#1-mysql-利用sql文件还原数据库" class="headerlink" title="1. mysql 利用sql文件还原数据库"></a>1. mysql 利用sql文件还原数据库</h5><figure class="highlight subunit"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql -h localhost -uroot -proot tuser&lt; D:\user_2017<span class="string">-12</span><span class="string">-25</span>_15<span class="string">-42</span><span class="string">-10</span>.sql</div></pre></td></tr></table></figure>
<h5 id="2-source-命令"><a href="#2-source-命令" class="headerlink" title="2. source 命令"></a>2. source 命令</h5><p>这也是导入sql文件的方式，登录mysql之后，输入：<br><figure class="highlight subunit"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">source d:/game_product2018<span class="string">-01</span><span class="string">-02</span>_10<span class="string">-41</span><span class="string">-30</span>.sql</div></pre></td></tr></table></figure></p>
<p>注意反斜杠的方向，“source d:\ab.sql” 这样会执行失败。<br><strong>注：在Navicat中无法使用 source 命令</strong></p>
<h4 id="还原"><a href="#还原" class="headerlink" title="还原"></a>还原</h4><p>在代码中采用第一种方式实现还原操作</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> restore() &#123;</div><div class="line">    <span class="keyword">String</span> user = <span class="string">"root"</span>;</div><div class="line">    <span class="keyword">String</span> password = <span class="string">"root"</span>;</div><div class="line">    <span class="keyword">String</span> database = <span class="string">"tuser"</span>; <span class="comment">// 需要备份的数据库名</span></div><div class="line">    System.out.<span class="built_in">println</span>(<span class="string">"现在时间是"</span> + <span class="keyword">new</span> Date());</div><div class="line">    Runtime runtime = Runtime.getRuntime();</div><div class="line"></div><div class="line">    <span class="keyword">String</span> cmd = <span class="string">"mysql  -h localhost"</span> + <span class="string">" -u "</span> + user + <span class="string">" -p"</span> + password + <span class="string">" "</span> + database;</div><div class="line">    System.out.<span class="built_in">println</span>(cmd);</div><div class="line">    <span class="built_in">try</span> &#123;</div><div class="line">        <span class="keyword">String</span> filePath =  <span class="string">"D:\\user_2017-12-25_15-42-10.sql"</span>; <span class="comment">// sql文件路径</span></div><div class="line">        <span class="keyword">String</span> stmt = cmd + <span class="string">" &lt; "</span> + filePath;</div><div class="line">        <span class="keyword">String</span>[] command = &#123;<span class="string">"cmd"</span>, <span class="string">"/c"</span>, stmt&#125;;</div><div class="line">        <span class="built_in">Process</span> <span class="built_in">process</span> = runtime.exec(command);</div><div class="line">        <span class="comment">//若有错误信息则输出</span></div><div class="line">        InputStream errorStream = <span class="built_in">process</span>.getErrorStream();</div><div class="line">        System.out.<span class="built_in">println</span>(IOUtils.toString(errorStream, <span class="string">"utf-8"</span>));</div><div class="line">        <span class="comment">//等待操作</span></div><div class="line">        <span class="keyword">int</span> processComplete = <span class="built_in">process</span>.waitFor();</div><div class="line">        <span class="built_in">if</span> (processComplete == <span class="number">0</span>) &#123;</div><div class="line">            System.out.<span class="built_in">println</span>(<span class="string">"还原成功."</span>);</div><div class="line">        &#125; <span class="built_in">else</span> &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"还原数据库失败."</span>);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="built_in">catch</span> (Exception e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、数据库的定时备份&quot;&gt;&lt;a href=&quot;#一、数据库的定时备份&quot; class=&quot;headerlink&quot; title=&quot;一、数据库的定时备份&quot;&gt;&lt;/a&gt;一、数据库的定时备份&lt;/h3&gt;&lt;h4 id=&quot;备份命令&quot;&gt;&lt;a href=&quot;#备份命令&quot; class=&quot;head
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="spring定时任务" scheme="http://yoursite.com/tags/spring%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    
      <category term="Mysql备份还原" scheme="http://yoursite.com/tags/Mysql%E5%A4%87%E4%BB%BD%E8%BF%98%E5%8E%9F/"/>
    
  </entry>
  
  <entry>
    <title>中缀表达式转后缀表达式（逆波兰）</title>
    <link href="http://yoursite.com/2017/12/18/%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E9%80%86%E6%B3%A2%E5%85%B0%EF%BC%89/"/>
    <id>http://yoursite.com/2017/12/18/中缀表达式转后缀表达式（逆波兰）/</id>
    <published>2017-12-18T11:23:12.000Z</published>
    <updated>2018-02-24T18:13:36.958Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、中缀表达式转后缀表达式"><a href="#一、中缀表达式转后缀表达式" class="headerlink" title="一、中缀表达式转后缀表达式"></a>一、中缀表达式转后缀表达式</h3><p>中缀表达式就是普通的表达式。如：9+（3-1）*3+10/2<br>后缀表达式是一种不需要括号的表示法，又叫逆波兰表达式。</p>
<p>上面的式子用后缀法表示：9 3 1 - 3 * + 10 2 / +</p>
<p>那么如何转化成后缀表达式？</p>
<h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>从左往右遍历：<br><strong>1. 如果是数字则直接输出</strong><br><strong>2. 如果是符号则入栈，但要通过以下判断</strong></p>
<ul>
<li><strong>若该符号c是右括号或者c的优先级≤栈顶符号，则栈中元素依次出栈输出，c入栈</strong></li>
</ul>
<p>代码实现：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//中缀转后缀表达式（逆波兰）------栈实现</span></div><div class="line"><span class="keyword">public</span> class NiPoLan2 &#123;</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</div><div class="line">		<span class="comment">//创建栈</span></div><div class="line">		Stack&lt;<span class="keyword">String</span>&gt; s = <span class="keyword">new</span> Stack&lt;<span class="keyword">String</span>&gt;();</div><div class="line">		<span class="keyword">String</span> s1 = <span class="string">"9+(3-1)*3+10/2"</span>; 	<span class="comment">//例子  (1-2)*(4+5)   9+(3-1)*3+10/2</span></div><div class="line">		<span class="keyword">char</span>[] o = s1.toCharArray();</div><div class="line">		<span class="keyword">String</span> r = <span class="string">""</span>;	<span class="comment">//字符串r记录输出</span></div><div class="line">		<span class="comment">//遍历</span></div><div class="line">		<span class="built_in">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;o.length;i++)&#123;</div><div class="line">		<span class="comment">//符号是数字</span></div><div class="line">		<span class="built_in">if</span>(Character.isDigit(o[i]))&#123;</div><div class="line">			<span class="comment">//判断两位整数，如10</span></div><div class="line">			<span class="built_in">if</span>(i&lt;o.length<span class="number">-1</span>&amp;&amp;Character.isDigit(o[i+<span class="number">1</span>]))&#123;</div><div class="line">				r = r+o[i]+o[i+<span class="number">1</span>]+<span class="string">" "</span>;</div><div class="line">				i++; <span class="comment">//减少一次循环</span></div><div class="line">				<span class="built_in">continue</span>;</div><div class="line">			&#125;</div><div class="line">			r = r+o[i]+<span class="string">" "</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="comment">//符号是 (</span></div><div class="line">		<span class="built_in">if</span>(o[i]==<span class="string">'('</span>)&#123;</div><div class="line">			s.push(o[i]+<span class="string">""</span>);</div><div class="line">		&#125;</div><div class="line">		<span class="comment">//符号是+ or -</span></div><div class="line">		<span class="built_in">if</span>(o[i]==<span class="string">'+'</span>|o[i]==<span class="string">'-'</span>)&#123;</div><div class="line">			<span class="comment">//栈不为空，且有乘除符号，则弹出</span></div><div class="line">			<span class="built_in">if</span>(!s.isEmpty()&amp;&amp;(s.<span class="built_in">peek</span>().equals(<span class="string">"*"</span>)|s.<span class="built_in">peek</span>().equals(<span class="string">"/"</span>)))&#123;</div><div class="line">				<span class="comment">//全部出栈</span></div><div class="line">				<span class="built_in">while</span>(!s.isEmpty())&#123;</div><div class="line">					r = r + s.pop()+<span class="string">" "</span>;</div><div class="line">				&#125;</div><div class="line">				<span class="comment">//出栈后，再将+-入栈</span></div><div class="line">				s.push(o[i]+<span class="string">""</span>);</div><div class="line">				<span class="comment">//栈为空</span></div><div class="line">			&#125;<span class="built_in">else</span>&#123;</div><div class="line">				s.push(o[i]+<span class="string">""</span>);</div><div class="line">				System.out.<span class="built_in">println</span>(o[i]+<span class="string">""</span>);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="comment">//符号是右括号则配对</span></div><div class="line">		<span class="built_in">if</span>(o[i]==<span class="string">')'</span>)&#123;</div><div class="line">			<span class="keyword">String</span> a = s.pop();</div><div class="line">			System.out.<span class="built_in">println</span>(a);</div><div class="line">			r = r + a+<span class="string">" "</span>;</div><div class="line">			s.pop();</div><div class="line">		&#125;</div><div class="line">		<span class="comment">//符号是乘除</span></div><div class="line">		<span class="built_in">if</span>(o[i]==<span class="string">'*'</span>|o[i]==<span class="string">'/'</span>)&#123;</div><div class="line">			System.out.<span class="built_in">println</span>(s.<span class="built_in">peek</span>());</div><div class="line">			<span class="comment">//栈顶是加减、括号</span></div><div class="line">			<span class="built_in">if</span>(s.isEmpty())&#123;</div><div class="line">				s.push(o[i]+<span class="string">""</span>);</div><div class="line">			&#125;<span class="built_in">else</span> <span class="built_in">if</span>(s.<span class="built_in">peek</span>().equals(<span class="string">"+"</span>)|s.<span class="built_in">peek</span>().equals(<span class="string">"-"</span>)|s.<span class="built_in">peek</span>().equals(<span class="string">"("</span>))&#123;	<span class="comment">//s.peek()=="-"|s.peek()=="+"|s.peek()=="("</span></div><div class="line">				s.push(o[i]+<span class="string">""</span>);</div><div class="line">			&#125;</div><div class="line">		    <span class="comment">//栈顶是乘除，则出栈</span></div><div class="line">			<span class="built_in">else</span> <span class="built_in">if</span>(s.<span class="built_in">peek</span>()==<span class="string">"*"</span>|s.<span class="built_in">peek</span>()==<span class="string">"/"</span>)&#123;</div><div class="line">				<span class="comment">//全部出栈</span></div><div class="line">				<span class="built_in">while</span>(!s.isEmpty())&#123;</div><div class="line">					r = r + s.pop();</div><div class="line">				&#125;</div><div class="line">				s.push(o[i]+<span class="string">""</span>);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="comment">//最后栈中不为空，全部出栈</span></div><div class="line">		<span class="built_in">while</span>(!s.isEmpty())&#123;</div><div class="line">			r = r + s.pop()+<span class="string">" "</span>; </div><div class="line">		&#125;</div><div class="line">		System.out.<span class="built_in">println</span>(r);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">9 </span><span class="number">3</span> <span class="number">1</span> - <span class="number">3</span> * + <span class="number">10</span> <span class="number">2</span> / +</div></pre></td></tr></table></figure></p>
<h3 id="二、计算后缀表达式"><a href="#二、计算后缀表达式" class="headerlink" title="二、计算后缀表达式"></a>二、计算后缀表达式</h3><p>中缀表达式容易计算：9+（3-1）*3+10/2=20<br>那么后缀表达式如何计算呢？</p>
<p>还是上面的例子： 9 3 1 - 3 * + 10 2 / + </p>
<h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h4><p><strong>从左往右遍历：</strong>   </p>
<ol>
<li><strong>遇到数字就入栈</strong>  </li>
<li><strong>遇到符号就将栈顶的两个元素取出计算，将结果入栈；最后栈中的数就是最终结果</strong></li>
</ol>
<p>代码实现：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> class NiPoLan &#123;</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</div><div class="line">		</div><div class="line">		Stack&lt;Integer&gt; s = <span class="keyword">new</span> Stack&lt;Integer&gt;();</div><div class="line">		<span class="keyword">String</span> s1 = <span class="string">"9 3 1 - 3 * + 10 2 / +"</span>;</div><div class="line">		<span class="keyword">String</span>[] r = s1.<span class="built_in">split</span>(<span class="string">" "</span>);				<span class="comment">//转为字符串数组</span></div><div class="line">		System.out.<span class="built_in">println</span>(s1);</div><div class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;r.length;i++)&#123;</div><div class="line">			<span class="comment">//判断字符串r[i]是数字还是符号</span></div><div class="line">			<span class="comment">//r[i]是数字，入栈</span></div><div class="line">			<span class="keyword">if</span>(Character.isDigit(r[i].charAt(<span class="number">0</span>)))&#123;</div><div class="line">				<span class="built_in">int</span> c = Integer.valueOf(r[i]);</div><div class="line">				s.push(c);</div><div class="line">			&#125;<span class="keyword">else</span>&#123;</div><div class="line">				<span class="comment">//r[i]是符号，则运算</span></div><div class="line">				<span class="keyword">switch</span> (r[i]) &#123;</div><div class="line">				<span class="keyword">case</span> <span class="string">"-"</span>:</div><div class="line">					<span class="built_in">int</span> a = s.pop();  </div><div class="line">					<span class="built_in">int</span> b = s.pop();  </div><div class="line">					s.push(b-a);</div><div class="line">					<span class="keyword">break</span>;</div><div class="line">				<span class="keyword">case</span> <span class="string">"+"</span>:</div><div class="line">					 a = s.pop();  </div><div class="line">					 b = s.pop();  </div><div class="line">					s.push(b+a); </div><div class="line">					<span class="keyword">break</span>;</div><div class="line">				<span class="keyword">case</span> <span class="string">"/"</span>:</div><div class="line">					 a = s.pop();  </div><div class="line">					 b = s.pop();  </div><div class="line">					s.push(b/a);</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">				<span class="keyword">case</span> <span class="string">"*"</span>:</div><div class="line">					 a = s.pop();  </div><div class="line">					 b = s.pop();  </div><div class="line">					s.push(b*a);</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">				<span class="keyword">default</span>:</div><div class="line">					<span class="keyword">break</span>;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">	&#125;</div><div class="line">		<span class="comment">//输出结果</span></div><div class="line">		System.out.<span class="built_in">println</span>(s.pop());</div><div class="line">	&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>输出结果：<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">9 </span><span class="number">3</span> <span class="number">1</span> - <span class="number">3</span> * + <span class="number">10</span> <span class="number">2</span> / +</div><div class="line"><span class="number">20</span></div></pre></td></tr></table></figure></p>
<p>结果为 20。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、中缀表达式转后缀表达式&quot;&gt;&lt;a href=&quot;#一、中缀表达式转后缀表达式&quot; class=&quot;headerlink&quot; title=&quot;一、中缀表达式转后缀表达式&quot;&gt;&lt;/a&gt;一、中缀表达式转后缀表达式&lt;/h3&gt;&lt;p&gt;中缀表达式就是普通的表达式。如：9+（3-1）*3+
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="逆波兰表达式" scheme="http://yoursite.com/tags/%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java并发工具类之Semaphore</title>
    <link href="http://yoursite.com/2017/12/12/Java%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%B9%8BSemaphore/"/>
    <id>http://yoursite.com/2017/12/12/Java并发工具类之Semaphore/</id>
    <published>2017-12-12T09:42:18.000Z</published>
    <updated>2018-02-24T18:08:10.476Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、Semaphore的概念"><a href="#一、Semaphore的概念" class="headerlink" title="一、Semaphore的概念"></a>一、Semaphore的概念</h3><p><strong>Semaphore又叫信号量，用来控制同时访问特定资源的线程数量</strong>。它通过协调各个线程，以保证合理地使用公共资源。</p>
<p><strong>Semaphore和CountDownLatch一样，也是维护了一个计数器，其本质是一个共享锁。</strong></p>
<p><strong>Semaphore有公平性和非公平性之分。</strong></p>
<p><strong>Semaphore的工作过程：</strong></p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/timg.jpg" alt="image">  </p>
<ol>
<li>当一个线程想要访问某个共享资源时，它必须要先获取Semaphore；</li>
<li>当Semaphore &gt; 0 时，获取该资源并使Semaphore – 1；</li>
<li>当Semaphore = 0，则表示全部的共享资源已经被其他线程全部占用，线程必须要等待其他线程释放资源；</li>
<li>当有线程释放资源时，Semaphore+1，其他线程可以争抢资源；</li>
</ol>
<h3 id="二、Semaphore的实现分析"><a href="#二、Semaphore的实现分析" class="headerlink" title="二、Semaphore的实现分析"></a>二、Semaphore的实现分析</h3><p>前面分析可知，<strong>Semaphore的实现是共享锁。</strong></p>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>Semaphore有两个构造函数。<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</div><div class="line">        sync = <span class="keyword">new</span> NonfairSync(permits);</div><div class="line">    &#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span> </span>&#123;</div><div class="line">    sync = fair ? <span class="keyword">new</span> FairSync(permits) : <span class="keyword">new</span> NonfairSync(permits);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>第一个构造函数中传入的是资源许可的数量，默认是非公平锁。<br>第二个构造函数传入资源许可的数量和一个boolean变量，该变量可实现公平锁。</p>
<p>Semaphore在使用时有两个主要方法，acquire()方法表示获取一个资源许可，而 release()方法表示释放一个资源许可。</p>
<h4 id="资源获取：acquire-方法"><a href="#资源获取：acquire-方法" class="headerlink" title="资源获取：acquire()方法"></a>资源获取：acquire()方法</h4><p>调用acquire()方法获取一个资源：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        sync.acquireSharedInterruptibly(<span class="number">1</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>该方法调用AQS的acquireSharedInterruptibly()方法，以共享的模式获取同步状态：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></div><div class="line">            <span class="keyword">throws</span> InterruptedException &#123;</div><div class="line">        <span class="keyword">if</span> (Thread.interrupted())</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div><div class="line">        <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</div><div class="line">            doAcquireSharedInterruptibly(arg);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>然后调用tryAcquireShared()方法，该方法由Sync的子类来实现：</p>
<ul>
<li>如果是非公平模式，调用NonfairSync的tryAcquireShared()方法；</li>
<li>如果是公平模式，调用FairSync的tryAcquireShared()方法。</li>
</ul>
<p>在前面的文章 <a href="http://blog.csdn.net/babylove_bale/article/details/78317204" target="_blank" rel="external">ReentrantLock重入锁</a> 中有提到公平与非公平的实现。</p>
<p><strong>非公平模式</strong><br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">final <span class="keyword">int</span> nonfairTryAcquireShared(<span class="keyword">int</span> acquires) &#123;</div><div class="line">            <span class="built_in">for</span> (;;) &#123;</div><div class="line">                <span class="keyword">int</span> <span class="built_in">available</span> = getState();</div><div class="line">                <span class="keyword">int</span> remaining = <span class="built_in">available</span> - acquires;</div><div class="line">                <span class="built_in">if</span> (remaining &lt; <span class="number">0</span> ||</div><div class="line">                    compareAndSetState(<span class="built_in">available</span>, remaining))</div><div class="line">                    <span class="built_in">return</span> remaining;</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p>
<p>remaining 表示剩余的资源许可，如果&lt; 0，表示目前没有剩余的许可。当前线程继续等待。如果remaining &gt;0 则执行CAS操作获取资源许可。</p>
<p><strong>公平模式</strong></p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> <span class="keyword">int</span> tryAcquireShared(<span class="keyword">int</span> acquires) &#123;</div><div class="line">            <span class="built_in">for</span> (;;) &#123;</div><div class="line">                <span class="built_in">if</span> (hasQueuedPredecessors())</div><div class="line">                    <span class="built_in">return</span> <span class="number">-1</span>;</div><div class="line">                <span class="keyword">int</span> <span class="built_in">available</span> = getState();</div><div class="line">                <span class="keyword">int</span> remaining = <span class="built_in">available</span> - acquires;</div><div class="line">                <span class="built_in">if</span> (remaining &lt; <span class="number">0</span> ||</div><div class="line">                    compareAndSetState(<span class="built_in">available</span>, remaining))</div><div class="line">                    <span class="built_in">return</span> remaining;</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p><strong>在公平模式的方法中，增加了一个判断，判断同步队列中是否有等待的线程：</strong></p>
<ul>
<li>有，则插入作为尾节点，线程阻塞；</li>
<li>没有，则参与资源竞争；</li>
</ul>
<p>简而言之，公平模式就是要按等待队列中的顺序获取资源许可。</p>
<h4 id="资源释放：release-方法"><a href="#资源释放：release-方法" class="headerlink" title="资源释放：release()方法"></a>资源释放：release()方法</h4><p>Semaphore调用release()方法释放资源许可，默认释放1个。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</div><div class="line">        sync.releaseShared(<span class="number">1</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>调用AQS的releaseShared()方法：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</div><div class="line">            doReleaseShared();</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>调用Sync中重写的tryReleaseShared()方法（<strong>公平与非公平都是调用该方法</strong>），<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> tryReleaseShared(<span class="keyword">int</span> releases) &#123;</div><div class="line">            <span class="keyword">for</span> (;;) &#123;</div><div class="line">                <span class="keyword">int</span> current = getState();</div><div class="line">                <span class="keyword">int</span> <span class="keyword">next</span> = current + releases;</div><div class="line">                <span class="keyword">if</span> (<span class="keyword">next</span> &lt; current) <span class="comment">// overflow</span></div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum permit count exceeded"</span>);</div><div class="line">                <span class="keyword">if</span> (compareAndSetState(current, <span class="keyword">next</span>))</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p>
<p><strong>next代表如果许可释放成功，可用资源许可的数量。<br>这里可能有多个线程同时释放，因此利用CAS操作将资源许可数量置为next。<br>释放成功后，进入doReleaseShared()唤醒队列中等待的线程。</strong></p>
<p><strong>注：公平模式与非公平模式都是调用该release()方法。</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、Semaphore的概念&quot;&gt;&lt;a href=&quot;#一、Semaphore的概念&quot; class=&quot;headerlink&quot; title=&quot;一、Semaphore的概念&quot;&gt;&lt;/a&gt;一、Semaphore的概念&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Semaphore又叫信号量
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="Semaphore" scheme="http://yoursite.com/tags/Semaphore/"/>
    
  </entry>
  
  <entry>
    <title>Java并发工具类之CyclicBarrier</title>
    <link href="http://yoursite.com/2017/12/08/Java%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%B9%8BCyclicBarrier/"/>
    <id>http://yoursite.com/2017/12/08/Java并发工具类之CyclicBarrier/</id>
    <published>2017-12-08T10:42:18.000Z</published>
    <updated>2018-02-24T18:06:39.939Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、CyclicBarrier的概念"><a href="#一、CyclicBarrier的概念" class="headerlink" title="一、CyclicBarrier的概念"></a>一、CyclicBarrier的概念</h3><p>CyclicBarrier的意思是可循环使用的屏障。<strong>它可以让一组线程到达一个屏障时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有阻塞的线程才会继续执行。</strong></p>
<p>它就好像一道关卡，只有所有的部队（线程）都到了才能放行。</p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/cycle.png" alt="image"></p>
<h3 id="二、CyclicBarrier的实现分析"><a href="#二、CyclicBarrier的实现分析" class="headerlink" title="二、CyclicBarrier的实现分析"></a>二、CyclicBarrier的实现分析</h3><p><strong>部分源码：</strong><br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrier</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition trip = lock.newCondition();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> parties;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Runnable barrierCommand;</div><div class="line">    <span class="keyword">private</span> Generation generation = <span class="keyword">new</span> Generation();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> <span class="keyword">count</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Generation</span> </span>&#123;</div><div class="line">        <span class="keyword">boolean</span> broken = <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    ....</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到，<strong>CyclicBarrier是基于ReentrantLock和Condition实现的。</strong></p>
<ul>
<li>parties 表示拦截线程的数量</li>
<li>barrierCommand 表示所有线程到达屏障后优先执行的命令</li>
<li>Generation 表示屏障循环利用</li>
</ul>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>CyclicBarrier有两个构造函数：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(parties, <span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</div><div class="line">        <span class="keyword">this</span>.parties = parties;</div><div class="line">        <span class="keyword">this</span>.count = parties;</div><div class="line">        <span class="keyword">this</span>.barrierCommand = barrierAction;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>第一个构造函数调用的其实也是第二个构造函数，只是第二个参数barrierAction为null。这个参数其实是一个线程任务命令，用于在所有线程到达屏障时，优先执行该线程任务，方便处理更加复杂的业务场景。</p>
<h4 id="await-方法："><a href="#await-方法：" class="headerlink" title="await()方法："></a>await()方法：</h4><p>每当一个线程调用await()方法表示该线程到达屏障，</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="function"><span class="keyword">return</span> <span class="title">dowait</span><span class="params">(<span class="keyword">false</span>, <span class="number">0</span>L)</span></span>;</div><div class="line">        &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(toe); </div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>进入dowait()方法：</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> dowait(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</div><div class="line">        throws InterruptedException, BrokenBarrierException,</div><div class="line">               TimeoutException &#123;</div><div class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</div><div class="line">        lock.lock();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">final</span> Generation g = generation;</div><div class="line">            </div><div class="line">            <span class="comment">//当前generation“已损坏”，抛出异常</span></div><div class="line">            <span class="keyword">if</span> (g.broken)</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</div><div class="line">                </div><div class="line">            <span class="comment">//如果线程中断，终止CyclicBarrier</span></div><div class="line">            <span class="keyword">if</span> (Thread.interrupted()) &#123;</div><div class="line">                breakBarrier();</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//每当线程进入，计数-1</span></div><div class="line">            <span class="keyword">int</span> <span class="keyword">index</span> = --<span class="keyword">count</span>;</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">index</span> == <span class="number">0</span>) &#123;  <span class="comment">//计数为0时，进入</span></div><div class="line">                <span class="keyword">boolean</span> ranAction = <span class="keyword">false</span>;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    <span class="keyword">final</span> Runnable command = barrierCommand;</div><div class="line">                    <span class="keyword">if</span> (command != <span class="keyword">null</span>)   <span class="comment">//如果有barrierCommand，则优先执行该任务</span></div><div class="line">                        command.run();</div><div class="line">                    ranAction = <span class="keyword">true</span>;</div><div class="line">                    nextGeneration();<span class="comment">//唤醒所有等待线程，并更新generation</span></div><div class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">                &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                    <span class="keyword">if</span> (!ranAction)</div><div class="line">                        breakBarrier();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// loop until tripped, broken, interrupted, or timed out</span></div><div class="line">            <span class="comment">//自旋</span></div><div class="line">            <span class="keyword">for</span> (;;) &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    <span class="keyword">if</span> (!timed)<span class="comment">//如果不是超时等待，则调用Condition.await()方法等待</span></div><div class="line">                        trip.await();</div><div class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0</span>L)<span class="comment">//超时等待，调用Condition.awaitNanos()方法等待</span></div><div class="line">                        nanos = trip.awaitNanos(nanos);</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</div><div class="line">                    <span class="comment">//如果等待过程中，线程被中断，则执行下面的函数。</span></div><div class="line">                    <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</div><div class="line">                        breakBarrier();</div><div class="line">                        <span class="keyword">throw</span> ie;</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                </div><div class="line">                <span class="comment">//当前generation“已损坏”，抛出异常</span></div><div class="line">                <span class="keyword">if</span> (g.broken)</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</div><div class="line">                    </div><div class="line">                <span class="comment">//generation已经更新，返回index</span></div><div class="line">                <span class="keyword">if</span> (g != generation)</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">index</span>;</div><div class="line"></div><div class="line">                <span class="comment">//“超时等待”，并且时间已到,终止CyclicBarrier，并抛出异常</span></div><div class="line">                <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0</span>L) &#123;</div><div class="line">                    breakBarrier();</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            lock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>dowait()的主要处理逻辑如下：如果该线程不是到达的最后一个线程，则它会一直处于等待状态，除非发生以下情况：</p>
<ol>
<li>最后一个线程到达，即index == 0</li>
<li>超出了指定时间（超时等待）</li>
<li>其他的某个线程中断当前线程</li>
<li>其他的某个线程中断另一个等待的线程</li>
<li>其他的某个线程在等待barrier超时</li>
<li>其他的某个线程在此barrier调用reset()方法。reset()方法用于将屏障重置为初始状态。</li>
</ol>
<p>Generation对象描述着CyclicBarrier的更新换代。在CyclicBarrier中，同一批线程属于同一代。当有parties个线程到达barrier，generation就会被更新换代。</p>
<h3 id="三、CyclicBarrier与CountDownLatch的对比"><a href="#三、CyclicBarrier与CountDownLatch的对比" class="headerlink" title="三、CyclicBarrier与CountDownLatch的对比"></a>三、CyclicBarrier与CountDownLatch的对比</h3><p><strong>CyclicBarrier允许一系列线程相互等待对方到达屏障，先到达的线程被阻塞在屏障前，必须等到所有线程都到达了屏障，所有线程才能运行；CountDownLatch允许一个或多个线程等待一些特定的操作完成，而这些操作是在其它的线程中进行的，只有“被等的线程”的操作完成后，“等待的线程”才能执行；</strong></p>
<p><strong>CyclicBarrier强调的是n个线程互相等待，CountDownLatch强调的是1个线程或n个线程等待其他线程操作。</strong></p>
<p><strong>CyclicBarrier的计数器可以循环使用（出现错误可重置计数），CountDownLatch的计数器只能用一次；</strong></p>
<p><strong>CyclicBarrier可以在所有线程到达屏障后先执行一个线程任务，再运行所有线程，用于处理复杂的业务，CountDownLatch不可以。</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、CyclicBarrier的概念&quot;&gt;&lt;a href=&quot;#一、CyclicBarrier的概念&quot; class=&quot;headerlink&quot; title=&quot;一、CyclicBarrier的概念&quot;&gt;&lt;/a&gt;一、CyclicBarrier的概念&lt;/h3&gt;&lt;p&gt;Cyclic
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="CyclicBarrier" scheme="http://yoursite.com/tags/CyclicBarrier/"/>
    
  </entry>
  
  <entry>
    <title>Java并发工具类之CountDownLatch</title>
    <link href="http://yoursite.com/2017/12/03/Java%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%B9%8BCountDownLatch/"/>
    <id>http://yoursite.com/2017/12/03/Java并发工具类之CountDownLatch/</id>
    <published>2017-12-03T10:42:18.000Z</published>
    <updated>2018-02-24T18:04:34.623Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h3><p>CountDownLatch也叫闭锁，是并发包的工具类之一，允许一个或多个线程等待其他线程完成操作后再执行。</p>
<p>回忆之前，我们知道Join方法，用于让当前线程等待join的线程执行结束。</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span><span class="comment">(isAlive()</span>)&#123;</div><div class="line">    wait<span class="comment">(0)</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其原理就是不停地检查join线程是否存活，如果存活则一直等待。<br>CountDownLatch也可以实现join的功能，且功能更多。  </p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/CountDownLatch.png" alt="image"></p>
<p>CountDownLatch是通过一个计数器来实现的，当new 一个CountDownLatch对象的时候需要传入该计数器值。<br>CountDownLatch有两个最主要的方法await()和countDown()。</p>
<p>当一个线程调用await()时会阻塞；每当一个其他线程完成自己的任务调用countDown()后，计数器的值就会减1。当计数器的值为0时，就表示所有的线程均已经完成了任务，然后阻塞的线程就可以继续执行了。</p>
<h3 id="二、实现分析"><a href="#二、实现分析" class="headerlink" title="二、实现分析"></a>二、实现分析</h3><p><strong>部分源码</strong>：<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatch</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</div><div class="line">    <span class="comment">//内部类Sync（继承AQS）</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</div><div class="line">        Sync(<span class="keyword">int</span> <span class="keyword">count</span>) &#123;</div><div class="line">            setState(<span class="keyword">count</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//重写</span></div><div class="line">        <span class="keyword">protected</span> <span class="keyword">int</span> tryAcquireShared(<span class="keyword">int</span> acquires) &#123;</div><div class="line">            <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">-1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">protected</span> <span class="keyword">boolean</span> tryReleaseShared(<span class="keyword">int</span> releases) &#123;</div><div class="line">            <span class="keyword">for</span> (;;) &#123;</div><div class="line">                <span class="keyword">int</span> c = getState();</div><div class="line">                <span class="keyword">if</span> (c == <span class="number">0</span>)</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">                <span class="keyword">int</span> nextc = c<span class="number">-1</span>;</div><div class="line">                <span class="keyword">if</span> (compareAndSetState(c, nextc))</div><div class="line">                    <span class="keyword">return</span> nextc == <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//构造方法</span></div><div class="line">     <span class="keyword">public</span> CountDownLatch(<span class="keyword">int</span> <span class="keyword">count</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">count</span> &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"count &lt; 0"</span>);</div><div class="line">        <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(<span class="keyword">count</span>);</div><div class="line">    &#125;</div><div class="line">    ....</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到，CountDownLatch的实现同样依赖AQS，可见AQS作用之大。<br>观察Sync重写的方法（tryAcquireShared、tryReleaseShared），我们可以断定：<br><strong>CountDownLatch使用的是共享锁。</strong></p>
<h4 id="await-的实现"><a href="#await-的实现" class="headerlink" title="await()的实现"></a>await()的实现</h4><p>调用await()方法会阻塞当前线程，直到计数器为0或被中断。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        sync.acquireSharedInterruptibly(<span class="number">1</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>可以看到，其实调用了AQS的acquireSharedInterruptibly()方法：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></div><div class="line">            <span class="keyword">throws</span> InterruptedException &#123;</div><div class="line">        <span class="keyword">if</span> (Thread.interrupted())</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div><div class="line">        <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</div><div class="line">            doAcquireSharedInterruptibly(arg);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>该方法中，如果线程被中断则抛出异常；否则尝试获取锁。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">-1</span>;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>尝试获取锁时调用了Sync重写的tryAcquireShared()方法：<br>很简单只有一行代码，但却是CountDownLatch的原理：<strong>如果同步状态为0（计数器值为0）那么返回1，表示获取锁成功；否则返回-1，获取锁失败</strong>，并进入doAcquireSharedInterruptibly()方法：</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">private void doAcquireSharedInterruptibly(int arg)</div><div class="line">        throws InterruptedException &#123;</div><div class="line">        final <span class="keyword">Node</span> <span class="title">node</span> = addWaiter(<span class="keyword">Node</span>.<span class="title">SHARED</span>);</div><div class="line">        boolean failed = <span class="literal">true</span>;</div><div class="line">        try &#123;</div><div class="line">            for (;;) &#123;</div><div class="line">                final <span class="keyword">Node</span> <span class="title">p</span> = <span class="keyword">node</span>.<span class="title">predecessor</span>();</div><div class="line">                if (p == head) &#123;</div><div class="line">                    int r = tryAcquireShared(arg);</div><div class="line">                    //注意r只会等于 <span class="number">0</span> <span class="keyword">or</span> -<span class="number">1</span>；</div><div class="line">                    if (r &gt;= <span class="number">0</span>) &#123;</div><div class="line">                        setHeadAndPropagate(<span class="keyword">node</span><span class="title">, r</span>);</div><div class="line">                        p.next = null; // help GC</div><div class="line">                        failed = <span class="literal">false</span>;</div><div class="line">                        return;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                if (shouldParkAfterFailedAcquire(p, <span class="keyword">node</span><span class="title">) &amp;&amp;</span></div><div class="line">                    parkAndCheckInterrupt())</div><div class="line">                    throw new InterruptedException();</div><div class="line">            &#125;</div><div class="line">        &#125; finally &#123;</div><div class="line">            if (failed)</div><div class="line">                cancelAcquire(<span class="keyword">node</span><span class="title">);</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>该方法在前面共享锁的文章中有提到，它是一个自旋尝试获取锁的方法，这里不再赘述。<strong>注意18行的代码：int r = tryAcquireShared(arg)，在获取同步状态时只会返回两个值0和-1。</strong></p>
<h4 id="countDown-的实现"><a href="#countDown-的实现" class="headerlink" title="countDown()的实现"></a>countDown()的实现</h4><p>每次调用countDown()时，计数器的数量就会减1。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</div><div class="line">        sync.releaseShared(<span class="number">1</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>调用的是AQS的releaseShared()方法，释放同步状态：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</div><div class="line">            doReleaseShared();</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>进入releaseShared()方法，调用Sync重写的tryReleaseShared()方法：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</div><div class="line">            <span class="keyword">for</span> (;;) &#123;</div><div class="line">                <span class="keyword">int</span> c = getState();</div><div class="line">                <span class="keyword">if</span> (c == <span class="number">0</span>)</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">                <span class="keyword">int</span> nextc = c<span class="number">-1</span>;</div><div class="line">                <span class="keyword">if</span> (compareAndSetState(c, nextc))</div><div class="line">                    <span class="keyword">return</span> nextc == <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p>
<p>可以看到，<strong>该方法自旋CAS操作释放同步状态（可能多个线程同时调用countDown()方法，所以用CAS保证原子性），计数器每次-1，但是直到同步状态为0（计数器为0）时，才返回true</strong>。然后进入doReleaseShared()方法，唤醒阻塞的线程，使其从await()方法退出。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>CountDownLatch的内部实现是共享锁。</strong></p>
<p><strong>创建CountDownLatch时，需要传入计数器的初始值，可以理解为共享锁的总次数。</strong><br><strong>当一个线程调用await()方法，会检查计数器的值，不为0则阻塞直到为0。<br>当其他线程调用countDown()方法时（可以一个线程调用多次），会释放共享状态，计数器-1。</strong><br><strong>当计数器减为0时，阻塞的线程才会运行。</strong></p>
<h3 id="三、应用场景"><a href="#三、应用场景" class="headerlink" title="三、应用场景"></a>三、应用场景</h3><p>CountDownLatch的应用场景：<strong>主线程等到N个子线程执行完毕之后，再继续往下执行。</strong> 如跑步比赛统计排名、启动程序等。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> </span>&#123;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> <span class="type">CountDownLatch</span> cd = <span class="keyword">new</span> <span class="type">CountDownLatch</span>(<span class="number">5</span>);</div><div class="line">	<span class="comment">/*</span></div><div class="line">	 * 飞船类</div><div class="line">	 */</div><div class="line">	 <span class="class"><span class="keyword">class</span> <span class="title">Plane</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</div><div class="line">		 <span class="meta">@Override</span></div><div class="line">		public void run() &#123;</div><div class="line">			<span class="type">System</span>.out.println(<span class="string">"飞船准备就绪，倒计时5s："</span>);</div><div class="line">			<span class="type">System</span>.out.println(cd.getCount());<span class="comment">//计数器的值</span></div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				cd.await();</div><div class="line">			&#125; <span class="keyword">catch</span> (<span class="type">InterruptedException</span> e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">			<span class="type">System</span>.out.println(<span class="string">"飞船起飞啦！！！！"</span>);</div><div class="line">		&#125;</div><div class="line">	 &#125;</div><div class="line">	 <span class="comment">/*</span></div><div class="line">	 * 倒计时类</div><div class="line">	 */</div><div class="line">	 <span class="class"><span class="keyword">class</span> <span class="title">Time</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</div><div class="line">		 <span class="meta">@Override</span></div><div class="line">		public void run() &#123;</div><div class="line">			 <span class="keyword">for</span>(int i=<span class="number">5</span>;i&gt;<span class="number">0</span>;i--)&#123;</div><div class="line">				 <span class="type">System</span>.out.println(<span class="string">"起飞倒计时："</span>+i+<span class="string">"s"</span>);</div><div class="line">				 cd.countDown();</div><div class="line">			 &#125;</div><div class="line">		&#125;</div><div class="line">	 &#125;</div><div class="line">	</div><div class="line">	public static void main(<span class="type">String</span>[] args) &#123;</div><div class="line">		<span class="type">CountDownLatchDemo</span> cdemo = <span class="keyword">new</span> <span class="type">CountDownLatchDemo</span>();</div><div class="line">		<span class="type">Plane</span> p = cdemo.<span class="keyword">new</span> <span class="type">Plane</span>();</div><div class="line">		p.start();</div><div class="line">		<span class="type">Time</span> t = cdemo.<span class="keyword">new</span> <span class="type">Time</span>();</div><div class="line">		t.start();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出结果：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">飞船准备就绪，倒计时<span class="number">5</span>s：</div><div class="line"><span class="number">5</span></div><div class="line">起飞倒计时：<span class="number">5</span>s</div><div class="line">起飞倒计时：<span class="number">4</span>s</div><div class="line">起飞倒计时：<span class="number">3</span>s</div><div class="line">起飞倒计时：<span class="number">2</span>s</div><div class="line">起飞倒计时：<span class="number">1</span>s</div><div class="line">飞船起飞啦！！！！</div></pre></td></tr></table></figure></p>
<p><strong>当调用CountDownLatch的countDown方法时，计数器N就会-1，无论是在多个线程调用，还是一个线程调用多次（上面的例子就是在一个线程中多次调用）。</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、概念&quot;&gt;&lt;a href=&quot;#一、概念&quot; class=&quot;headerlink&quot; title=&quot;一、概念&quot;&gt;&lt;/a&gt;一、概念&lt;/h3&gt;&lt;p&gt;CountDownLatch也叫闭锁，是并发包的工具类之一，允许一个或多个线程等待其他线程完成操作后再执行。&lt;/p&gt;
&lt;p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="CountDownLatch" scheme="http://yoursite.com/tags/CountDownLatch/"/>
    
  </entry>
  
  <entry>
    <title>Java并发之Condition的实现分析</title>
    <link href="http://yoursite.com/2017/12/01/Java%E5%B9%B6%E5%8F%91%E4%B9%8BCondition%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2017/12/01/Java并发之Condition的实现分析/</id>
    <published>2017-12-01T07:42:18.000Z</published>
    <updated>2018-02-24T18:01:24.796Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、Condition的概念"><a href="#一、Condition的概念" class="headerlink" title="一、Condition的概念"></a>一、Condition的概念</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>回忆synchronized关键字，它配合Object的wait()、notify()系列方法可以实现等待/通知模式。</p>
<p>对于Lock，通过Condition也可以实现等待/通知模式。</p>
<p>Condition是一个接口。<br>Condition接口的实现类是Lock（AQS）中的ConditionObject。<br>Lock接口中有个 newCondition()方法，通过这个方法可以获得Condition对象（其实就是ConditionObject）。<br>因此，<strong>通过Lock对象可以获得Condition对象。</strong><br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Lock lock  = <span class="keyword">new</span> <span class="type">ReentrantLock</span>();</div><div class="line">Condition c1 = lock.<span class="keyword">new</span><span class="type">Condition</span>();</div><div class="line">Condition c2 = lock.<span class="keyword">new</span><span class="type">Condition</span>();</div></pre></td></tr></table></figure></p>
<h3 id="二、Condition的实现分析"><a href="#二、Condition的实现分析" class="headerlink" title="二、Condition的实现分析"></a>二、Condition的实现分析</h3><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>ConditionObject类是AQS的内部类，实现了Condition接口。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionObject</span> <span class="keyword">implements</span> <span class="title">Condition</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> &#123;</span></div><div class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</div><div class="line">        ...</div></pre></td></tr></table></figure>
<p>可以看到，等待队列和同步队列一样，使用的都是同步器AQS中的节点类Node。<br>同样拥有首节点和尾节点，<br>每个Condition对象都包含着一个FIFO队列。<br>结构图：</p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/condition.jpg" alt="image"></p>
<h4 id="等待"><a href="#等待" class="headerlink" title="等待"></a>等待</h4><p>调用Condition的await()方法会使线程进入等待队列，并释放锁，线程状态变为等待状态。<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public final void await() throws InterruptedException &#123;</div><div class="line">            if (Thread.interrupted())</div><div class="line">                throw new InterruptedException();</div><div class="line">            <span class="keyword">Node</span> <span class="title">node</span> = addConditionWaiter();</div><div class="line">            //释放同步状态（锁）</div><div class="line">            int savedState = fullyRelease(<span class="keyword">node</span><span class="title">);</span></div><div class="line">            int interruptMode = <span class="number">0</span>;</div><div class="line">            //判断节点是否放入同步对列</div><div class="line">            while (!isOnSyncQueue(<span class="keyword">node</span><span class="title">)) &#123;</span></div><div class="line">                //阻塞</div><div class="line">                LockSupport.park(this);</div><div class="line">                //如果已经中断了，则退出</div><div class="line">                if ((interruptMode = checkInterruptWhileWaiting(<span class="keyword">node</span><span class="title">)) != 0</span>)</div><div class="line">                    break;</div><div class="line">            &#125;</div><div class="line">            if (acquireQueued(<span class="keyword">node</span><span class="title">, savedState</span>) &amp;&amp; interruptMode != THROW_IE)</div><div class="line">                interruptMode = REINTERRUPT;</div><div class="line">            if (<span class="keyword">node</span>.<span class="title">nextWaiter</span> != null) // clean up if cancelled</div><div class="line">                unlinkCancelledWaiters();</div><div class="line">            if (interruptMode != <span class="number">0</span>)</div><div class="line">                reportInterruptAfterWait(interruptMode);</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p>
<p>分析上述方法的大概过程：</p>
<ol>
<li>将当前线程创建为节点，加入等待队列</li>
<li>释放锁，唤醒同步队列中的后继节点</li>
<li>while循环判断节点是否放入同步队列：</li>
</ol>
<ul>
<li>没有放入，则阻塞，继续while循环（如果已经中断了，则退出）</li>
<li>放入，则退出while循环，执行后面的判断</li>
</ul>
<ol>
<li>退出while说明节点已经在同步队列中，调用acquireQueued()方法加入同步状态竞争。</li>
<li>竞争到锁后从await()方法返回，即退出该方法。  </li>
</ol>
<p><img src="http://osuskkx7k.bkt.clouddn.com/enterCon.png" alt="image"></p>
<p><strong>addConditionWaiter()方法：</strong><br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">private <span class="keyword">Node</span> <span class="title">addConditionWaiter</span>() &#123;</div><div class="line">            <span class="keyword">Node</span> <span class="title">t</span> = lastWaiter;</div><div class="line">            if (t != null &amp;&amp; t.waitStatus != <span class="keyword">Node</span>.<span class="title">CONDITION</span>) &#123;</div><div class="line">                //清除条件队列中所有状态不为Condition的节点</div><div class="line">                unlinkCancelledWaiters();</div><div class="line">                t = lastWaiter;</div><div class="line">            &#125;</div><div class="line">            //将该线程创建节点，放入等待队列</div><div class="line">            <span class="keyword">Node</span> <span class="title">node</span> = new <span class="keyword">Node</span><span class="title">(Thread</span>.currentThread(), <span class="keyword">Node</span>.<span class="title">CONDITION</span>);</div><div class="line">            if (t == null)</div><div class="line">                firstWaiter = <span class="keyword">node</span><span class="title">;</span></div><div class="line">            else</div><div class="line">                t.nextWaiter = <span class="keyword">node</span><span class="title">;</span></div><div class="line">            lastWaiter = <span class="keyword">node</span><span class="title">;</span></div><div class="line">            return <span class="keyword">node</span><span class="title">;</span></div><div class="line">        &#125;</div></pre></td></tr></table></figure></p>
<p>过程分析：同步队列的首节点移动到等待队列。加入尾节点之前会清除所有状态不为Condition的节点。</p>
<hr>
<h4 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h4><p>调用Condition的signal()方法，可以唤醒等待队列的首节点（等待时间最长），唤醒之前会将该节点移动到同步队列中。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="comment">//判断是否获取了锁</span></div><div class="line">            <span class="keyword">if</span> (!isHeldExclusively())</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</div><div class="line">            Node first = firstWaiter;</div><div class="line">            <span class="keyword">if</span> (first != <span class="keyword">null</span>)</div><div class="line">                doSignal(first);</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>过程：</p>
<ol>
<li>先判断当前线程是否获取了锁</li>
<li>然后对首节点调用doSignal()方法</li>
</ol>
<figure class="highlight q"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">private void doSignal(Node <span class="built_in">first</span>) &#123;</div><div class="line">            <span class="keyword">do</span> &#123;</div><div class="line">                if ( (firstWaiter = <span class="built_in">first</span>.nextWaiter) == <span class="built_in">null</span>)</div><div class="line">                    lastWaiter = <span class="built_in">null</span>;</div><div class="line">                <span class="built_in">first</span>.nextWaiter = <span class="built_in">null</span>;</div><div class="line">            &#125; <span class="keyword">while</span> (!transferForSignal(<span class="built_in">first</span>) &amp;&amp;</div><div class="line">                     (<span class="built_in">first</span> = firstWaiter) != <span class="built_in">null</span>);</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>过程：</p>
<ol>
<li>修改首节点</li>
<li>调用transferForSignal()方法将节点移动到同步队列</li>
</ol>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">final boolean transferForSignal(<span class="keyword">Node</span> <span class="title">node</span>) &#123;</div><div class="line">        //将节点状态变为<span class="number">0</span>   </div><div class="line">        if (!compareAndSetWaitStatus(<span class="keyword">node</span><span class="title">, Node</span>.CONDITION, <span class="number">0</span>))</div><div class="line">            return <span class="literal">false</span>;</div><div class="line">        //将该节点加入同步队列</div><div class="line">        <span class="keyword">Node</span> <span class="title">p</span> = enq(<span class="keyword">node</span><span class="title">);</span></div><div class="line">        int ws = p.waitStatus;</div><div class="line">        //如果结点p的状态为cancel 或者修改waitStatus失败，则直接唤醒</div><div class="line">        if (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, <span class="keyword">Node</span>.<span class="title">SIGNAL</span>))</div><div class="line">            LockSupport.unpark(<span class="keyword">node</span>.<span class="title">thread</span>);</div><div class="line">        return <span class="literal">true</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>调用同步器的enq方法，将节点移动到同步队列，<br>满足条件后使用LockSupport唤醒该线程。  </p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/signalcon.png" alt="image"></p>
<hr>
<p>当Condition调用signalAll()方法：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> signalAll() &#123;</div><div class="line">            <span class="keyword">if</span> (!isHeldExclusively())</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</div><div class="line">            Node first = firstWaiter;</div><div class="line">            <span class="keyword">if</span> (first != <span class="keyword">null</span>)</div><div class="line">                doSignalAll(first);</div><div class="line">        &#125;</div><div class="line"><span class="keyword">private</span> <span class="keyword">void</span> doSignalAll(Node first) &#123;</div><div class="line">            lastWaiter = firstWaiter = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">do</span> &#123;</div><div class="line">                Node <span class="keyword">next</span> = first.nextWaiter;</div><div class="line">                first.nextWaiter = <span class="keyword">null</span>;</div><div class="line">                transferForSignal(first);</div><div class="line">                first = <span class="keyword">next</span>;</div><div class="line">            &#125; <span class="keyword">while</span> (first != <span class="keyword">null</span>);</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p>
<p>可以看到doSignalAll()方法使用了do-while循环来唤醒每一个等待队列中的节点，直到first为null时，停止循环。</p>
<p>一句话总结signalAll()的作用：<strong>将等待队列中的全部节点移动到同步队列中，并唤醒每个节点的线程。</strong></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>整个过程可以分为三步：</p>
<p>第一步：一个线程获取锁后，通过调用Condition的await()方法，会将当前线程先加入到等待队列中，并释放锁。然后就在await()中的一个while循环中判断节点是否已经在同步队列，是则尝试获取锁，否则一直阻塞。</p>
<p>第二步：当线程调用signal()方法后，程序首先检查当前线程是否获取了锁，然后通过doSignal(Node first)方法将节点移动到同步队列，并唤醒节点中的线程。</p>
<p>第三步：被唤醒的线程，将从await()中的while循环中退出来，然后调用acquireQueued()方法竞争同步状态。竞争成功则退出await()方法，继续执行。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、Condition的概念&quot;&gt;&lt;a href=&quot;#一、Condition的概念&quot; class=&quot;headerlink&quot; title=&quot;一、Condition的概念&quot;&gt;&lt;/a&gt;一、Condition的概念&lt;/h3&gt;&lt;h4 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="Condition" scheme="http://yoursite.com/tags/Condition/"/>
    
  </entry>
  
  <entry>
    <title>Java并发之Executor框架</title>
    <link href="http://yoursite.com/2017/11/22/Java%E5%B9%B6%E5%8F%91%E4%B9%8BExecutor%E6%A1%86%E6%9E%B6/"/>
    <id>http://yoursite.com/2017/11/22/Java并发之Executor框架/</id>
    <published>2017-11-22T08:42:18.000Z</published>
    <updated>2018-02-24T17:54:29.392Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、Executor框架的介绍"><a href="#一、Executor框架的介绍" class="headerlink" title="一、Executor框架的介绍"></a>一、Executor框架的介绍</h3><p>Java中的线程既是工作单元又是执行机制。JDK1.5开始，把工作单元与执行机制分离开来。<strong>工作单元为Runnable（Thread实现该接口）和Callable，执行机制就是Executor框架。</strong> 使用Executor框架时不用显式的创建线程Thread。</p>
<p>Executor框架由三部分组成：  </p>
<ul>
<li><strong>任务</strong>：Runnable或Callable  </li>
<li><strong>任务的执行</strong>：ExecutorService接口及其实现。  </li>
<li><strong>异步计算的结果</strong>：Future接口或其实现类FutureTask</li>
</ul>
<h4 id="Executor的结构"><a href="#Executor的结构" class="headerlink" title="Executor的结构"></a>Executor的结构</h4><p><img src="http://osuskkx7k.bkt.clouddn.com/Executor1.png" alt="image"></p>
<h4 id="Executor接口"><a href="#Executor接口" class="headerlink" title="Executor接口"></a><strong>Executor接口</strong></h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public<span class="built_in"> interface </span>Executor &#123;</div><div class="line">        void execute(Runnable command);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>Executor接口中只有一个execute()方法，用来执行已经提交的Runnable实例，可见即使是Callable实例，最后也会被封装成Runnable来执行。</strong></p>
<h4 id="ExecutorService接口"><a href="#ExecutorService接口" class="headerlink" title="ExecutorService接口"></a><strong>ExecutorService接口</strong></h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public<span class="built_in"> interface </span>ExecutorService extends Executor &#123;</div><div class="line">        void shutdown();</div><div class="line">        List&lt;Runnable&gt; shutdownNow();</div><div class="line">        &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);</div><div class="line">        &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);</div><div class="line">        Future&lt;?&gt; submit(Runnable task);</div><div class="line">        <span class="built_in">..</span><span class="built_in">..</span></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><strong>ExecutorService扩展了Executor接口，添加了许多方法用于服务、管理和关闭线程池。</strong><br>submit()方法最终执行时也是调用了execute()方法。</p>
<p>ExecutorService接口有两个实现类，ThreadPoolExecutor（核心）和ScheduledThreadPoolExecutor（定时执行）。</p>
<h4 id="Executors工具类"><a href="#Executors工具类" class="headerlink" title="Executors工具类"></a><strong>Executors工具类</strong></h4><p><strong>Executors工具类中包含了许多静态工厂方法。采用了多方法静态工厂模式。</strong> 本质是根据不同的输入创建出不同类型的对象。</p>
<p>通过Executors工具类可以创建3种类型的线程池，即3种ThreadPoolExecutor对象。实质是创建ThreadPoolExecutor时传入的参数不同。</p>
<h3 id="二、3种常用线程池"><a href="#二、3种常用线程池" class="headerlink" title="二、3种常用线程池"></a>二、3种常用线程池</h3><h4 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h4><p><strong>FixedThreadPool是固定大小的线程池。内部线程可重用。</strong><br>Executors工具类中的静态方法：<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="keyword">new</span><span class="type">FixedThreadPool</span>(int nThreads) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">ThreadPoolExecutor</span>(nThreads, nThreads,</div><div class="line">                                      <span class="number">0</span>L, TimeUnit.MILLISECONDS,</div><div class="line">                                      <span class="keyword">new</span> <span class="type">LinkedBlockingQueue</span>&lt;Runnable&gt;());</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p><strong>特点</strong>：</p>
<ol>
<li>参数corePoolSize和maximumPoolSize大小都是nThreads，说明最大线程数就是核心线程数，所以线程大小固定</li>
<li>参数keepAliveTime为0L，说明不会有空闲的线程</li>
<li>参数BlockingQueue是无界队列LinkedBlockingQueue，说明任务会一直放入，不会采用饱和策略。</li>
</ol>
<p><strong>应用场景</strong>：需要限制线程数量，适用于负载较重的服务器</p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/fixed.png" alt="image"></p>
<p><strong>工作过程</strong>：</p>
<ol>
<li>当前线程数小于corePoolSize，创建新线程执行任务</li>
<li>当前线程数等于corePoolSize，任务加入阻塞队列</li>
<li>线程反复执行阻塞队列中的任务</li>
</ol>
<h4 id="SingleThreadExecutor"><a href="#SingleThreadExecutor" class="headerlink" title="SingleThreadExecutor"></a>SingleThreadExecutor</h4><p><strong>SingleThreadExecutor是只有一个线程的线程池。</strong></p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="keyword">new</span><span class="type">SingleThreadExecutor</span>() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">FinalizableDelegatedExecutorService</span></div><div class="line">            (<span class="keyword">new</span> <span class="type">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</div><div class="line">                                    <span class="number">0</span>L, TimeUnit.MILLISECONDS,</div><div class="line">                                    <span class="keyword">new</span> <span class="type">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><strong>特点</strong>：</p>
<ol>
<li>参数corePoolSize和maximumPoolSize大小都是1，说明线程数固定为1</li>
<li>参数keepAliveTime为0L，说明不会有空闲的线程</li>
<li>参数BlockingQueue是无界队列LinkedBlockingQueue，说明任务会一直放入，不会采用饱和策略。</li>
</ol>
<p><strong>应用场景</strong>：<strong>适用于执行的任务需要保证顺序；并且在任意时间点，不会有多个线程是活动的场景。</strong></p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/single1.png" alt="image"></p>
<p><strong>工作过程</strong>：</p>
<ol>
<li>当前线程数小于1，创建一个唯一的线程执行任务</li>
<li>当前线程数等于1，任务加入阻塞队列</li>
<li>这个唯一的线程反复执行阻塞队列中的任务</li>
</ol>
<h4 id="CachedThreadPool"><a href="#CachedThreadPool" class="headerlink" title="CachedThreadPool"></a>CachedThreadPool</h4><p><strong>CachedThreadPool是一个根据需要创建线程的线程池。</strong></p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="keyword">new</span><span class="type">CachedThreadPool</span>() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</div><div class="line">                                      <span class="number">60</span>L, TimeUnit.SECONDS,</div><div class="line">                                      <span class="keyword">new</span> <span class="type">SynchronousQueue</span>&lt;Runnable&gt;());</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><strong>特点</strong>：</p>
<ol>
<li>参数corePoolSize为0，maximumPoolSize为Integer.MAX_VALUE（2147483647），说明可创建的线程数巨大，且都是可销毁的</li>
<li>参数keepAliveTime为60L，说明空闲的线程等待时间最长60s</li>
<li>参数BlockingQueue是一个没有容量的阻塞队列SynchronousQueue，说明任务会一直被线程执行。</li>
</ol>
<p><strong>应用场景</strong>：<strong>大小无界的线程池，适用于执行很多的短期异步任务的小程序，或者负载较轻的服务器。<br>注：使用时需控制并发的任务数，否则创建大量的线程可能导致严重的性能问题。</strong></p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/cached1.png" alt="image"></p>
<p><strong>工作过程</strong>：</p>
<ol>
<li>首先执行SynchronousQueue.offer()，如果有空闲的线程在执行SynchronousQueue.poll()，表示配对成功，任务交给空闲线程执行。</li>
<li>初始化时，如果没有空闲的线程，那么创建一个新的线程执行任务。</li>
<li>步骤2中的线程任务完成后，会执行SynchronousQueue.poll()等待60s，若没有任务提交，则该空闲线程销毁。</li>
</ol>
<p>SynchronousQueue队列的每个插入操作都要等待一个移除操作，因此是没有容量的队列。</p>
<hr>
<p>除上述3种常用线程池外，Executors还可以创建以下几种线程池。</p>
<p><strong>newScheduledThreadPool</strong>：可以定时或周期性执行任务的线程池（线程数目指定）</p>
<p><strong>newSingleThreadScheduledExecutor：</strong> 可以定时或周期性执行任务的线程池。只有一个线程。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、Executor框架的介绍&quot;&gt;&lt;a href=&quot;#一、Executor框架的介绍&quot; class=&quot;headerlink&quot; title=&quot;一、Executor框架的介绍&quot;&gt;&lt;/a&gt;一、Executor框架的介绍&lt;/h3&gt;&lt;p&gt;Java中的线程既是工作单元又是执行
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="Executor框架" scheme="http://yoursite.com/tags/Executor%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Java线程池的实现分析</title>
    <link href="http://yoursite.com/2017/11/18/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2017/11/18/Java线程池的实现分析/</id>
    <published>2017-11-18T12:42:18.000Z</published>
    <updated>2018-02-24T17:52:30.529Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、线程池的介绍"><a href="#一、线程池的介绍" class="headerlink" title="一、线程池的介绍"></a>一、线程池的介绍</h3><p>线程池是一种并发框架。</p>
<p>优势：</p>
<ol>
<li><strong>降低资源消耗。</strong>（重复利用线程，减少开销）</li>
<li><strong>提高响应速度。</strong>（任务到达可直接执行，不需要等待创建线程）</li>
<li><strong>提高线程的可管理性</strong>。（统一分配、监控、调优）</li>
</ol>
<p><strong>ThreadPoolExecutor是线程池的核心实现类</strong>。可以通过ThreadPoolExecutor来创建一个线程池。</p>
<h3 id="二、线程池的实现分析"><a href="#二、线程池的实现分析" class="headerlink" title="二、线程池的实现分析"></a>二、线程池的实现分析</h3><p>线程池的实现是ThreadPoolExecutor类，因此重点描述ThreadPoolExecutor类的实现。  </p>
<h4 id="ThreadPoolExecutor的结构"><a href="#ThreadPoolExecutor的结构" class="headerlink" title="ThreadPoolExecutor的结构"></a>ThreadPoolExecutor的结构</h4><p>ThreadPoolExecutor的构造方法<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></div><div class="line">                              <span class="keyword">int</span> maximumPoolSize,</div><div class="line">                              <span class="keyword">long</span> keepAliveTime,</div><div class="line">                              TimeUnit unit,</div><div class="line">                              BlockingQueue&lt;Runnable&gt; workQueue,</div><div class="line">                              ThreadFactory threadFactory,</div><div class="line">                              RejectedExecutionHandler <span class="keyword">handler</span>) &#123;</div><div class="line">        ...(省略部分)</div><div class="line">        <span class="keyword">this</span>.corePoolSize = corePoolSize;</div><div class="line">        <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</div><div class="line">        <span class="keyword">this</span>.workQueue = workQueue;</div><div class="line">        <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</div><div class="line">        <span class="keyword">this</span>.threadFactory = threadFactory;</div><div class="line">        <span class="keyword">this</span>.<span class="keyword">handler</span> = <span class="keyword">handler</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>构造函数中省略了部分判断的代码。<br>主要有7个参数：  </p>
<p><strong>corePoolSize</strong>：核心线程池的大小  </p>
<p><strong>maximumPoolSize</strong>：线程池的大小  </p>
<p><strong>keepAliveTime</strong>：存活时间（超过核心数目的线程空闲后的存活时间）  </p>
<p><strong>TimeUnit</strong>：时间单位  </p>
<p><strong>BlockingQueue<runnable></runnable></strong>：任务队列（保存等待任务的阻塞队列）  </p>
<p><strong>ThreadFactory</strong>：创建线程的工厂类   </p>
<p><strong>RejectedExecutionHandler</strong> ：饱和策略（拒绝策略）</p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/%E7%BA%BF%E7%A8%8B%E6%B1%A0.png" alt="image"></p>
<h4 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h4><p>当提交一个新任务时，线程池的工作过程：</p>
<ol>
<li><p><strong>判断核心线程池（corePool）中的线程是否都在执行任务。如果不是，创建一个新的线程执行任务。核心线程池已满，进入2</strong>；  </p>
</li>
<li><p><strong>判断任务队列是否已满。未满，则将新的任务存入；满了，进入3；</strong></p>
</li>
<li><strong>判断线程池（maximumPoolSize）里的线程是否都在工作。如果没有，创建一个新的线程执行任务；否则，交给饱和策略4</strong>；</li>
<li><strong>根据不同的饱和策略处理这个任务</strong>。</li>
</ol>
<p><img src="http://osuskkx7k.bkt.clouddn.com/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B.png" alt="image"></p>
<p>饱和策略有4种：</p>
<ul>
<li><strong>AbortPolicy（默认）</strong>：直接抛出异常</li>
<li><strong>CallerRunsPolicy</strong>：只用调用者所在线程来处理</li>
<li><strong>DiscardOldestPolicy</strong>：丢弃任务队列中最后一个任务，执行当前任务</li>
<li><strong>DiscardPolicy</strong>：不处理丢弃掉</li>
</ul>
<p>线程池回收线程时，对所谓的“核心线程”和“非核心线程”是一视同仁的，直到线程池中线程的数量等于corePoolSize参数时，回收过程才会停止。<br>如果设置的corePoolSize参数和maximumPoolSize参数一致时，线程池在任何情况下都不会回收空闲线程。keepAliveTime和timeUnit也就失去了意义。<br>可以调用以下方法回收核心线程。<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">threadPoolExecutor.allowCoreThreadTimeOut(true)<span class="comment">;</span></div></pre></td></tr></table></figure></p>
<h4 id="线程池处理任务"><a href="#线程池处理任务" class="headerlink" title="线程池处理任务"></a>线程池处理任务</h4><p>线程池处理任务的方法主要有两种，execute()和submit()。</p>
<p><strong>execute()</strong>  </p>
<p><strong>execute()方法用于提交不需要返回值的任务</strong>，Runnable实例。所以无法判断任务是否被线程池执行成功。</p>
<p><strong>submit()</strong><br><strong>submit()方法用于提交需要返回值的任务</strong>。线程池会返回一个future类型的对象，通过这个对象可以判断任务是否执行成功。</p>
<p>future的get()方法会阻塞当前线程直到任务完成，返回结果。</p>
<p>submit()最终调用的也是execute(Runnable runable)，submit()只是将Callable或Runnable封装成一个FutureTask对象，因为FutureTask是个Runnable，所以调用的是execute()方法。</p>
<h4 id="线程池的关闭"><a href="#线程池的关闭" class="headerlink" title="线程池的关闭"></a>线程池的关闭</h4><p>线程池关闭的方法主要有两种，shutdown()和shutdownNow()。</p>
<p><strong>原理</strong>：遍历线程池中的工作线程，逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法停止。</p>
<p><strong>区别</strong>：<br><strong>shutdown()只是将线程池的状态设置成SHUTDOWN状态，然后中断没有在执行任务的线程。</strong></p>
<p><strong>shutdownNow()首先将线程池的状态设置成STOP，然后尝试停止所有正在执行或暂停任务的线程，并返回等待执行任务的列表。</strong></p>
<p>如果任务不一定要执行完，可以调用shutdownNow()方法。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、线程池的介绍&quot;&gt;&lt;a href=&quot;#一、线程池的介绍&quot; class=&quot;headerlink&quot; title=&quot;一、线程池的介绍&quot;&gt;&lt;/a&gt;一、线程池的介绍&lt;/h3&gt;&lt;p&gt;线程池是一种并发框架。&lt;/p&gt;
&lt;p&gt;优势：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;降低
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="Java线程池" scheme="http://yoursite.com/tags/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>ConcurrentHashMap在JDK1.8中的实现分析</title>
    <link href="http://yoursite.com/2017/11/10/ConcurrentHashMap%E5%9C%A8JDK1.8%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2017/11/10/ConcurrentHashMap在JDK1.8中的实现分析/</id>
    <published>2017-11-10T08:42:18.000Z</published>
    <updated>2018-02-24T17:40:51.020Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、ConcurrentHashMap的介绍"><a href="#一、ConcurrentHashMap的介绍" class="headerlink" title="一、ConcurrentHashMap的介绍"></a>一、ConcurrentHashMap的介绍</h3><p><strong>ConcurrentHashMap在JDK8中进行了巨大改动，它舍弃了锁分段的技术，大量引入了CAS操作，以此来实现并发操作。</strong>   </p>
<p>回忆JDK1.7中的ConcurrentHashmap，当hash碰撞频繁时，链表长度会拉长，而链表的增改删查操作都会消耗很长的时间，影响性能，因此和JDK1.8中的HashMap一样，当链表过长时，将其结构转化为红黑树，由此提高性能。</p>
<h3 id="二、ConcurrentHashMap的实现原理"><a href="#二、ConcurrentHashMap的实现原理" class="headerlink" title="二、ConcurrentHashMap的实现原理"></a>二、ConcurrentHashMap的实现原理</h3><p><strong>ConcurrentHashMap的结构图</strong></p>
<p>ConcurrentHashMap在JDK1.8的实现原理是“<strong>数组+链表+红黑树</strong>”。（与HashMap在1.8中的实现思想一致，但是<strong>红黑树的节点不同</strong>，HashMap是Node节点，ConcurrentHashMap是TreeBin对象）</p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/1.8hash.PNG" alt="image"></p>
<hr>
<p>下面介绍一下ConcurrentHashMap主要方法put()和get()的实现。</p>
<h4 id="put-方法"><a href="#put-方法" class="headerlink" title="put()方法"></a>put()方法</h4><figure class="highlight gauss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line">final V putVal(K <span class="built_in">key</span>, V value, boolean onlyIfAbsent) &#123;</div><div class="line">---第一部分</div><div class="line">        <span class="keyword">if</span> (<span class="built_in">key</span> == <span class="built_in">null</span> || value == <span class="built_in">null</span>) throw <span class="keyword">new</span> NullPointerException();</div><div class="line">        <span class="comment">//计算hash值</span></div><div class="line">        int hash = spread(<span class="built_in">key</span>.hashCode());</div><div class="line">        int binCount = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt;[] <span class="built_in">tab</span> = table;;) &#123;</div><div class="line">            Node&lt;K,V&gt; f; int n, i, fh;</div><div class="line">            <span class="comment">//如果tab为null，则初始化</span></div><div class="line">            <span class="keyword">if</span> (<span class="built_in">tab</span> == <span class="built_in">null</span> || (n = <span class="built_in">tab</span>.length) == <span class="number">0</span>)</div><div class="line">                <span class="built_in">tab</span> = initTable();</div><div class="line">            <span class="comment">//判断数组索引位置的元素是否为null</span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(<span class="built_in">tab</span>, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="built_in">null</span>) &#123;</div><div class="line">                <span class="comment">//CAS操作设置该数组索引位置为新节点Node</span></div><div class="line">                <span class="keyword">if</span> (casTabAt(<span class="built_in">tab</span>, i, <span class="built_in">null</span>,</div><div class="line">                             <span class="keyword">new</span> Node&lt;K,V&gt;(hash, <span class="built_in">key</span>, value, <span class="built_in">null</span>)))</div><div class="line">                    <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></div><div class="line">            &#125;</div><div class="line">            <span class="comment">//f节点是MOVED节点，表示有其他线程在扩容，帮助一起扩容</span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</div><div class="line">                <span class="built_in">tab</span> = helpTransfer(<span class="built_in">tab</span>, f);</div><div class="line">                </div><div class="line">---第二部分-----</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                V oldVal = <span class="built_in">null</span>;</div><div class="line">                synchronized (f) &#123;</div><div class="line">                    <span class="keyword">if</span> (tabAt(<span class="built_in">tab</span>, i) == f) &#123;</div><div class="line">                        <span class="comment">//表示是链表，还未转化成红黑树</span></div><div class="line">                        <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</div><div class="line">                            binCount = <span class="number">1</span>;</div><div class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</div><div class="line">                                K ek;</div><div class="line">                                <span class="comment">//如果key已存在，则替换value</span></div><div class="line">                                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                                    ((ek = e.<span class="built_in">key</span>) == <span class="built_in">key</span> ||</div><div class="line">                                     (ek != <span class="built_in">null</span> &amp;&amp; <span class="built_in">key</span>.equals(ek)))) &#123;</div><div class="line">                                    oldVal = e.val;</div><div class="line">                                    <span class="keyword">if</span> (!onlyIfAbsent)</div><div class="line">                                        e.val = value;</div><div class="line">                                    <span class="keyword">break</span>;</div><div class="line">                                &#125;</div><div class="line">                                Node&lt;K,V&gt; pred = e;</div><div class="line">                                <span class="comment">//将新的节点插入尾部</span></div><div class="line">                                <span class="keyword">if</span> ((e = e.next) == <span class="built_in">null</span>) &#123;</div><div class="line">                                    pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, <span class="built_in">key</span>,</div><div class="line">                                                              value, <span class="built_in">null</span>);</div><div class="line">                                    <span class="keyword">break</span>;</div><div class="line">                                &#125;</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                        <span class="comment">//节点f是TreeBin对象，表示链表转为了红黑树</span></div><div class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (f instanceof TreeBin) &#123;</div><div class="line">                            Node&lt;K,V&gt; p;</div><div class="line">                            binCount = <span class="number">2</span>;</div><div class="line">                            <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, <span class="built_in">key</span>,</div><div class="line">                                                           value)) != <span class="built_in">null</span>) &#123;</div><div class="line">                                oldVal = p.val;</div><div class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</div><div class="line">                                    p.val = value;</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</div><div class="line">                    <span class="comment">//如果大于8，转化为红黑树</span></div><div class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</div><div class="line">                        treeifyBin(<span class="built_in">tab</span>, i);</div><div class="line">                    <span class="keyword">if</span> (oldVal != <span class="built_in">null</span>)</div><div class="line">                        <span class="keyword">return</span> oldVal;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        addCount(<span class="number">1</span>L, binCount);</div><div class="line">        <span class="keyword">return</span> <span class="built_in">null</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>由于整个put()方法较长，分成两部分来分析。<br><strong>第一部分：</strong></p>
<ol>
<li>遍历数组tab，如果为null，初始化数组；</li>
<li><strong>调用tabAt()方法查找数组索引i处的节点f，如果f为null，说明该位置还没有节点，调用casTabAt()利用CAS操作插入新的节点</strong></li>
</ol>
<ul>
<li><strong>CAS成功</strong>：break跳出，直到最后的addCount(1L, binCount)方法，判断插入这一个节点后是否需要扩容; </li>
<li><strong>CAS失败</strong>：说明有其它线程提前插入了节点，自旋重新尝试在这个位置插入节点；<br>tabAt()和casTabAt()方法源码如下：<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"> private static final sun.misc.Unsafe U;</div><div class="line"> </div><div class="line">static final <span class="tag">&lt;K,V&gt;</span> <span class="keyword">Node</span><span class="title">&lt;K</span>,V&gt; tabAt(<span class="keyword">Node</span><span class="title">&lt;K</span>,V&gt;[] tab, int i) &#123;</div><div class="line">        return (<span class="keyword">Node</span><span class="title">&lt;K</span>,V&gt;)U.getObjectVolatile(tab, ((long)i <span class="tag">&lt;&lt; ASHIFT) + ABASE);</span></div><div class="line">    &#125;</div><div class="line">static final &lt;K,V&gt; boolean casTabAt(<span class="keyword">Node</span><span class="title">&lt;K</span>,V&gt;[] tab, int i,</div><div class="line">                                        <span class="keyword">Node</span><span class="title">&lt;K</span>,V&gt; c, <span class="keyword">Node</span><span class="title">&lt;K</span>,V&gt; v) &#123;</div><div class="line">        return U.compareAndSwapObject(tab, ((long)i <span class="tag">&lt;&lt; ASHIFT) + ABASE, c, v);</span></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>可以看到，都是<strong>调用Unsafe类的方法（原子性），Unsafe.getObjectVolatile可以直接获取指定内存的数据，保证了每次拿到数据都是最新的。</strong></p>
<ol>
<li><strong>若前面的情况都不满足，判断f节点是否为MOVED节点，是则表示有其他线程在扩容，帮助一起扩容</strong>；否则进入第二部分。  </li>
</ol>
<p><strong>第二部分：</strong>  </p>
<p>第二部分表示把新的节点Node插入链表或红黑树，可以看到使用了synchronized关键字实现同步。<strong>但是注意，只在节点f上进行同步，表示只能有一个线程访问该节点。</strong> 节点插入之前，再次利用 tabAt(tab, i) == f 判断头节点是否还是f，防止被其它线程修改。</p>
<ol>
<li>如果f.hash &gt;= 0，说明f是链表结构的头结点，遍历链表，如果key已存在，则修改value，否则在链表尾部插入节点。</li>
<li>如果f是TreeBin类型节点，说明链表变成红黑树，则在树结构上遍历元素，更新或增加节点。</li>
<li>最后判断链表中的节点数binCount &gt;= 8，则转化为红黑树。</li>
</ol>
<hr>
<h4 id="get-方法"><a href="#get-方法" class="headerlink" title="get()方法"></a>get()方法</h4><figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> V <span class="built_in">get</span>(<span class="keyword">Object</span> <span class="built_in">key</span>) &#123;</div><div class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="built_in">int</span> n, eh; K ek;</div><div class="line">        <span class="comment">//获取key的hash值</span></div><div class="line">        <span class="built_in">int</span> h = spread(<span class="built_in">key</span>.hashCode());</div><div class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</div><div class="line">            (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</div><div class="line">                <span class="keyword">if</span> ((ek = e.<span class="built_in">key</span>) == <span class="built_in">key</span> || (ek != <span class="keyword">null</span> &amp;&amp; <span class="built_in">key</span>.equals(ek)))</div><div class="line">                    <span class="keyword">return</span> e.val;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</div><div class="line">                <span class="keyword">return</span> (p = e.find(h, <span class="built_in">key</span>)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</div><div class="line">            <span class="comment">//遍历    </span></div><div class="line">            <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (e.hash == h &amp;&amp;</div><div class="line">                    ((ek = e.<span class="built_in">key</span>) == <span class="built_in">key</span> || (ek != <span class="keyword">null</span> &amp;&amp; <span class="built_in">key</span>.equals(ek))))</div><div class="line">                    <span class="keyword">return</span> e.val;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ol>
<li>如果table为null或者遍历之后没找到对应的value，返回null；</li>
<li>根据key的hash值找到table中指定的Node节点，遍历链表或红黑树找到对应的value值。<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4></li>
</ol>
<p>最后总结一下<strong>ConcurrentHashMap从JDK1.7（1.6）到JDK1.8的变化</strong>：</p>
<ol>
<li><strong>底层结构改变</strong>，从“<strong>数组+数组+链表</strong>”到“<strong>数组+链表+红黑树</strong>”</li>
<li><strong>锁方式改变，取消了Segment重入锁，变成CAS+Synchronized实现锁</strong></li>
<li><strong>锁粒度变小</strong>，<strong>由Segment数组变成table的元素</strong>。</li>
<li>JDK1.8中size()实现更简单</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、ConcurrentHashMap的介绍&quot;&gt;&lt;a href=&quot;#一、ConcurrentHashMap的介绍&quot; class=&quot;headerlink&quot; title=&quot;一、ConcurrentHashMap的介绍&quot;&gt;&lt;/a&gt;一、ConcurrentHashMap的
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="ConcurrentHashMap" scheme="http://yoursite.com/tags/ConcurrentHashMap/"/>
    
      <category term="JDK1.8" scheme="http://yoursite.com/tags/JDK1-8/"/>
    
  </entry>
  
  <entry>
    <title>ConcurrentHashMap在JDK1.7中的实现分析</title>
    <link href="http://yoursite.com/2017/11/06/ConcurrentHashMap%E5%9C%A8JDK1.7%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2017/11/06/ConcurrentHashMap在JDK1.7中的实现分析/</id>
    <published>2017-11-06T09:48:18.000Z</published>
    <updated>2018-02-24T17:36:40.387Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、ConcurrentHashMap的介绍"><a href="#一、ConcurrentHashMap的介绍" class="headerlink" title="一、ConcurrentHashMap的介绍"></a>一、ConcurrentHashMap的介绍</h3><p>ConcurrentHashMap是线程安全且高效的HashMap，可以在多线程的环境下使用。<br><strong>ConcurrentHashMap允许多个线程并发访问，其关键在于使用了锁分段技术。</strong><br>锁分段：首先将数据分成一段一段地存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个数据段的时候，其他数据段也能被其他线程访问。</p>
<h3 id="二、ConcurrentHashMap的实现原理"><a href="#二、ConcurrentHashMap的实现原理" class="headerlink" title="二、ConcurrentHashMap的实现原理"></a>二、ConcurrentHashMap的实现原理</h3><p><strong>ConcurrentHashMap的结构图</strong>  </p>
<p>ConcurrentHashMap在JDK1.8之前的实现原理是“<strong>数组+数组+链表</strong>”。（可能描述不妥）<br><img src="http://osuskkx7k.bkt.clouddn.com/concurrentHashmap.PNG" alt="image"></p>
<p>第一个数组是Segment[ ]，每一个Segment类似于HashMap；<br>第二个数组是HashEntry[ ]，每个元素可能是一个链表；<br>链表是HashEntry形成的链表，HashEntry是一个节点。</p>
<hr>
<h4 id="HashEntry类"><a href="#HashEntry类" class="headerlink" title="HashEntry类"></a>HashEntry类</h4><figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> HashEntry&lt;K,V&gt; &#123;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</div><div class="line">        <span class="keyword">final</span> K key;</div><div class="line">        <span class="keyword">volatile</span> V value;</div><div class="line">        <span class="keyword">volatile</span> HashEntry&lt;K,V&gt; <span class="keyword">next</span>;</div><div class="line">        ....</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>HashEntry类相当于HashMap中的Entry类（节点类），储存了key和value，并拥有指向下一个元素的引用next。<br>注：<strong>value采用volatile修饰，保证了线程之间的可见性</strong>。</p>
<h4 id="Segment类"><a href="#Segment类" class="headerlink" title="Segment类"></a>Segment类</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span> &#123;</span></div><div class="line"></div><div class="line">        <span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;</div><div class="line">        <span class="keyword">transient</span> <span class="keyword">int</span> count;</div><div class="line">        <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</div><div class="line">        <span class="keyword">transient</span> <span class="keyword">int</span> threshold;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">float</span> loadFactor; </div><div class="line">        ....</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>每个Segment都拥有一个HashEntry[]数组，还有threshold和loadFactor分别表示极限容量和负载因子，count表示元素个数，modCount表示修改的记录。如此看来，<strong>每个Segment就好比是一个缩小版的HashMap</strong>，从上面ConcurrentHashMap结构图也可以看出来。</p>
<p><strong>Segment继承自ReentrantLock重入锁，因此它支持一个线程重进入同一个Segment，访问其中的数据。</strong></p>
<hr>
<p>下面介绍一下ConcurrentHashMap主要的几个方法的实现:put()方法、get()方法、size()方法</p>
<h4 id="put-方法"><a href="#put-方法" class="headerlink" title="put()方法"></a>put()方法</h4><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span>(<span class="params">K key, V <span class="keyword">value</span></span>) </span>&#123;</div><div class="line">        Segment&lt;K,V&gt; s;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">value</span> == <span class="literal">null</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">        <span class="keyword">int</span> hash = hash(key);</div><div class="line">        <span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</div><div class="line">        <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject</div><div class="line">             (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="literal">null</span>) </div><div class="line">            <span class="comment">// 扩容 </span></div><div class="line">            s = ensureSegment(j);</div><div class="line">        <span class="keyword">return</span> s.put(key, hash, <span class="keyword">value</span>, <span class="literal">false</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>首先定位到相应的Segment。<br>如果需要扩容则进入ensureSegment(j)方法，<strong>注意ConcurrentHashMap不会对整个容器扩容，而只对当前的Segment进行扩容。</strong>  扩容为原来的2倍。<br>如果不需要扩容，调用Segment中的put()方法：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="function">final V <span class="title">put</span>(<span class="params">K key, <span class="keyword">int</span> hash, V <span class="keyword">value</span>, boolean onlyIfAbsent</span>) </span>&#123;</div><div class="line">            HashEntry&lt;K,V&gt; node = tryLock() ? <span class="literal">null</span> :</div><div class="line">                scanAndLockForPut(key, hash, <span class="keyword">value</span>);</div><div class="line">            V oldValue;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                HashEntry&lt;K,V&gt;[] tab = table;</div><div class="line">                <span class="keyword">int</span> index = (tab.length - <span class="number">1</span>) &amp; hash;</div><div class="line">                <span class="comment">//取出头节点</span></div><div class="line">                HashEntry&lt;K,V&gt; first = entryAt(tab, index);</div><div class="line">                <span class="comment">//遍历链表</span></div><div class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;</div><div class="line">                    <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</div><div class="line">                        K k;</div><div class="line">                        <span class="comment">//key已存在，替换value</span></div><div class="line">                        <span class="keyword">if</span> ((k = e.key) == key ||</div><div class="line">                            (e.hash == hash &amp;&amp; key.<span class="keyword">equals</span>(k))) &#123;</div><div class="line">                            oldValue = e.<span class="keyword">value</span>;</div><div class="line">                            <span class="keyword">if</span> (!onlyIfAbsent) &#123;</div><div class="line">                                e.<span class="keyword">value</span> = <span class="keyword">value</span>;</div><div class="line">                                ++modCount;</div><div class="line">                            &#125;</div><div class="line">                            <span class="keyword">break</span>;</div><div class="line">                        &#125;</div><div class="line">                        e = e.next;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">else</span> &#123;</div><div class="line">                        <span class="comment">//scanAndLockForPut()方法中已经返回了node，设置为first节点</span></div><div class="line">                        <span class="keyword">if</span> (node != <span class="literal">null</span>)</div><div class="line">                            node.setNext(first);</div><div class="line">                        <span class="keyword">else</span></div><div class="line">                            <span class="comment">//新建HashEntry节点作为头节点first</span></div><div class="line">                            node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, <span class="keyword">value</span>, first);</div><div class="line">                        <span class="keyword">int</span> c = count + <span class="number">1</span>;</div><div class="line">                        <span class="comment">//判断是否扩容</span></div><div class="line">                        <span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</div><div class="line">                            rehash(node);</div><div class="line">                        <span class="keyword">else</span></div><div class="line">                            setEntryAt(tab, index, node);</div><div class="line">                        ++modCount; <span class="comment">//记录修改次数</span></div><div class="line">                        count = c;  <span class="comment">//修改count值</span></div><div class="line">                        oldValue = <span class="literal">null</span>;</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                unlock();</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> oldValue;</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p>
<p>过程分析：  </p>
<ol>
<li>首先调用tryLock()方法尝试获取锁，如果获取失败，则进入scanAndLockForPut()方法，该方法实际上是先自旋一定的次数等待其他线程释放锁。若自旋过程中，其他线程释放了锁，导致本线程直接获得了锁，就避免了本线程进入等待锁的场景，提高了效率。若自旋一定次数后，仍未获取锁，则调用lock方法进入等待锁的场景。（这是JDK1.7的实现，如果是1.6则没有自旋，直接获取锁）</li>
<li>获取锁成功，找到对应的链表作相应的操作。具体见代码注释。</li>
</ol>
<h4 id="get-方法"><a href="#get-方法" class="headerlink" title="get()方法"></a>get()方法</h4><p>get()方法不需要锁。<strong>因为value字段是volatile修饰，保证了线程之间的可见性，可以被多线程同时读，但只能被单线程写。一句话，get操作只需要读共享变量value，所以不用加锁。</strong></p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> V <span class="built_in">get</span>(<span class="keyword">Object</span> <span class="built_in">key</span>) &#123;</div><div class="line">        Segment&lt;K,V&gt; s; <span class="comment">// manually integrate access methods to reduce overhead</span></div><div class="line">        HashEntry&lt;K,V&gt;[] tab;</div><div class="line">        <span class="built_in">int</span> h = hash(<span class="built_in">key</span>); <span class="comment">//第一次散列</span></div><div class="line">        <span class="comment">//第二次散列</span></div><div class="line">        <span class="keyword">long</span> u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</div><div class="line">        <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != <span class="keyword">null</span> &amp;&amp;</div><div class="line">            (tab = s.table) != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">//第三次散列（for循环中）</span></div><div class="line">            <span class="comment">//遍历链表</span></div><div class="line">            <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile</div><div class="line">                     (tab, ((<span class="keyword">long</span>)(((tab.length - <span class="number">1</span>) &amp; h)) &lt;&lt; TSHIFT) + TBASE);</div><div class="line">                 e != <span class="keyword">null</span>; e = e.next) &#123;</div><div class="line">                K k;</div><div class="line">                <span class="keyword">if</span> ((k = e.<span class="built_in">key</span>) == <span class="built_in">key</span> || (e.hash == h &amp;&amp; <span class="built_in">key</span>.equals(k)))</div><div class="line">                    <span class="keyword">return</span> e.value;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>（get()方法中用到了许多UNSAFE类的方法，这是在JDK1.6中没有的，主要是利用Native方法来快速的定位元素。）  </p>
<p>get()的过程经过了三次散列：  </p>
<p><strong>第一次：对key进行散列得到h<br>第二次：对h进行散列定位到哪个Segment<br>第三次：对h进行散列定位到哪个HashEntry</strong> </p>
<p>定位到HashEntry之后就对该链表遍历，查找key对应的value，若没有找到则返回null。  </p>
<h4 id="size-方法"><a href="#size-方法" class="headerlink" title="size()方法"></a>size()方法</h4><p><strong>size()方法需要跨Segment操作，因为要统计每个Segment中的count值。而count值是volatile变量，一般来说将所有的count变量相加就可以得到整个ConcurrentHashMap的大小。</strong> 但可能在累加前使用的count发生了变化，那么结果就不正确。那么该如何统计呢？</p>
<ol>
<li>第一种方法，将所有Segment的put、remove、clean方法都锁住，然后统计count值。做法可行，但是低效。</li>
<li><strong>第二种方法，先尝试连续2次不通过锁住Segment的方式计算各个count值的和：</strong></li>
</ol>
<ul>
<li>若没有发生变化，则作为size的大小。</li>
<li>若发生变化说明有线程在操作元素，则锁住Segment统计所有的count值。</li>
</ul>
<p><strong>如何判断容器大小没有发生变化？</strong>   </p>
<p><strong>modCount变量。这个变量记录了每个Segment中put、remove、clean等操作的次数，因此在连续两次统计count的值时，比较modCount是否变化，就可得知容器大小是否变化。</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、ConcurrentHashMap的介绍&quot;&gt;&lt;a href=&quot;#一、ConcurrentHashMap的介绍&quot; class=&quot;headerlink&quot; title=&quot;一、ConcurrentHashMap的介绍&quot;&gt;&lt;/a&gt;一、ConcurrentHashMap的
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="ConcurrentHashMap" scheme="http://yoursite.com/tags/ConcurrentHashMap/"/>
    
      <category term="JDK1.7" scheme="http://yoursite.com/tags/JDK1-7/"/>
    
  </entry>
  
  <entry>
    <title>HashMap引发的线程安全问题</title>
    <link href="http://yoursite.com/2017/11/03/HashMap%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2017/11/03/HashMap引发的线程安全问题/</id>
    <published>2017-11-03T09:48:18.000Z</published>
    <updated>2018-02-24T17:48:06.945Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、线程安全性"><a href="#一、线程安全性" class="headerlink" title="一、线程安全性"></a>一、线程安全性</h3><p>我们知道，HashMap是非线程安全的，只能在单线程的情况下使用。那么为什么不能在并发的情况下使用呢？<strong>因为在并发时，HashMap的扩容会产生错误而形成环形链表，导致读取数据时发生死循环</strong>。</p>
<p>回忆前面描述的扩容过程，调用了transfer()方法将旧链表转化为新链表：</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">void transfer(Entry[] <span class="keyword">new</span><span class="type">Table</span>) &#123;  </div><div class="line">    Entry[] src = table;  </div><div class="line">    int <span class="keyword">new</span><span class="type">Capacity</span> = <span class="keyword">new</span><span class="type">Table</span>.length;  </div><div class="line">    <span class="keyword">for</span> (int j = <span class="number">0</span>; j &lt; src.length; j++) &#123;  </div><div class="line">        Entry&lt;K,V&gt; e = src[j];  </div><div class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;  </div><div class="line">            src[j] = <span class="literal">null</span>;  </div><div class="line">            <span class="keyword">do</span> &#123;  </div><div class="line">                Entry&lt;K,V&gt; next = e.next;  </div><div class="line">                int i = indexFor(e.hash, <span class="keyword">new</span><span class="type">Capacity</span>);  </div><div class="line">                e.next = <span class="keyword">new</span><span class="type">Table</span>[i];  </div><div class="line">                <span class="keyword">new</span><span class="type">Table</span>[i] = e;  </div><div class="line">                e = next;  </div><div class="line">            &#125; <span class="keyword">while</span> (e != <span class="literal">null</span>);  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>关键代码如下：</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">do</span> &#123;  </div><div class="line">Entry&lt;K,V&gt; next = e.next;  </div><div class="line">int i = indexFor(e.hash, <span class="keyword">new</span><span class="type">Capacity</span>);  </div><div class="line">e.next = <span class="keyword">new</span><span class="type">Table</span>[i];  </div><div class="line"><span class="keyword">new</span><span class="type">Table</span>[i] = e;  </div><div class="line">e = next;  </div><div class="line">&#125; <span class="keyword">while</span> (e != <span class="literal">null</span>);</div></pre></td></tr></table></figure>
<p>循环操作将旧链表中的节点放入新链表，直到下一个节点next为null。<br>分别在单线程和多线程的环境下描述扩容过程。</p>
<h4 id="单线程扩容"><a href="#单线程扩容" class="headerlink" title="单线程扩容"></a>单线程扩容</h4><p>假设hash数组的大小为2，负载因子为1，即超过1×2=2个元素时扩容，添加3个元素5、7、3，数组大小扩大为4，扩容过程如下：</p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/h1.png?imageView2/2/w/900/h/450" alt="image"></p>
<p>原链表中3个元素，循环3次，具体如下：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">第一次循环</div><div class="line"><span class="attr">e</span> = <span class="number">3</span>,<span class="attr">next</span> = <span class="number">7</span></div><div class="line"><span class="number">3</span>.<span class="attr">next</span> = tab[i] = <span class="literal">null</span>  (此时数组tab[i]为空)</div><div class="line">tab[i] = <span class="number">3</span></div><div class="line"><span class="attr">e</span> = <span class="number">7</span> </div><div class="line"></div><div class="line">第二次循环</div><div class="line"><span class="attr">e</span> = <span class="number">7</span>,<span class="attr">next</span> = <span class="number">5</span></div><div class="line"><span class="number">7</span>.<span class="attr">next</span> = tab[i] = <span class="number">3</span></div><div class="line">tab[i] = <span class="number">7</span></div><div class="line"><span class="attr">e</span> = <span class="number">5</span></div><div class="line"></div><div class="line">第三次循环</div><div class="line"><span class="attr">e</span> = <span class="number">5</span>,<span class="attr">next</span> = <span class="literal">null</span></div><div class="line"><span class="number">5</span>.<span class="attr">next</span> = tab[i2] = <span class="literal">null</span>  (此时数组tab[i2]为空)</div><div class="line">tab[i2] = <span class="number">5</span></div><div class="line"><span class="attr">e</span> = <span class="literal">null</span> </div><div class="line"></div><div class="line">(停止循环)</div></pre></td></tr></table></figure></p>
<h4 id="多线程扩容"><a href="#多线程扩容" class="headerlink" title="多线程扩容"></a>多线程扩容</h4><p>为什么多线程环境下扩容会形成环形链表呢？<br>还是刚刚的例子，两个线程并发执行，线程1在进入do循环的第一行挂起，线程2继续执行</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">do</span> &#123;  </div><div class="line">    Entry&lt;K,V&gt; next = e.next;  <span class="comment">//线程1在此处挂起</span></div><div class="line">    int i = indexFor(e.hash, <span class="keyword">new</span><span class="type">Capacity</span>);  </div><div class="line">    e.next = <span class="keyword">new</span><span class="type">Table</span>[i];  </div><div class="line">    <span class="keyword">new</span><span class="type">Table</span>[i] = e;  </div><div class="line">    e = next;  </div><div class="line">    &#125; <span class="keyword">while</span> (e != <span class="literal">null</span>);</div></pre></td></tr></table></figure>
<p>由前面单线程的情况可知，线程2此时成功扩容，结果如下：</p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/h2.png" alt="image"></p>
<p>线程1恢复执行，已知线程1的 e 指向了key(3)，而next指向了key(7)，扩容过程如下：</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">第一次循环</div><div class="line">e = <span class="number">3</span>,next = <span class="number">7</span></div><div class="line"><span class="number">3.</span>next = tab[i] = null  (此时数组tab[i]为空)</div><div class="line">tab[i] = <span class="number">3</span></div><div class="line">e = <span class="number">7</span> </div><div class="line"></div><div class="line">第二次循环</div><div class="line">e = <span class="number">7</span>,next = <span class="number">3</span></div><div class="line"><span class="number">7.</span>next = tab[i] = <span class="number">3</span></div><div class="line">tab[i] = <span class="number">7</span></div><div class="line">e = <span class="number">3</span></div><div class="line"></div><div class="line">第三次循环</div><div class="line">e = <span class="number">3</span>,next = null</div><div class="line"><span class="number">3.</span>next = tab[i] = <span class="number">7</span></div><div class="line">tab[i] = <span class="number">3</span></div><div class="line">e = null</div><div class="line"></div><div class="line">(停止循环)</div></pre></td></tr></table></figure>
<p>第一次循环图：  </p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/h3.png" alt="image">  </p>
<p>第二次循环图：</p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/h22.png" alt="image"></p>
<p>第三次循环图：</p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/h4.png" alt="image"></p>
<p>在停止循环后，问题就出现了，如图所示，key(3)和key(7)构成了环形链表。<br><strong>于是，当我们调用HashMap的get方法时，由于查找链表节点时无法退出，就会产生无限循环。</strong></p>
<h3 id="二、解决方法"><a href="#二、解决方法" class="headerlink" title="二、解决方法"></a>二、解决方法</h3><p>解决方法就是采用同步的数据结构，主要有以下三种：</p>
<ol>
<li><strong>Hashtable</strong></li>
<li><strong>Collections.synchronizedMap()</strong></li>
<li><strong>ConcurrentHashMap</strong></li>
</ol>
<h4 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h4><p>Hashtable是线程安全的。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public synchronized V put(K key, V value) <span class="meta">&#123;...&#125;</span></div><div class="line"></div><div class="line">public synchronized V get(<span class="type">Object</span> key) <span class="meta">&#123;...&#125;</span></div></pre></td></tr></table></figure>
<p>可以看到，<strong>Hashtable是通过在方法上加上synchronized关键字来实现同步功能的</strong>。当一个线程访问时，其他线程都被阻塞住，这种方式效率很低，目前几乎不被使用。</p>
<h4 id="Collections-synchronizedMap"><a href="#Collections-synchronizedMap" class="headerlink" title="Collections.synchronizedMap()"></a>Collections.synchronizedMap()</h4><p>调用Collections的synchronizedMap()方法，传入一个Map，可以得到一个线程安全的SynchronizedMap。</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> class SynchronizedMap&lt;K,V&gt;</div><div class="line">        implements Map&lt;K,V&gt;, Serializable &#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K,V&gt; m;     </div><div class="line">        <span class="keyword">final</span> <span class="keyword">Object</span>      mutex;        <span class="comment">// Object on which to synchronize</span></div><div class="line"></div><div class="line">        SynchronizedMap(Map&lt;K,V&gt; m) &#123;</div><div class="line">            <span class="keyword">this</span>.m = Objects.requireNonNull(m);</div><div class="line">            mutex = <span class="keyword">this</span>;</div><div class="line">        &#125;</div><div class="line">        ....</div><div class="line">        <span class="keyword">public</span> V <span class="built_in">get</span>(<span class="keyword">Object</span> <span class="built_in">key</span>) &#123;</div><div class="line">            <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> m.<span class="built_in">get</span>(<span class="built_in">key</span>);&#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">public</span> V put(K <span class="built_in">key</span>, V value) &#123;</div><div class="line">            <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> m.put(<span class="built_in">key</span>, value);&#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>可以看到，<strong>它同步的原理同样也是使用了Synchronized关键字，不同的是Synchronized修饰代码块，并且将自身（this）作为了锁对象（mutex）。</strong></p>
<h4 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><p>ConcurrentHashMap是JDK1.5之后引入的，是为了替代上面提到的二者。<br>ConcurrentHashMap是线程安全且高效的HashMap，它使用了多个锁来控制对hash数组不同部分的修改。  </p>
<p>关于它的实现原理可以查看<a href="https://youngforzy.github.io/2017/11/10/ConcurrentHashMap在JDK1.8中的实现分析/" target="_blank" rel="external">ConcurrentHashMap</a>这篇文章中的分析。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、线程安全性&quot;&gt;&lt;a href=&quot;#一、线程安全性&quot; class=&quot;headerlink&quot; title=&quot;一、线程安全性&quot;&gt;&lt;/a&gt;一、线程安全性&lt;/h3&gt;&lt;p&gt;我们知道，HashMap是非线程安全的，只能在单线程的情况下使用。那么为什么不能在并发的情况下使用呢
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="HashMap" scheme="http://yoursite.com/tags/HashMap/"/>
    
      <category term="线程安全" scheme="http://yoursite.com/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>HashMap 在JDK1.8中的实现（与JDK1.7对比）</title>
    <link href="http://yoursite.com/2017/11/01/HashMap%20%E5%9C%A8JDK1.8%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%B8%8EJDK1.7%E5%AF%B9%E6%AF%94%EF%BC%89/"/>
    <id>http://yoursite.com/2017/11/01/HashMap 在JDK1.8中的实现（与JDK1.7对比）/</id>
    <published>2017-11-01T09:48:18.000Z</published>
    <updated>2018-02-24T17:30:16.587Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HashMap的实现分析"><a href="#HashMap的实现分析" class="headerlink" title="HashMap的实现分析"></a>HashMap的实现分析</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>通过前面JDK1.7的分析，我们知道，当负载因子和Hash算法设计的很好时，可以降低hash碰撞的概率，但在数据量过大时也避免不了会出现链表变长的情况，一旦出现链表过长，查找元素变慢，则会严重影响HashMap的性能。<br>于是，在JDK1.8中，对数据结构做了进一步的优化，引入了红黑树。<strong>而当链表长度太长（默认超过8）时，链表就转换为红黑树</strong>，利用红黑树快速增删改查的特点提高HashMap的性能，其中会用到红黑树的插入、删除、查找等算法。</p>
<h4 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h4><p>HashMap的底层实现是<strong>数组+链表+红黑树</strong>。</p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/1.8hash.PNG" alt="image"></p>
<h4 id="数组索引位置"><a href="#数组索引位置" class="headerlink" title="数组索引位置"></a>数组索引位置</h4><figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//第一步</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> hash(<span class="keyword">Object</span> <span class="built_in">key</span>) &#123;</div><div class="line">        <span class="built_in">int</span> h;</div><div class="line">        <span class="keyword">return</span> (<span class="built_in">key</span> == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = <span class="built_in">key</span>.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="comment">//第二步，代码中：    </span></div><div class="line">    tab[i = (n - <span class="number">1</span>) &amp; hash]</div></pre></td></tr></table></figure>
<p>确定数组索引的位置同样是两步法：<br>第一步计算hash，与JDK1.7中的计算方法不同；<br>计算过程如下：  </p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/hash.png" alt="image">  </p>
<p>第二步确定索引，与JDK1.7中的相同，只是不作为一个独立的方法；</p>
<h4 id="put-、get-方法"><a href="#put-、get-方法" class="headerlink" title="put()、get()方法"></a>put()、get()方法</h4><p><strong>put()方法</strong><br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span>(<span class="params">K key, V <span class="keyword">value</span></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> putVal(hash(key), key, <span class="keyword">value</span>, <span class="literal">false</span>, <span class="literal">true</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>调用了putVal()方法：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> V putVal(<span class="built_in">int</span> hash, K <span class="built_in">key</span>, V value, <span class="built_in">boolean</span> onlyIfAbsent,</div><div class="line">                   <span class="built_in">boolean</span> evict) &#123;</div><div class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="built_in">int</span> n, i;</div><div class="line">        <span class="comment">//如果tab为空或长度为0，则分配内存resize()</span></div><div class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</div><div class="line">            n = (tab = resize()).length;</div><div class="line">        <span class="comment">//数组索引位置为null，直接put</span></div><div class="line">        <span class="comment">//同时这一步p赋值为tab[i]</span></div><div class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</div><div class="line">            tab[i] = newNode(hash, <span class="built_in">key</span>, value, <span class="keyword">null</span>);</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            Node&lt;K,V&gt; e; K k;</div><div class="line">            <span class="comment">//判断hash值和key是否都相同，都相同则后面替换value值</span></div><div class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</div><div class="line">                ((k = p.<span class="built_in">key</span>) == <span class="built_in">key</span> || (<span class="built_in">key</span> != <span class="keyword">null</span> &amp;&amp; <span class="built_in">key</span>.equals(k))))</div><div class="line">                e = p;</div><div class="line">            <span class="comment">//红黑书处理冲突    </span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</div><div class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, <span class="built_in">key</span>, value);</div><div class="line">            <span class="comment">//链表处理冲突</span></div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">for</span> (<span class="built_in">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</div><div class="line">                    <span class="comment">// 在链表尾部插入新结点</span></div><div class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</div><div class="line">                        p.next = newNode(hash, <span class="built_in">key</span>, value, <span class="keyword">null</span>);</div><div class="line">                        <span class="comment">//节点数 &gt;= 7，转化为红黑树</span></div><div class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) </div><div class="line">                            treeifyBin(tab, hash);</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">//已经存在key，退出循环，后面替换value值</span></div><div class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                        ((k = e.<span class="built_in">key</span>) == <span class="built_in">key</span> || (<span class="built_in">key</span> != <span class="keyword">null</span> &amp;&amp; <span class="built_in">key</span>.equals(k))))</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    <span class="comment">//与e = p.next组合，遍历链表</span></div><div class="line">                    p = e;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//已经存在key，替换value值</span></div><div class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></div><div class="line">                V oldValue = e.value;</div><div class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</div><div class="line">                    e.value = value;</div><div class="line">                afterNodeAccess(e);</div><div class="line">                <span class="keyword">return</span> oldValue;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        ++modCount;</div><div class="line">        <span class="comment">//扩容</span></div><div class="line">        <span class="keyword">if</span> (++<span class="built_in">size</span> &gt; threshold)</div><div class="line">            resize();</div><div class="line">        afterNodeInsertion(evict);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>put过程分析：</p>
<ol>
<li>如果数组索引位置tab[i]为null，直接put；否则进入2；</li>
<li>与第一个节点hash值相同且key值也相同，则直接到后面替换value值，否则进入3；</li>
<li>判断链表是否形成红黑树，并根据结果进入不同的处理。</li>
</ol>
<hr>
<p><strong>get()方法</strong></p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> V <span class="built_in">get</span>(<span class="keyword">Object</span> <span class="built_in">key</span>) &#123;</div><div class="line">        Node&lt;K,V&gt; e;</div><div class="line">        <span class="keyword">return</span> (e = getNode(hash(<span class="built_in">key</span>), <span class="built_in">key</span>)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>调用getNode()方法：<br><figure class="highlight gauss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">final Node&lt;K,V&gt; getNode(int hash, Object <span class="built_in">key</span>) &#123;</div><div class="line">        Node&lt;K,V&gt;[] <span class="built_in">tab</span>; Node&lt;K,V&gt; first, e; int n; K k;</div><div class="line">        <span class="keyword">if</span> ((<span class="built_in">tab</span> = table) != <span class="built_in">null</span> &amp;&amp; (n = <span class="built_in">tab</span>.length) &gt; <span class="number">0</span> &amp;&amp;</div><div class="line">            (first = <span class="built_in">tab</span>[(n - <span class="number">1</span>) &amp; hash]) != <span class="built_in">null</span>) &#123;</div><div class="line">            <span class="comment">//判断目标是不是first，是直接返回first</span></div><div class="line">            <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></div><div class="line">                ((k = first.<span class="built_in">key</span>) == <span class="built_in">key</span> || (<span class="built_in">key</span> != <span class="built_in">null</span> &amp;&amp; <span class="built_in">key</span>.equals(k))))</div><div class="line">                <span class="keyword">return</span> first;</div><div class="line">            <span class="comment">//已经形成链表</span></div><div class="line">            <span class="keyword">if</span> ((e = first.next) != <span class="built_in">null</span>) &#123;</div><div class="line">                <span class="comment">//第一个节点是TreeNode，说明形成了红黑树</span></div><div class="line">                <span class="keyword">if</span> (first instanceof TreeNode)</div><div class="line">                    <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, <span class="built_in">key</span>);</div><div class="line">                <span class="comment">// 还未形成红黑树，按链表处理   </span></div><div class="line">                <span class="keyword">do</span> &#123;</div><div class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                        ((k = e.<span class="built_in">key</span>) == <span class="built_in">key</span> || (<span class="built_in">key</span> != <span class="built_in">null</span> &amp;&amp; <span class="built_in">key</span>.equals(k))))</div><div class="line">                        <span class="keyword">return</span> e;</div><div class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="built_in">null</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">null</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>方法分析：</p>
<ol>
<li>首先判断第一个节点first是不是要寻找的节点，如果是直接返回；不是进入2；</li>
<li>判断第一个节点first是不是树节点，如果是说明形成红黑树，调用红黑树的查找方法；不是则进入3；</li>
<li>说明还是链表，未形成红黑树，调用链表查找方法。</li>
</ol>
<h4 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h4><p>我们知道，当往HashMap中不断地添加元素时，它就会扩大数组的长度，把小的数组用大的数组来代替。<br><strong>回忆JDK1.7中的扩容，对于链表中的每个元素都需要重新计算hash值，而在JDK1.8中，只需要看看原来的hash值新增的那个bit是1还是0就好了</strong>，是0的话索引没变，是1的话索引变成“原索引+oldCap（原容量）”，工作过程如下图：</p>
<p>数组由16扩大到32的过程中，索引位置为15的元素变化：<br><img src="http://osuskkx7k.bkt.clouddn.com/1.8hahs%E6%89%A9%E5%AE%B9.png" alt="image"></p>
<p><strong>注：JDK1.7中旧链表的元素如果刚好又在新链表中，那么元素的顺序是倒置的，而JDK1.8不会倒置。</strong></p>
<h4 id="JDK1-8和JDK1-7的区别（HashMap）"><a href="#JDK1-8和JDK1-7的区别（HashMap）" class="headerlink" title="JDK1.8和JDK1.7的区别（HashMap）"></a>JDK1.8和JDK1.7的区别（HashMap）</h4><p><strong>相同点</strong></p>
<ol>
<li><strong>默认初始容量都是16，默认负载因子都是0.75。数组的长度length都是2的次幂，扩容时都是2倍</strong></li>
<li><strong>通过hash计算索引的方法相同（hash &amp; length-1）</strong></li>
<li><strong>key为null的键值对都会放入table[0]中</strong></li>
<li><strong>都是懒加载，初始时表为空，在插入第一个键值对时初始</strong>化</li>
</ol>
<p><strong>不同点</strong></p>
<ol>
<li><strong>结构不同，JDK1.8增加了红黑树优化结构</strong></li>
<li><strong>put方法的区别，JDK1.7中put时，添加到头节点；JDK1.8中添加到尾节点</strong></li>
<li><strong>计算hash的方法不同，JDK1.8更优化</strong></li>
<li><strong>JDK1.7新链表的顺序倒置，JDK1.8新链表顺序不倒置</strong></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;HashMap的实现分析&quot;&gt;&lt;a href=&quot;#HashMap的实现分析&quot; class=&quot;headerlink&quot; title=&quot;HashMap的实现分析&quot;&gt;&lt;/a&gt;HashMap的实现分析&lt;/h3&gt;&lt;h4 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="HashMap" scheme="http://yoursite.com/tags/HashMap/"/>
    
      <category term="JDK1.8" scheme="http://yoursite.com/tags/JDK1-8/"/>
    
  </entry>
  
  <entry>
    <title>HashMap 在JDK1.7中的实现原理分析</title>
    <link href="http://yoursite.com/2017/10/30/HashMap%20%E5%9C%A8JDK1.7%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2017/10/30/HashMap 在JDK1.7中的实现原理分析/</id>
    <published>2017-10-30T10:48:18.000Z</published>
    <updated>2018-02-24T17:26:41.879Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、HashMap的介绍"><a href="#一、HashMap的介绍" class="headerlink" title="一、HashMap的介绍"></a>一、HashMap的介绍</h3><p>HashMap是存储键值对（key，value）的一种数据结构。<br>每一个元素都是一个key-value。<br>HashMap最多只允许一个key为null，允许多个key的value值为null。<br>HashMap是非线程安全的，只适用于单线程环境。<br>HashMap实现了Serializable、Cloneable接口，因此它支持序列化和克隆。</p>
<h3 id="二、HashMap的实现原理"><a href="#二、HashMap的实现原理" class="headerlink" title="二、HashMap的实现原理"></a>二、HashMap的实现原理</h3><p>从<strong>底层结构、put和get方法、hash数组索引、扩容机制</strong>等几个方面来分析HashMap的实现原理：</p>
<h4 id="1-底层结构"><a href="#1-底层结构" class="headerlink" title="1.底层结构"></a>1.底层结构</h4><p>HashMap的底层结构是由<strong>数组+链表</strong>构成的。  </p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/hash2.PNG" alt="image"></p>
<p>数组（紫色）：hash数组（桶），数组元素是每个链表的头节点<br>链表（绿色）：解决hash冲突，不同的key映射到了数组的同一索引处，则形成链表。</p>
<p><strong>构成链表的节点类Node：</strong> （jdk 1.7 中的源码）<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</div><div class="line">        <span class="keyword">final</span> K key;</div><div class="line">        V value;</div><div class="line">        Entry&lt;K,V&gt; next;</div><div class="line">        <span class="keyword">int</span> hash;</div><div class="line">        ....</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到，key和value都储存于节点之中，next表示下一个节点。</p>
<h4 id="2-put、get方法"><a href="#2-put、get方法" class="headerlink" title="2.put、get方法"></a>2.put、get方法</h4><p><strong>put()方法：</strong></p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span>(<span class="params">K key, V <span class="keyword">value</span></span>) </span>&#123;  </div><div class="line">    <span class="comment">// 若key为null，则将该键值对添加到table[0]中。  </span></div><div class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span>)  </div><div class="line">        <span class="keyword">return</span> putForNullKey(<span class="keyword">value</span>);  </div><div class="line">    <span class="comment">// 若key不为null，则计算该key的hash值，然后将其添加到该哈希值对应的数组索引处的链表中。</span></div><div class="line">    <span class="keyword">int</span> hash = hash(key.hashCode());  </div><div class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);  </div><div class="line">    <span class="comment">//遍历该数组索引位置处的链表</span></div><div class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="literal">null</span>; e = e.next) &#123;  </div><div class="line">        Object k;  </div><div class="line">        <span class="comment">// 若该key对应的键值对已经存在，则用新的value替换旧的value，退出  </span></div><div class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.<span class="keyword">equals</span>(k))) &#123;  </div><div class="line">            V oldValue = e.<span class="keyword">value</span>;  </div><div class="line">            e.<span class="keyword">value</span> = <span class="keyword">value</span>;  </div><div class="line">            e.recordAccess(<span class="keyword">this</span>);  </div><div class="line">            <span class="keyword">return</span> oldValue;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    modCount++;</div><div class="line">    <span class="comment">// 若数组索引位置处table[i]没有链表，即没有元素</span></div><div class="line">    <span class="comment">// 则将key-value添加到数组索引table[i]处，成为头节点</span></div><div class="line">    addEntry(hash, key, <span class="keyword">value</span>, i);  </div><div class="line">    <span class="keyword">return</span> <span class="literal">null</span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>put()方法大概过程如下：</p>
<ol>
<li><strong>如果添加的key值为null，那么将该键值对添加到数组索引为0的链表中，不一定是链表的首节点。</strong></li>
<li><strong>如果添加的key不为null，则根据key计算数组索引的位置</strong>：  </li>
</ol>
<ul>
<li><strong>数组索引处存在链表</strong>，则遍历该链表，如果发现key已经存在，那么将新的value值替换旧的value值</li>
<li><strong>数组索引处不存在链表</strong>，将该key-value添加到此处，成为头节点</li>
</ul>
<p><strong>addEntry()方法如下：</strong></p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span>(<span class="params"><span class="keyword">int</span> hash, K key, V <span class="keyword">value</span>, <span class="keyword">int</span> bucketIndex</span>) </span>&#123;  </div><div class="line">    <span class="comment">// bucketIndex是数组位置索引，保存“bucketIndex”位置的值到“e”中  </span></div><div class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];  </div><div class="line">    <span class="comment">// 设置“bucketIndex”位置的元素为“新Entry”，设置“e”为“新Entry的下一个节点”  </span></div><div class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;K,V&gt;(hash, key, <span class="keyword">value</span>, e);  </div><div class="line">    <span class="comment">// size超过阈值，则调整HashMap的大小  </span></div><div class="line">    <span class="keyword">if</span> (size++ &gt;= threshold)  </div><div class="line">        resize(<span class="number">2</span> * table.length);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>将新的节点（假设为节点n）添加到数组索引位置处，将原来的节点e作为n的next节点，即下一个节点。</strong></p>
<p>由此可知：<strong>每一次添加的新节点总是作为头节点。</strong></p>
<hr>
<p><strong>get()方法：</strong></p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> V <span class="built_in">get</span>(<span class="keyword">Object</span> <span class="built_in">key</span>) &#123;  </div><div class="line">    <span class="keyword">if</span> (<span class="built_in">key</span> == <span class="keyword">null</span>)  </div><div class="line">        <span class="keyword">return</span> getForNullKey();  </div><div class="line">    <span class="comment">// 获取key的hash值  </span></div><div class="line">    <span class="built_in">int</span> hash = hash(<span class="built_in">key</span>.hashCode());  </div><div class="line">    <span class="comment">// 在“该hash值对应的链表”上查找“键值等于key”的元素  </span></div><div class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];  </div><div class="line">         e != <span class="keyword">null</span>;  </div><div class="line">         e = e.next) &#123;  </div><div class="line">        <span class="keyword">Object</span> k;  </div><div class="line">        <span class="comment">//判断key是否相同</span></div><div class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.<span class="built_in">key</span>) == <span class="built_in">key</span> || <span class="built_in">key</span>.equals(k)))  </div><div class="line">            <span class="keyword">return</span> e.value;  </div><div class="line">    &#125;</div><div class="line">    <span class="comment">//没找到则返回null</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;  </div><div class="line">&#125;  </div><div class="line"> </div><div class="line"><span class="comment">// 获取“key为null”的元素的值  </span></div><div class="line"><span class="comment">// HashMap将“key为null”的元素存储在table[0]位置，但不一定是该链表的第一个位置！  </span></div><div class="line"><span class="keyword">private</span> V getForNullKey() &#123;  </div><div class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="keyword">null</span>; e = e.next) &#123;  </div><div class="line">        <span class="keyword">if</span> (e.<span class="built_in">key</span> == <span class="keyword">null</span>)  </div><div class="line">            <span class="keyword">return</span> e.value;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>get()方法的大概过程：</p>
<ol>
<li>如果key为null，那么在数组索引table[0]处的链表中遍历查找key为null的value</li>
<li>如果key不为null，根据key找到数组索引位置处的链表，遍历查找key的value，找到返回value，若没找到则返回null</li>
</ol>
<h4 id="3-hash数组索引位置"><a href="#3-hash数组索引位置" class="headerlink" title="3.hash数组索引位置"></a>3.hash数组索引位置</h4><p>前面多次提到了数组索引位置，那么这个位置该如何确定呢？<br>两步：</p>
<ol>
<li>确定key的hash值</li>
<li>根据hash计算索引</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</div><div class="line">        h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</div><div class="line">        <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> h &amp; (length<span class="number">-1</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>第一步：采用位操作计算hash值，这么做的<strong>目的是为了下一步的索引值分布均匀，减少碰撞，提高效率。</strong><br>第二步：根据hash值计算索引的值，把hash值和数组长度-1做一个”与”操作，保留的值作为索引。</p>
<p><strong>为什么是length-1？</strong><br><strong>这也是HashMap的数组长度要取2的整次幂的原因之一。  因为length为2的整数次幂时，（length-1）正好相当于一个“低位掩码”**</strong>。“与”操作的结果就可以保留低位作为数组索引。**<br>例如：length = 16和某个hash值进行 &amp; 操作</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">某个hash           <span class="number">10110110</span> <span class="number">11100010</span> <span class="number">01000101</span></div><div class="line">length<span class="number">-1</span>=<span class="number">15</span>    &amp;   <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00001111</span></div><div class="line">           ---------------------------------</div><div class="line">                   <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000101</span>   <span class="comment">//只保留末四位，索引值=5</span></div></pre></td></tr></table></figure>
<p><strong>另一个原因</strong>：HashMap的数组长度length为2的整次幂时，length-1为奇数（偶数-1），此时进行 &amp; 操作时可保证最后一位可能是 0 或 1 ，保证了数组索引的均匀性；而如果length-1为偶数，那么 &amp; 操作时最后一位只能是 0，也就是数组索引只能是偶数索引位置，这样就浪费了一半的空间，所以length为2的整次幂。<br><strong>综上，数组长度取2的整次幂，是为了减少hash碰撞的概率，使元素散列更加均匀。</strong></p>
<h4 id="4-扩容机制"><a href="#4-扩容机制" class="headerlink" title="4.扩容机制"></a>4.扩容机制</h4><p>先看一个例子，创建一个HashMap，初始容量默认为16，负载因子默认为0.75，那么什么时候它会扩容呢？<br>来看以下公式：<br><figure class="highlight fix"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attr">实际容量 </span>=<span class="string"> 初始容量 × 负载因子</span></div></pre></td></tr></table></figure></p>
<p>计算可知，16×0.75=12，也就是当实际容量超过12时，这个HashMap就会扩容。</p>
<p><strong>初始容量</strong>  </p>
<p>当构造一个hashmap时，初始容量设为不小于指定容量的2的次方的一个数（new HashMap(5)， 指定容量为5，那么实际初始容量为8，2^3=8&gt;5），且最大值不能超过2的30次方。  </p>
<p><strong>负载因子</strong>  </p>
<p><strong>负载因子是哈希数组在其容量自动增加之前可以达到多满的一种尺度。（时间与空间的折衷）</strong> 当哈希数组中的条目数超出了加载因子与初始容量的乘积时，则要对该哈希数组进行扩容操作（即resize）。<br><strong>特点：</strong></p>
<ul>
<li><strong>负载因子越小，容易扩容，浪费空间，但查找效率高</strong></li>
<li><strong>负载因子越大，不易扩容，对空间的利用更加充分，查找效率低（链表拉长）</strong></li>
</ul>
<p><strong>扩容过程</strong>  </p>
<p> HashMap在扩容时，<strong>新数组的容量将是原来的2倍</strong>，由于容量发生变化，原有的每个元素需要重新计算数组索引Index，再存放到新数组中去，这就是所谓的rehash。</p>
<p>扩容代码：<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">void resize(int <span class="keyword">new</span><span class="type">Capacity</span>) &#123;  </div><div class="line">    Entry[] oldTable = table;  </div><div class="line">    int oldCapacity = oldTable.length;  </div><div class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;  </div><div class="line">        threshold = Integer.MAX_VALUE;  </div><div class="line">        <span class="keyword">return</span>;  </div><div class="line">    &#125;  </div><div class="line">    <span class="comment">// 新建一个HashMap，将“旧HashMap”的全部元素添加到“新HashMap”中</span></div><div class="line">    <span class="comment">// 然后，将“新HashMap”赋值给“旧HashMap”。  </span></div><div class="line">    Entry[] <span class="keyword">new</span><span class="type">Table</span> = <span class="keyword">new</span> <span class="type">Entry</span>[<span class="keyword">new</span><span class="type">Capacity</span>];  </div><div class="line">    transfer(<span class="keyword">new</span><span class="type">Table</span>);  </div><div class="line">    table = <span class="keyword">new</span><span class="type">Table</span>;  </div><div class="line">    threshold = (int)(<span class="keyword">new</span><span class="type">Capacity</span> * loadFactor);  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>调用transfer()方法<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">void transfer(Entry[] <span class="keyword">new</span><span class="type">Table</span>) &#123;  </div><div class="line">    Entry[] src = table;  </div><div class="line">    int <span class="keyword">new</span><span class="type">Capacity</span> = <span class="keyword">new</span><span class="type">Table</span>.length;  </div><div class="line">    <span class="keyword">for</span> (int j = <span class="number">0</span>; j &lt; src.length; j++) &#123;  </div><div class="line">        Entry&lt;K,V&gt; e = src[j];  </div><div class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;  </div><div class="line">            src[j] = <span class="literal">null</span>;  </div><div class="line">            <span class="keyword">do</span> &#123;  </div><div class="line">                Entry&lt;K,V&gt; next = e.next;  </div><div class="line">                int i = indexFor(e.hash, <span class="keyword">new</span><span class="type">Capacity</span>);  </div><div class="line">                e.next = <span class="keyword">new</span><span class="type">Table</span>[i];  </div><div class="line">                <span class="keyword">new</span><span class="type">Table</span>[i] = e;  </div><div class="line">                e = next;  </div><div class="line">            &#125; <span class="keyword">while</span> (e != <span class="literal">null</span>);  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>第一步for循环遍历每一个数组元素（桶）；<br>第二步遍历每一个数组元素中的链表，将链表中的节点存入新数组指定的位置构成链表，注意此时新链表顺序反转。（原链表的头节点将变成新链表的尾节点）<br><strong>注：原链表中的节点可能存到不同的新链表中，因为rehash重新计算了索引位置。</strong></p>
<p>由此可知，<strong>扩容操作是一个耗时耗性能的操作，因为它需要重新计算元素的位置，并进行复制操作。因此，在使用时提前预估HashMap的大小有助于提高性能。</strong></p>
<p>HashMap未初始容量和初始容量的对比：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">long</span> start1 = System.currentTimeMillis();</div><div class="line">		<span class="keyword">HashMap</span> <span class="built_in">map</span> = <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;&gt;(); <span class="comment">//未初始容量</span></div><div class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20000</span>;i++)&#123;</div><div class="line">			<span class="built_in">map</span>.put(i, <span class="string">"I am zy"</span>);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">long</span> end1 = System.currentTimeMillis();</div><div class="line">		System.out.<span class="built_in">println</span>(<span class="string">"不初始化时耗时："</span>+(end1-start1)+ <span class="string">"ms"</span>);</div><div class="line">		</div><div class="line">		<span class="keyword">long</span> start2 = System.currentTimeMillis();</div><div class="line">		<span class="keyword">HashMap</span> map2 = <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;&gt;(<span class="number">32768</span>); <span class="comment">//初始容量</span></div><div class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20000</span>;i++)&#123;</div><div class="line">			map2.put(i, <span class="string">"I am zy"</span>);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">long</span> end2 = System.currentTimeMillis();</div><div class="line">		System.out.<span class="built_in">println</span>(<span class="string">"初始化时耗时："</span>+(end2-start2)+ <span class="string">"ms"</span>);</div></pre></td></tr></table></figure>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">不初始化时耗时：<span class="number">5</span>ms</div><div class="line">初始化时耗时：<span class="number">1</span>ms</div></pre></td></tr></table></figure>
<p>可见初始化容量有助于提高性能，对于数据量大则越明显。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、HashMap的介绍&quot;&gt;&lt;a href=&quot;#一、HashMap的介绍&quot; class=&quot;headerlink&quot; title=&quot;一、HashMap的介绍&quot;&gt;&lt;/a&gt;一、HashMap的介绍&lt;/h3&gt;&lt;p&gt;HashMap是存储键值对（key，value）的一种数据结
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="JDK1.7" scheme="http://yoursite.com/tags/JDK1-7/"/>
    
      <category term="HashMap" scheme="http://yoursite.com/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>ReentrantReadWriteLock可重入读写锁</title>
    <link href="http://yoursite.com/2017/10/28/ReentrantReadWriteLock%E5%8F%AF%E9%87%8D%E5%85%A5%E8%AF%BB%E5%86%99%E9%94%81/"/>
    <id>http://yoursite.com/2017/10/28/ReentrantReadWriteLock可重入读写锁/</id>
    <published>2017-10-28T09:48:18.000Z</published>
    <updated>2018-02-24T07:44:19.001Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、ReentrantReadWriteLock的概念"><a href="#一、ReentrantReadWriteLock的概念" class="headerlink" title="一、ReentrantReadWriteLock的概念"></a>一、ReentrantReadWriteLock的概念</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>前面提到的锁（独占锁、ReentrantLock）等都是排他锁，这些锁在同一时刻只允许一个线程访问。<br>而<strong>读写锁在同一时刻可以允许多个读线程访问，但在写线程访问时，所有读线程和其他写线程都阻塞。</strong></p>
<p>ReadWriteLock并不是继承自Lock接口，而是一个单独的接口。</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public<span class="built_in"> interface </span>ReadWriteLock &#123;</div><div class="line">    Lock readLock();</div><div class="line">    Lock writeLock();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ReentrantReadWriteLock则是这个接口的实现。通过readLock()和writeLock()方法可分别获得一个ReadLock实例和一个WriteLock实例，这两个实例实现了Lock接口。<br>因此，我们可以调用Lock接口的相关方法来完成锁的语义。</p>
<figure class="highlight pony"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="type">ReentrantReadWriteLock</span> rw = <span class="function"><span class="keyword">new</span> <span class="title">ReentrantReadWriteLock</span>();</span></div><div class="line"><span class="title">Lock</span> <span class="title">r</span> = <span class="title">rw</span>.<span class="title">readLock</span>();</div><div class="line"><span class="title">Lock</span> <span class="title">w</span> = <span class="title">rw</span>.<span class="title">writeLock</span>();</div><div class="line">...</div></pre></td></tr></table></figure>
<h4 id="特性："><a href="#特性：" class="headerlink" title="特性："></a>特性：</h4><ol>
<li><p><strong>公平性：同样有公平锁和非公平锁；</strong>  </p>
</li>
<li><p><strong>重入性：读锁和写锁都支持重入（最大65535）；</strong></p>
</li>
<li><strong>锁降级：获取写锁之后，获取读锁，释放写锁，保留读锁；（按顺序）</strong></li>
</ol>
<h3 id="二、ReentrantReadWriteLock的实现原理"><a href="#二、ReentrantReadWriteLock的实现原理" class="headerlink" title="二、ReentrantReadWriteLock的实现原理"></a>二、ReentrantReadWriteLock的实现原理</h3><p>ReentrantReadWriteLock与ReentrantLock一样，锁的语义的实现依旧是依靠Sync（继承自AQS），它的读锁、写锁的实现原理如下：</p>
<ul>
<li><strong>读锁：AQS共享锁</strong></li>
<li><strong>写锁：AQS独占锁</strong></li>
</ul>
<h4 id="读写状态"><a href="#读写状态" class="headerlink" title="读写状态"></a>读写状态</h4><p>读写锁的实现同样是依赖AQS来实现同步功能。<br>那么它的读写状态如何表示呢？<br>同样是<strong>使用一个int型的变量</strong>表示，将这个变量“按位切割”成两部分，<strong>高16位表示读，低16位表示写</strong>。这样我们就能通过位运算确定它的读写状态。（如下图）  </p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/duxiesuo.jpg" alt="（图）">  </p>
<p>如果已知整体同步状态为S，那么：</p>
<ul>
<li><strong>写状态：S &amp; 0x0000FFFF</strong>（将高16位变0，抹去）</li>
<li><strong>读状态：S&gt;&gt;&gt;16</strong> （无符号补0右移16位）  </li>
</ul>
<p><strong>注：当写状态为0，S不为0时，表示读状态不为0，读锁被获取。</strong></p>
<h4 id="写锁的获取和释放"><a href="#写锁的获取和释放" class="headerlink" title="写锁的获取和释放"></a>写锁的获取和释放</h4><p>写锁是独占锁，获取时调用Sync中的tryAcquire()方法：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">            Thread current = Thread.currentThread();</div><div class="line">            <span class="comment">//获取状态</span></div><div class="line">            <span class="keyword">int</span> c = getState();</div><div class="line">            <span class="comment">//获取写状态</span></div><div class="line">            <span class="keyword">int</span> w = exclusiveCount(c);</div><div class="line">            <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</div><div class="line">                <span class="comment">//写状态为0表示存在读线程，获取失败</span></div><div class="line">                <span class="comment">//或当前线程不是获取写锁的线程，获取失败</span></div><div class="line">                <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">                <span class="comment">//超过写锁总数量</span></div><div class="line">                <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</div><div class="line">                <span class="comment">//当前线程是获取写锁的线程，重进入，获取成功</span></div><div class="line">                setState(c + acquires);</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//是否需要阻塞</span></div><div class="line">            <span class="keyword">if</span> (writerShouldBlock() ||</div><div class="line">                !compareAndSetState(c, c + acquires))</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            setExclusiveOwnerThread(current);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p>
<p>写锁的获取过程如代码中注释所示。<br>只有在以下情况才能获取写锁：</p>
<ul>
<li><strong>不存在读锁或当前线程是已经获取写锁的线程（可重入）</strong></li>
</ul>
<hr>
<p>写锁的释放调用的是Sync的tryRelease()方法：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (!isHeldExclusively())</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</div><div class="line">            <span class="keyword">int</span> nextc = getState() - releases;</div><div class="line">            <span class="keyword">boolean</span> free = exclusiveCount(nextc) == <span class="number">0</span>;</div><div class="line">            <span class="keyword">if</span> (free)</div><div class="line">                setExclusiveOwnerThread(<span class="keyword">null</span>);</div><div class="line">            setState(nextc);</div><div class="line">            <span class="keyword">return</span> free;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>写锁的释放与重入锁的释放过程类似，每次释放时将写状态减少，直到写锁状态为0时，表示写锁释放。</p>
<hr>
<h4 id="读锁的获取和释放"><a href="#读锁的获取和释放" class="headerlink" title="读锁的获取和释放"></a>读锁的获取和释放</h4><p>读锁是共享锁，调用的是Sync的tryAcquireShared()方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">protected <span class="keyword">final</span> int tryAcquireShared(int unused) &#123;</div><div class="line">            <span class="type">Thread</span> current = <span class="type">Thread</span>.currentThread();</div><div class="line">            int <span class="built_in">c</span> = getState(); <span class="comment">//获取状态</span></div><div class="line">            <span class="comment">//写锁不为0  &amp;&amp; 且获取写锁的线程不是当前线程</span></div><div class="line">            <span class="comment">//直接失败</span></div><div class="line">            <span class="keyword">if</span> (exclusiveCount(<span class="built_in">c</span>) != <span class="number">0</span> &amp;&amp;</div><div class="line">                getExclusiveOwnerThread() != current) </div><div class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">            <span class="comment">//获取读锁</span></div><div class="line">            int r = sharedCount(<span class="built_in">c</span>);</div><div class="line">            <span class="comment">//readerShouldBlock()：读锁是否要等待（公平or非公平）</span></div><div class="line">            <span class="comment">// r &lt; MAX_COUNT：读锁小于最大值（65535）</span></div><div class="line">            <span class="comment">//compareAndSetState(c, c + SHARED_UNIT))：CAS操作成功</span></div><div class="line">            <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</div><div class="line">                r &lt; <span class="type">MAX_COUNT</span> &amp;&amp;</div><div class="line">                compareAndSetState(<span class="built_in">c</span>, <span class="built_in">c</span> + <span class="type">SHARED_UNIT</span>)) &#123;</div><div class="line">                <span class="comment">//r == 0：只有一个读锁（A），计数+1</span></div><div class="line">                <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</div><div class="line">                    firstReader = current;</div><div class="line">                    firstReaderHoldCount = <span class="number">1</span>;</div><div class="line">                <span class="comment">//持有读锁的线程（A）重进入，计数++</span></div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</div><div class="line">                    firstReaderHoldCount++;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">//另一个线程（B）进入，此时找到缓存的rh，将计数++；</span></div><div class="line">                    <span class="type">HoldCounter</span> rh = cachedHoldCounter;</div><div class="line">                    <span class="keyword">if</span> (rh == null || rh.tid != getThreadId(current))</div><div class="line">                        cachedHoldCounter = rh = readHolds.<span class="keyword">get</span>();</div><div class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (rh.<span class="built_in">count</span> == <span class="number">0</span>)</div><div class="line">                        readHolds.<span class="keyword">set</span>(rh);</div><div class="line">                    rh.<span class="built_in">count</span>++;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//循环尝试</span></div><div class="line">            <span class="keyword">return</span> fullTryAcquireShared(current);</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>获取锁的过程如注释所示。<br>如果不满足第二个if语句中的判断，比如读锁需要阻塞，则会进入fullTryAcquireShared（current）方法，<strong>该方法循环不断尝试修改状态直到成功或被写入锁占有。</strong></p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">final int fullTryAcquireShared(Thread current) &#123;</div><div class="line">            HoldCounter <span class="attr">rh</span> = <span class="literal">null</span>;</div><div class="line">            for (;;) &#123;</div><div class="line">                int <span class="attr">c</span> = getState();</div><div class="line">                //写锁存在但不是当前线程，直接失败</div><div class="line">                <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span>) &#123;</div><div class="line">                    <span class="keyword">if</span> (getExclusiveOwnerThread() != current)</div><div class="line">                        return -<span class="number">1</span>;</div><div class="line">                //读锁是否要阻塞（公平 <span class="literal">or</span> 非公平）</div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readerShouldBlock()) &#123;</div><div class="line">                    <span class="keyword">if</span> (<span class="attr">firstReader</span> == current) &#123;</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        <span class="keyword">if</span> (<span class="attr">rh</span> == <span class="literal">null</span>) &#123;</div><div class="line">                            <span class="attr">rh</span> = cachedHoldCounter;</div><div class="line">                            <span class="keyword">if</span> (<span class="attr">rh</span> == <span class="literal">null</span> || rh.tid != getThreadId(current)) &#123;</div><div class="line">                                <span class="attr">rh</span> = readHolds.get();</div><div class="line">                                <span class="keyword">if</span> (rh.<span class="attr">count</span> == <span class="number">0</span>)</div><div class="line">                                    readHolds.remove();</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                        <span class="keyword">if</span> (rh.<span class="attr">count</span> == <span class="number">0</span>)</div><div class="line">                            return -<span class="number">1</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                //读锁达到最大值，不能再获取</div><div class="line">                <span class="keyword">if</span> (sharedCount(c) == MAX_COUNT)</div><div class="line">                    <span class="built_in">throw</span> new Error(<span class="string">"Maximum lock count exceeded"</span>);</div><div class="line">                //CAS操作</div><div class="line">                <span class="keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123;</div><div class="line">                    <span class="keyword">if</span> (sharedCount(c) == <span class="number">0</span>) &#123;</div><div class="line">                        <span class="attr">firstReader</span> = current;</div><div class="line">                        <span class="attr">firstReaderHoldCount</span> = <span class="number">1</span>;</div><div class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="attr">firstReader</span> == current) &#123;</div><div class="line">                        firstReaderHoldCount++;</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        <span class="keyword">if</span> (<span class="attr">rh</span> == <span class="literal">null</span>)</div><div class="line">                            <span class="attr">rh</span> = cachedHoldCounter;</div><div class="line">                        <span class="keyword">if</span> (<span class="attr">rh</span> == <span class="literal">null</span> || rh.tid != getThreadId(current))</div><div class="line">                            <span class="attr">rh</span> = readHolds.get();</div><div class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (rh.<span class="attr">count</span> == <span class="number">0</span>)</div><div class="line">                            readHolds.set(rh);</div><div class="line">                        rh.count++;</div><div class="line">                        <span class="attr">cachedHoldCounter</span> = rh; </div><div class="line">                    &#125;</div><div class="line">                    return <span class="number">1</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>以上的代码中多次出现了一个rh变量（HoldCounter），我们知道重入锁的原理就是计数器，同理这个rh变量也相当于一个计数器，记录线程获取读锁的次数。来看它的定义：</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//HoldCounter类</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HoldCounter</span> </span>&#123;</div><div class="line">            <span class="keyword">int</span> <span class="keyword">count</span> = <span class="number">0</span>;</div><div class="line">            <span class="keyword">final</span> <span class="keyword">long</span> tid = getThreadId(Thread.currentThread());</div><div class="line">        &#125;</div><div class="line"><span class="comment">//继承ThreadLocal类        </span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalHoldCounter</span></span></div><div class="line">            <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">HoldCounter</span>&gt; &#123;</div><div class="line">            <span class="keyword">public</span> HoldCounter initialValue() &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">new</span> HoldCounter();</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>HoldCounter的定义只包含一个计数器和当前线程的Id，它的作用就是记录该线程获取读锁的次数，那么它是如何与线程绑定的呢？我们知道ThreadLocal类是线程维护的私有变量，利用它就可以和线程绑定。  </p>
<p>注：（需要说明的是这样<strong>HoldCounter绑定线程id而不绑定线程对象的原因是**</strong>避免HoldCounter和ThreadLocal互相绑定而GC难以释放它们**，所以其实这样做只是为了帮助GC快速回收对象而已。）</p>
<hr>
<p>当读锁释放时，调用的是Sync的tryReleaseShared()方法：</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> tryReleaseShared(<span class="keyword">int</span> unused) &#123;</div><div class="line">            Thread current = Thread.currentThread();</div><div class="line">            <span class="keyword">if</span> (firstReader == current) &#123;</div><div class="line">                <span class="keyword">if</span> (firstReaderHoldCount == <span class="number">1</span>)</div><div class="line">                    firstReader = <span class="keyword">null</span>;</div><div class="line">                <span class="keyword">else</span></div><div class="line">                    firstReaderHoldCount--;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                HoldCounter rh = cachedHoldCounter;</div><div class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</div><div class="line">                    rh = readHolds.get();</div><div class="line">                <span class="keyword">int</span> <span class="keyword">count</span> = rh.<span class="keyword">count</span>;</div><div class="line">                <span class="keyword">if</span> (<span class="keyword">count</span> &lt;= <span class="number">1</span>) &#123;</div><div class="line">                    readHolds.remove();</div><div class="line">                    <span class="keyword">if</span> (<span class="keyword">count</span> &lt;= <span class="number">0</span>)</div><div class="line">                        <span class="keyword">throw</span> unmatchedUnlockException();</div><div class="line">                &#125;</div><div class="line">                --rh.<span class="keyword">count</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">for</span> (;;) &#123;</div><div class="line">                <span class="keyword">int</span> c = getState();</div><div class="line">                <span class="keyword">int</span> nextc = c - SHARED_UNIT;</div><div class="line">                <span class="keyword">if</span> (compareAndSetState(c, nextc))</div><div class="line">                    <span class="keyword">return</span> nextc == <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>循环CAS操作直到读锁的状态为0。</p>
<h4 id="锁降级"><a href="#锁降级" class="headerlink" title="锁降级"></a>锁降级</h4><p>前面提到，读写锁有个特性是锁降级。<br>锁降级指的是：<strong>写锁降级为读锁</strong>。</p>
<p>具体过程：<strong>获取写锁的线程把持住写锁，然后获取读锁，再释放写锁。</strong>  </p>
<p><strong>目的：保证写锁修改的数据可以被其他线程看见，保证了数据的可见性。</strong> </p>
<p>锁降级中读锁的获取是否为必要？肯定是必要的。试想，假如当前线程A不获取读锁而是直接释放了写锁，这个时候另外一个线程B获取了写锁，那么这个线程B对数据的修改是不会对当前线程A可见的。   如果获取了读锁，则线程B在获取写锁过程中判断如果有读锁还没有释放则会被阻塞，只有当前线程A释放读锁后，线程B才会获取写锁成功。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、ReentrantReadWriteLock的概念&quot;&gt;&lt;a href=&quot;#一、ReentrantReadWriteLock的概念&quot; class=&quot;headerlink&quot; title=&quot;一、ReentrantReadWriteLock的概念&quot;&gt;&lt;/a&gt;一、Ree
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="ReentrantReadWriteLock" scheme="http://yoursite.com/tags/ReentrantReadWriteLock/"/>
    
      <category term="可重入读写锁" scheme="http://yoursite.com/tags/%E5%8F%AF%E9%87%8D%E5%85%A5%E8%AF%BB%E5%86%99%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>JVM之对象创建过程</title>
    <link href="http://yoursite.com/2017/10/26/JVM%E4%B9%8B%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2017/10/26/JVM之对象创建过程/</id>
    <published>2017-10-26T10:48:19.000Z</published>
    <updated>2018-02-24T07:33:25.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、Java对象的创建过程"><a href="#一、Java对象的创建过程" class="headerlink" title="一、Java对象的创建过程"></a>一、Java对象的创建过程</h3><p>在Java程序中，通常都是通过 new 关键字来创建对象，那么在虚拟机中对象是如何创建的？<br>（普通Java对象，不包含数组和Class对象）</p>
<p>虚拟机创建对象主要经历5个步骤：<strong>类加载检查、为对象分配内存、内存空间初始化、对象设置、执行对象<init>方法。</init></strong></p>
<h4 id="1-类加载检查"><a href="#1-类加载检查" class="headerlink" title="1 类加载检查"></a>1 类加载检查</h4><p>当虚拟机遇到 new 指令时，首先会去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且<strong>检查这个符号引用代表的类是否已被加载、解析和初始化过</strong>。如果没有，先执行类加载过程。</p>
<h4 id="2-为对象分配内存"><a href="#2-为对象分配内存" class="headerlink" title="2 为对象分配内存"></a>2 为对象分配内存</h4><p>对象所需的内存大小在类加载完成时已经确定，因此<strong>为对象分配内存等同于在Java堆中划分一块大小确定的内存空间</strong>。  </p>
<h5 id="两种分配方式："><a href="#两种分配方式：" class="headerlink" title="两种分配方式："></a>两种分配方式：</h5><ul>
<li><strong>指针碰撞</strong>：Java堆中的内存是完整的，将指针往空闲空间挪动一段与对象大小相等的距离</li>
<li><strong>空闲列表</strong>：Java堆中的内存不是完整的，JVM维护了一个记录可用内存的列表，分配时将列表中足够大的空间划分给对象，并更新列表</li>
</ul>
<p>因此选择何种分配方式由Java堆是否完整决定，而这又由垃圾收集器是否带有压缩整理功能决定。如：</p>
<ul>
<li><strong>Serial、ParNew等采用指针碰撞</strong></li>
<li><strong>CMS基于“标记-清除”采用空闲列表</strong></li>
</ul>
<h5 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h5><p>当处于并发情况下时，还要考虑线程安全问题。<br>两种解决方案：</p>
<ul>
<li><strong>对分配内存的动作进行同步处理</strong>。JVM采用CAS加失败重试的方式保证原子性</li>
<li><strong>把内存分配的动作按照线程划分在不同的空间进行</strong>。每个线程在Java堆中预先分配一小块内存（本地线程分配缓冲TLAB），只有TLAB用完重新分配时才同步锁定。<h4 id="3-内存空间初始化"><a href="#3-内存空间初始化" class="headerlink" title="3 内存空间初始化"></a>3 内存空间初始化</h4>JVM将分配到的内存空间都初始化为零值（不包括对象头）；若使用TLAB，则提前至TLAB分配时执行。</li>
</ul>
<p>这一步<strong>保证了对象实例字段在Java代码中可以不赋初值就直接使用</strong>，程序能访问到这些字段的数据类型所对应的零值。</p>
<h4 id="4-对象设置"><a href="#4-对象设置" class="headerlink" title="4 对象设置"></a>4 对象设置</h4><p>JVM设置对象头信息，如类元数据信息、对象的哈希码、对象的GC分代年龄信息等。还有是否启用偏向锁。</p>
<h4 id="5-执行对象方法"><a href="#5-执行对象方法" class="headerlink" title="5 执行对象方法"></a>5 执行对象<init>方法</init></h4><p>此时，对于JVM来说，对象已经产生；<br>对于Java程序来说，才刚刚开始，执行<init>方法进行初始化，一个对象才算真正创建完成。</init></p>
<h3 id="二、Java对象的初始化"><a href="#二、Java对象的初始化" class="headerlink" title="二、Java对象的初始化"></a>二、Java对象的初始化</h3><p>在Java对象初始化过程中，主要涉及三种执行对象初始化的结构，分别是 <strong>实例变量初始化、实例代码块初始化</strong> 以及 <strong>构造函数初始化</strong>。 </p>
<h4 id="实例变量初始化与实例代码块初始化"><a href="#实例变量初始化与实例代码块初始化" class="headerlink" title="实例变量初始化与实例代码块初始化"></a>实例变量初始化与实例代码块初始化</h4><p>在定义（声明）实例变量的同时，还可以直接对实例变量进行赋值或者使用实例代码块对其进行赋值。<br>如果我们<strong>以这两种方式为实例变量进行初始化，那么它们将在构造函数执行之前完成这些初始化操作。</strong> 实际上，如果我们对实例变量直接赋值或者使用实例代码块赋值，那么编译器会将其中的代码放到类的构造函数中去，并且这些代码会被放在对超类构造函数的调用语句之后(Super())，构造函数本身的代码之前。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Tdemo2</span> &#123;</div><div class="line">	<span class="comment">//成员变量</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">1</span>;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> j = <span class="number">1</span>;</div><div class="line">	<span class="function"><span class="keyword">public</span>  <span class="title">Tdemo2</span>(<span class="params"><span class="keyword">int</span> c</span>)</span>&#123;</div><div class="line">		System.<span class="keyword">out</span>.println(i);</div><div class="line">		System.<span class="keyword">out</span>.println(j);</div><div class="line">		<span class="keyword">this</span>.i = c;</div><div class="line">		System.<span class="keyword">out</span>.println(i);</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//代码块</span></div><div class="line">	&#123;</div><div class="line">		j = j+<span class="number">1</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//静态代码块</span></div><div class="line">	<span class="keyword">static</span>&#123;</div><div class="line">		<span class="keyword">int</span> a = <span class="number">5</span>;</div><div class="line">		System.<span class="keyword">out</span>.println(a);</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</div><div class="line">		<span class="keyword">new</span> Tdemo2(<span class="number">3</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">5</span></div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">2</span></div><div class="line"><span class="number">3</span></div></pre></td></tr></table></figure></p>
<p>可见执行顺序是static代码块、成员变量赋值、代码块、构造函数。</p>
<h4 id="构造函数初始化"><a href="#构造函数初始化" class="headerlink" title="构造函数初始化"></a>构造函数初始化</h4><p><strong>Java要求在实例化类之前，必须先实例化其超类，以保证所创建实例的完整性。</strong><br>Java强制要求Object对象(Object是Java的顶层对象，没有超类)之外的所有对象构造函数的第一条语句必须是超类构造函数的调用语句或者是类中定义的其他的构造函数，如果我们既没有调用其他的构造函数，也没有显式调用超类的构造函数，那么编译器会为我们自动生成一个对超类构造函数的调用。</p>
<p>实际上，实例化一个类的对象的过程是一个典型的递归过程。</p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/%E5%AE%9E%E4%BE%8B%E5%8C%96%E9%80%92%E5%BD%92%E8%BF%87%E7%A8%8B.png" alt="image"></p>
<p>在准备实例化一个类的对象前，首先准备实例化该类的父类，如果该类的父类还有父类，那么准备实例化该类的父类的父类，依次递归直到递归到Object类。</p>
<p><strong>注意：实例初始化不一定要在类初始化结束之后才开始初始化。</strong></p>
<p>回忆一下Java中赋值顺序： </p>
<ol>
<li>父类的静态变量赋值 </li>
<li>自身的静态变量赋值 </li>
<li>父类成员变量赋值和父类代码块赋值 </li>
<li>父类构造函数赋值 </li>
<li>自身成员变量赋值和自身块代码赋值 </li>
<li>自身构造函数赋值</li>
</ol>
<h3 id="三、Java对象的创建方式"><a href="#三、Java对象的创建方式" class="headerlink" title="三、Java对象的创建方式"></a>三、Java对象的创建方式</h3><p>Java对象的创建方式有 5 种：</p>
<ol>
<li><p>new 关键字</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Person p</span> = new Person();</div></pre></td></tr></table></figure>
</li>
<li><p>Class类的newInstance()（反射）</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Person p2 = Person.class.<span class="keyword">new</span><span class="type">Instance</span>();</div></pre></td></tr></table></figure>
</li>
<li><p>Constructor类的newInstance方法（反射）</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">Constructor</span> <span class="title">c</span> = <span class="title">Person</span>.<span class="title">class</span>.<span class="title">getConstructor</span><span class="params">()</span>;</span></div><div class="line">Person p3 = (Person) c.newInstance();</div></pre></td></tr></table></figure>
</li>
<li><p>clone方法（实现Cloneable接口）</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">Person</span> <span class="built_in">p4</span> = (Person) <span class="built_in">p3</span>.clone()<span class="comment">;</span></div></pre></td></tr></table></figure>
</li>
<li><p>反序列化（实现Serializable接口）</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//写对象</span></div><div class="line">ObjectOutputStream <span class="keyword">output</span> = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"person.txt"</span>));</div><div class="line"><span class="keyword">output</span><span class="variable">.writeObject</span>(p);</div><div class="line"><span class="keyword">output</span><span class="variable">.close</span>();</div><div class="line"></div><div class="line"><span class="comment">//读对象</span></div><div class="line">ObjectInputStream <span class="keyword">input</span> = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"person.txt"</span>));</div><div class="line">Person p5 = (Person) <span class="keyword">input</span><span class="variable">.readObject</span>();</div></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、Java对象的创建过程&quot;&gt;&lt;a href=&quot;#一、Java对象的创建过程&quot; class=&quot;headerlink&quot; title=&quot;一、Java对象的创建过程&quot;&gt;&lt;/a&gt;一、Java对象的创建过程&lt;/h3&gt;&lt;p&gt;在Java程序中，通常都是通过 new 关键字来创建
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
      <category term="对象创建过程" scheme="http://yoursite.com/tags/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B/"/>
    
  </entry>
  
</feed>
