<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZY&#39;s Blog</title>
  <subtitle>Young for you.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-04-14T16:29:31.778Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Z Yong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ActiveMQ结合Spring收发消息</title>
    <link href="http://yoursite.com/2018/02/15/ActiveMQ%E7%BB%93%E5%90%88Spring%E6%94%B6%E5%8F%91%E6%B6%88%E6%81%AF/"/>
    <id>http://yoursite.com/2018/02/15/ActiveMQ结合Spring收发消息/</id>
    <published>2018-02-15T07:12:12.000Z</published>
    <updated>2018-04-14T16:29:31.778Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ActiveMQ结合Spring收发消息"><a href="#ActiveMQ结合Spring收发消息" class="headerlink" title="ActiveMQ结合Spring收发消息"></a>ActiveMQ结合Spring收发消息</h3><p>直接使用ActiveMQ的方式需要重复写很多代码，且不利于管理，Spring 提供了一种更加简便的方式————Spring JMS ，通过它可以更加方便地使用ActiveMQ。</p>
<h4 id="Maven-依赖"><a href="#Maven-依赖" class="headerlink" title="Maven 依赖"></a>Maven 依赖</h4><p>结合Spring使用ActiveMQ的依赖如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">&lt;!-- Spring JMS --&gt;</div><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;spring-jms&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div><div class="line">&lt;!-- xbean 如&lt;amq:connectionFactory /&gt; --&gt;</div><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.apache.xbean&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;xbean-spring&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;3.16&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div><div class="line">&lt;!-- ActiiveMQ --&gt;</div><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;activemq-core&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;5.7.0&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;activemq-pool&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;5.7.0&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure></p>
<h4 id="ActiveMQ-xml-文件"><a href="#ActiveMQ-xml-文件" class="headerlink" title="ActiveMQ.xml 文件"></a>ActiveMQ.xml 文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</div><div class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</div><div class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</div><div class="line">       xmlns:amq=&quot;http://activemq.apache.org/schema/core&quot;</div><div class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</div><div class="line">        http://www.springframework.org/schema/beans/spring-beans-4.0.xsd</div><div class="line">        http://activemq.apache.org/schema/core</div><div class="line">        http://activemq.apache.org/schema/core/activemq-core-5.12.1.xsd&quot;&gt;</div><div class="line">    &lt;!-- ActiveMQ 连接工厂 --&gt;</div><div class="line">    &lt;amq:connectionFactory id=&quot;amqConnectionFactory&quot;</div><div class="line">                           brokerURL=&quot;tcp://localhost:61616&quot;</div><div class="line">                           userName=&quot;admin&quot;</div><div class="line">                           password=&quot;admin&quot; /&gt;</div><div class="line"></div><div class="line">    &lt;!-- 提高效率，配置JMS连接工厂 --&gt;</div><div class="line">    &lt;bean id=&quot;connectionFactory&quot; class=&quot;org.springframework.jms.connection.CachingConnectionFactory&quot;&gt;</div><div class="line">        &lt;constructor-arg ref=&quot;amqConnectionFactory&quot; /&gt;</div><div class="line">        &lt;property name=&quot;sessionCacheSize&quot; value=&quot;100&quot; /&gt;</div><div class="line">    &lt;/bean&gt;</div><div class="line">    &lt;!-- 定义消息队列（Queue）--&gt;</div><div class="line">   &lt;!-- &lt;bean id=&quot;QueueDestination&quot; class=&quot;org.apache.activemq.command.ActiveMQQueue&quot;&gt;</div><div class="line">        &amp;lt;!&amp;ndash; 设置消息队列的名字 &amp;ndash;&amp;gt;</div><div class="line">        &lt;constructor-arg value=&quot;Queue-zy&quot;/&gt;</div><div class="line">    &lt;/bean&gt;--&gt;</div><div class="line">    &lt;!--定义主题(Topic)--&gt;</div><div class="line">    &lt;bean id=&quot;topicDestination&quot; class=&quot;org.apache.activemq.command.ActiveMQTopic&quot;&gt;</div><div class="line">        &lt;constructor-arg value=&quot;Topic-zy&quot;/&gt;</div><div class="line">    &lt;/bean&gt;</div><div class="line">    &lt;!-- 配置JMS模板（Queue），Spring提供的JMS工具类，利用它发送、接收消息。 --&gt;</div><div class="line">    &lt;bean id=&quot;jmsTemplate&quot; class=&quot;org.springframework.jms.core.JmsTemplate&quot;&gt;</div><div class="line">        &lt;property name=&quot;connectionFactory&quot; ref=&quot;connectionFactory&quot; /&gt;</div><div class="line">        &lt;property name=&quot;defaultDestination&quot; ref=&quot;topicDestination&quot; /&gt;</div><div class="line">        &lt;property name=&quot;receiveTimeout&quot; value=&quot;10000&quot; /&gt;</div><div class="line">        &lt;!-- true是topic，false是queue，默认是false --&gt;</div><div class="line">        &lt;property name=&quot;pubSubDomain&quot; value=&quot;true&quot; /&gt;</div><div class="line">    &lt;/bean&gt;</div><div class="line">    &lt;!-- 配置消息队列监听者（Queue or Topic） --&gt;</div><div class="line">    &lt;bean id=&quot;messageListener&quot; class=&quot;com.service.TopicMessageListener&quot; /&gt;</div><div class="line"></div><div class="line">    &lt;!-- 显示注入消息监听容器，配置连接工厂，监听的目标是QueueDestination，监听器是上面定义的监听器 --&gt;</div><div class="line">    &lt;bean id=&quot;ListenerContainer&quot;</div><div class="line">          class=&quot;org.springframework.jms.listener.DefaultMessageListenerContainer&quot;&gt;</div><div class="line">        &lt;property name=&quot;connectionFactory&quot; ref=&quot;connectionFactory&quot; /&gt;</div><div class="line">        &lt;property name=&quot;destination&quot; ref=&quot;topicDestination&quot; /&gt;</div><div class="line">        &lt;property name=&quot;messageListener&quot; ref=&quot;messageListener&quot; /&gt;</div><div class="line">    &lt;/bean&gt;</div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure>
<h5 id="配置connectionFactory"><a href="#配置connectionFactory" class="headerlink" title="配置connectionFactory"></a>配置connectionFactory</h5><p>connectionFactory是Spring用于创建到JMS服务器链接的，Spring提供了多种connectionFactory.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;!-- ActiveMQ 连接工厂 --&gt;</div><div class="line">&lt;amq:connectionFactory id=&quot;amqConnectionFactory&quot;</div><div class="line">                       brokerURL=&quot;tcp://localhost:61616&quot;</div><div class="line">                       userName=&quot;admin&quot;</div><div class="line">                       password=&quot;admin&quot; /&gt;</div><div class="line"></div><div class="line">&lt;!-- 提高效率，配置JMS连接工厂 --&gt;</div><div class="line">&lt;bean id=&quot;connectionFactory&quot; class=&quot;org.springframework.jms.connection.CachingConnectionFactory&quot;&gt;</div><div class="line">    &lt;constructor-arg ref=&quot;amqConnectionFactory&quot; /&gt;</div><div class="line">    &lt;property name=&quot;sessionCacheSize&quot; value=&quot;100&quot; /&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure>
<h5 id="配置Queue"><a href="#配置Queue" class="headerlink" title="配置Queue"></a>配置Queue</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=&quot;QueueDestination&quot; class=&quot;org.apache.activemq.command.ActiveMQQueue&quot;&gt;</div><div class="line">       &lt;!-- 设置消息队列的名字 --&gt;</div><div class="line">       &lt;constructor-arg value=&quot;Queue-zy&quot;/&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure>
<h5 id="配置Topic"><a href="#配置Topic" class="headerlink" title="配置Topic"></a>配置Topic</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=&quot;topicDestination&quot; class=&quot;org.apache.activemq.command.ActiveMQTopic&quot;&gt;</div><div class="line">        &lt;constructor-arg value=&quot;Topic-zy&quot;/&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure>
<h5 id="配置JMS消息模板——jmsTemplate"><a href="#配置JMS消息模板——jmsTemplate" class="headerlink" title="配置JMS消息模板——jmsTemplate"></a>配置JMS消息模板——jmsTemplate</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 配置JMS模板，Spring提供的JMS工具类，利用它发送、接收消息--&gt;</div><div class="line">&lt;bean id=&quot;jmsTemplate&quot; class=&quot;org.springframework.jms.core.JmsTemplate&quot;&gt;</div><div class="line">    &lt;property name=&quot;connectionFactory&quot; ref=&quot;connectionFactory&quot; /&gt;</div><div class="line">    &lt;property name=&quot;defaultDestination&quot; ref=&quot;QueueDestination&quot; /&gt;</div><div class="line">    &lt;!--&lt;property name=&quot;defaultDestination&quot; ref=&quot;topicDestination&quot; /&gt;--&gt;</div><div class="line">    &lt;property name=&quot;receiveTimeout&quot; value=&quot;10000&quot; /&gt;</div><div class="line">    &lt;property name=&quot;pubSubDomain&quot; value=&quot;false&quot; /&gt;&lt;!-- true是topic，false是queue，默认是false --&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure>
<p>最后，在applicationContext.xml中引入配置好的ActiveMQ.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;import resource=&quot;ActiveMQ.xml&quot; /&gt;</div></pre></td></tr></table></figure></p>
<p>以上就是配置文件相关的，下面是具体的业务代码。</p>
<h4 id="消息生产者服务"><a href="#消息生产者服务" class="headerlink" title="消息生产者服务"></a>消息生产者服务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">@Service</div><div class="line">public class ProducerService &#123;</div><div class="line"></div><div class="line">    @Autowired</div><div class="line">    private JmsTemplate jmsTemplate;</div><div class="line"></div><div class="line">    //使用默认目的地</div><div class="line">    public void sendMessageDefault(final String msg)&#123;</div><div class="line">        Destination destination = jmsTemplate.getDefaultDestination();</div><div class="line">        System.out.println(&quot;向队列： &quot; + destination + &quot; 成功发送一条消息&quot;);</div><div class="line">        jmsTemplate.send(new MessageCreator() &#123;</div><div class="line">            public Message createMessage(Session session) throws JMSException &#123;</div><div class="line">                return session.createTextMessage(msg);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //可指定目的地</div><div class="line">    public void sendMessage(Destination destination,final String msg)&#123;</div><div class="line"></div><div class="line">        jmsTemplate.send(destination, new MessageCreator() &#123;</div><div class="line">            public Message createMessage(Session session) throws JMSException &#123;</div><div class="line">                return session.createTextMessage(msg);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="消息消费者服务"><a href="#消息消费者服务" class="headerlink" title="消息消费者服务"></a>消息消费者服务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">@Service</div><div class="line">public class ConsumerService &#123;</div><div class="line"></div><div class="line">    @Autowired</div><div class="line">    private JmsTemplate jmsTemplate;</div><div class="line"></div><div class="line">    //从指定的Destination接收消息</div><div class="line">    public TextMessage recive(Destination destination)&#123;</div><div class="line">        TextMessage message = (TextMessage) jmsTemplate.receive(destination);</div><div class="line">        try &#123;</div><div class="line">            System.out.println(&quot;从队列&quot; + destination.toString() + &quot;收到了消息&quot; + message.getText());</div><div class="line">        &#125; catch (JMSException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        return message;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //从默认的Destination接收消息</div><div class="line">    public void reciveDefault()&#123;</div><div class="line">    </div><div class="line">        Destination destination = jmsTemplate.getDefaultDestination();</div><div class="line">        jmsTemplate.setReceiveTimeout(5000);</div><div class="line">        while(true)&#123;</div><div class="line">            TextMessage message = (TextMessage) jmsTemplate.receive(destination);</div><div class="line">            try &#123;</div><div class="line">                //这里还是同一个消费者</div><div class="line">                System.out.println(&quot;消费者  从目的地 &quot; + destination.toString() + &quot; 收到了消息&quot; + message.getText());</div><div class="line">            &#125; catch (JMSException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h4><p>直接在main方法中获取ApplicationContext运行，便于测试。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">@Component</div><div class="line">public class MsgProducer &#123;</div><div class="line"></div><div class="line">    @Autowired</div><div class="line">    private ProducerService producerService;</div><div class="line"></div><div class="line">    public void send()&#123;</div><div class="line">        System.out.println(&quot;生产者开始发送消息：&quot;);</div><div class="line">        for(int i = 1; i &lt; 11; i++)&#123;</div><div class="line">            String msg = &quot;生产者发出的消息&quot;;</div><div class="line">            producerService.sendMessageDefault(msg + &quot;-----&quot; + i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:/applicationContext.xml&quot;);</div><div class="line">        MsgProducer msgProducer = context.getBean(MsgProducer.class);</div><div class="line">        msgProducer.send();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">@Component</div><div class="line">public class MsgConsumer &#123;</div><div class="line"></div><div class="line">    @Autowired</div><div class="line">    private ConsumerService consumerService;</div><div class="line"></div><div class="line">    public void recive()&#123;</div><div class="line">        System.out.println(&quot;消费者 1 开始接收消息：&quot;);</div><div class="line">        consumerService.reciveDefault();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:/applicationContext.xml&quot;);</div><div class="line">        MsgConsumer msgConsumer = context.getBean(MsgConsumer.class);</div><div class="line">        msgConsumer.recive();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来就可以启动项目。同样是使用两种方式测试。</p>
<h4 id="第一种方式————点对点（Queue）"><a href="#第一种方式————点对点（Queue）" class="headerlink" title="第一种方式————点对点（Queue）"></a>第一种方式————点对点（Queue）</h4><h4 id="同步的方式"><a href="#同步的方式" class="headerlink" title="同步的方式"></a>同步的方式</h4><p>先启动生产者  发送10条消息， 再启动消费者，可以看到控制台显示成功收到10条消息  </p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/%E7%82%B9%E5%AF%B9%E7%82%B9%E7%94%9F%E4%BA%A7.png" alt="image"></p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/%E7%82%B9%E5%AF%B9%E7%82%B9%E6%B6%88%E8%B4%B9.jpg" alt="image"></p>
<h4 id="异步监听的方式"><a href="#异步监听的方式" class="headerlink" title="异步监听的方式"></a>异步监听的方式</h4><p>通过监听器即可实现异步接收消息的效果，而不是像上面使用while()轮询同步的方式。<br>项目中一般都是使用异步监听的方式，<strong>在A服务中发送了一条消息，B服务可以利用消息监听器监听，当收到消息后，进行相应的操作</strong>。</p>
<h5 id="消息监听器（3种）"><a href="#消息监听器（3种）" class="headerlink" title="消息监听器（3种）"></a>消息监听器（3种）</h5><p>通过继承JMS中的<strong>MessageListener接口</strong>，实现onMessage()方法，就可以自定义监听器。这是最基本的监听器。（可根据业务实现自定义的功能）</p>
<p>另外spring也给我们提供了其他类型的消息监听器，比如 <strong>SessionAwareMessageListener</strong>，它的作用不仅可以接收消息，还可以发送一条消息通知对方表示自己收到了消息。（还有一种是<strong>MessageListenerAdapter</strong>）</p>
<p>一个简单的自定义监听器如下:收到消息后打印消息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class QueueMessageListener implements MessageListener &#123;</div><div class="line"></div><div class="line">    public void onMessage(Message message) &#123;</div><div class="line">        //如果有消息</div><div class="line">        TextMessage tmessage = (TextMessage) message;</div><div class="line">        try &#123;</div><div class="line">            if(tmessage != null)&#123;</div><div class="line">                System.out.println(&quot;监听器监听消息：&quot;+tmessage.getText());</div><div class="line">            &#125;</div><div class="line">        &#125; catch (JMSException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在ActiveMQ.xml中引入消息监听器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 配置消息队列监听者（Queue） --&gt;</div><div class="line">    &lt;bean id=&quot;queueMessageListener&quot; class=&quot;com.service.QueueMessageListener&quot; /&gt;</div><div class="line">    </div><div class="line"> &lt;!-- 显示注入消息监听容器，配置连接工厂，监听的目标是QueueDestination 或 topicDestination，监听器是上面自定义的监听器 --&gt;</div><div class="line">    &lt;bean id=&quot;queueListenerContainer&quot;</div><div class="line">          class=&quot;org.springframework.jms.listener.DefaultMessageListenerContainer&quot;&gt;</div><div class="line">        &lt;property name=&quot;connectionFactory&quot; ref=&quot;connectionFactory&quot; /&gt;</div><div class="line">        &lt;property name=&quot;destination&quot; ref=&quot;QueueDestination&quot; /&gt;</div><div class="line">        &lt;!--&lt;property name=&quot;destination&quot; ref=&quot;topicDestination&quot; /&gt;--&gt;</div><div class="line">        &lt;property name=&quot;messageListener&quot; ref=&quot;queueMessageListener&quot; /&gt;</div><div class="line">    &lt;/bean&gt;</div></pre></td></tr></table></figure></p>
<p>可以看到，当使用消息监听器之后，每发送一条消息立马就会被监听到：  </p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/%E7%82%B9%E5%AF%B9%E7%82%B9%E7%9B%91%E5%90%AC%E5%99%A8.jpg" alt="image"></p>
<h4 id="第二种方式————发布-订阅（Topic）"><a href="#第二种方式————发布-订阅（Topic）" class="headerlink" title="第二种方式————发布/订阅（Topic）"></a>第二种方式————发布/订阅（Topic）</h4><h4 id="同步的方式-1"><a href="#同步的方式-1" class="headerlink" title="同步的方式"></a>同步的方式</h4><p>类似点对点中同步的方式，只是每个消费者都能收到生产者发出的全部消息，不再赘述。</p>
<h4 id="异步监听的方式-1"><a href="#异步监听的方式-1" class="headerlink" title="异步监听的方式"></a>异步监听的方式</h4><p>启动两个监听器（两个消费者），对消息进行异步监听。看是否各自能收到生产者发送的消息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 配置两个监听器 --&gt;</div><div class="line">    &lt;bean id=&quot;messageListener&quot; class=&quot;com.service.TopicMessageListener&quot; /&gt;</div><div class="line">    &lt;bean id=&quot;messageListener2&quot; class=&quot;com.service.TopicMessageListener2&quot; /&gt;</div></pre></td></tr></table></figure>
<p><img src="http://osuskkx7k.bkt.clouddn.com/%E4%B8%A4%E4%B8%AA%E7%9B%91%E5%90%AC%E5%99%A8.jpg" alt="image"></p>
<p>可以看到，每个监听器各自都收到了生产者发送的10条消息。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;ActiveMQ结合Spring收发消息&quot;&gt;&lt;a href=&quot;#ActiveMQ结合Spring收发消息&quot; class=&quot;headerlink&quot; title=&quot;ActiveMQ结合Spring收发消息&quot;&gt;&lt;/a&gt;ActiveMQ结合Spring收发消息&lt;/h3&gt;&lt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="ActiveMQ" scheme="http://yoursite.com/tags/ActiveMQ/"/>
    
      <category term="消息队列" scheme="http://yoursite.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>ActiveMQ的简单使用</title>
    <link href="http://yoursite.com/2018/02/12/ActiveMQ%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/02/12/ActiveMQ的简单使用/</id>
    <published>2018-02-12T07:12:12.000Z</published>
    <updated>2018-04-14T16:37:00.716Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ActiveMQ的简单使用"><a href="#ActiveMQ的简单使用" class="headerlink" title="ActiveMQ的简单使用"></a>ActiveMQ的简单使用</h3><p>ActiveMQ 是一种消息队列，是Apache提供的一个开源消息系统，完全采用Java实现，因此，它能很好地支持J2EE提出的JMS（Java Message Service,即Java消息服务）规范。</p>
<h4 id="第一种方式（点对点）——Queue"><a href="#第一种方式（点对点）——Queue" class="headerlink" title="第一种方式（点对点）——Queue"></a>第一种方式（点对点）——Queue</h4><h5 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">import org.apache.activemq.ActiveMQConnectionFactory;</div><div class="line">import javax.jms.*;</div><div class="line"></div><div class="line">public class Producer &#123;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">        //连接工厂</div><div class="line">        ConnectionFactory connectionFactory;</div><div class="line">        //连接</div><div class="line">        Connection connection = null;</div><div class="line">        //会话</div><div class="line">        Session session;</div><div class="line">        //目的地</div><div class="line">        Destination destination;</div><div class="line">        //消息生产者</div><div class="line">        MessageProducer messageProducer;</div><div class="line"></div><div class="line">        try &#123;</div><div class="line">            connectionFactory = new ActiveMQConnectionFactory(ActiveMQConnectionFactory.DEFAULT_USER,ActiveMQConnectionFactory.DEFAULT_PASSWORD,</div><div class="line">                    ActiveMQConnectionFactory.DEFAULT_BROKER_URL);</div><div class="line">            connection = connectionFactory.createConnection();</div><div class="line">            connection.start();</div><div class="line">            session = connection.createSession(false,Session.AUTO_ACKNOWLEDGE);   //不开启事务</div><div class="line"></div><div class="line">            destination = session.createQueue(&quot;Queue-zy&quot;);</div><div class="line">            messageProducer = session.createProducer(destination);</div><div class="line">            messageProducer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);       //是否持久化（默认持久化）</div><div class="line"></div><div class="line">            for(int i = 1; i&lt;11; i++)&#123;</div><div class="line">                System.out.println(&quot;生产者成功发出消息——Queue-zy：序号---&quot;+i);</div><div class="line">                TextMessage message = session.createTextMessage(&quot;消息-----&quot;+i+&quot;-------hello,MQ!&quot;);</div><div class="line">                messageProducer.send(message);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125; catch (JMSException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; finally&#123;</div><div class="line">            try &#123;</div><div class="line">                connection.close();</div><div class="line">            &#125; catch (JMSException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>控制台打印出发送消息成功的语句，总计10条消息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">生产者成功发出消息——Queue-zy：序号---1</div><div class="line">生产者成功发出消息——Queue-zy：序号---2</div><div class="line">生产者成功发出消息——Queue-zy：序号---3</div><div class="line">生产者成功发出消息——Queue-zy：序号---4</div><div class="line">生产者成功发出消息——Queue-zy：序号---5</div><div class="line">生产者成功发出消息——Queue-zy：序号---6</div><div class="line">生产者成功发出消息——Queue-zy：序号---7</div><div class="line">生产者成功发出消息——Queue-zy：序号---8</div><div class="line">生产者成功发出消息——Queue-zy：序号---9</div><div class="line">生产者成功发出消息——Queue-zy：序号---10</div></pre></td></tr></table></figure>
<p><img src="http://osuskkx7k.bkt.clouddn.com/Queue1%20%282%29.jpg" alt="image"><br>此时，打开ActiveMQ的管理页面，点击Queues，便可看到一个名为 Queue-zy 的队列：<br>Number Of Pending Messages ：表示等待被消费的消息数为 10  </p>
<p>Messages Enqueued：  表示进入队列的消息数为 10  （可叠加）</p>
<p>Messages Dequeued：  表示出队列的消息，此时为0  </p>
<h5 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">import org.apache.activemq.ActiveMQConnectionFactory;</div><div class="line">import javax.jms.*;</div><div class="line"></div><div class="line">public class Consumer &#123;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">        //连接工厂</div><div class="line">        ConnectionFactory connectionFactory;</div><div class="line">        //连接</div><div class="line">        Connection connection = null;</div><div class="line">        //会话</div><div class="line">        Session session;</div><div class="line">        //目的地</div><div class="line">        Destination destination;</div><div class="line">        //消息生产者</div><div class="line">        MessageConsumer messageConsumer ;</div><div class="line"></div><div class="line">        try &#123;</div><div class="line">            connectionFactory = new ActiveMQConnectionFactory(ActiveMQConnectionFactory.DEFAULT_USER,ActiveMQConnectionFactory.DEFAULT_PASSWORD,</div><div class="line">                    ActiveMQConnectionFactory.DEFAULT_BROKER_URL);</div><div class="line">            connection = connectionFactory.createConnection();</div><div class="line">            connection.start();</div><div class="line"></div><div class="line">            session = connection.createSession(false,Session.AUTO_ACKNOWLEDGE);</div><div class="line">            destination = session.createQueue(&quot;Queue-zy&quot;);</div><div class="line">            messageConsumer = session.createConsumer(destination);</div><div class="line"></div><div class="line">            while(true)&#123;</div><div class="line">                TextMessage textMessage = (TextMessage) messageConsumer.receive(10000);</div><div class="line">                if(textMessage != null)&#123;</div><div class="line">                    System.out.println(&quot;消费者成功接收到消息： &quot;+textMessage.getText());</div><div class="line">                &#125;else&#123;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; finally&#123;</div><div class="line">            try &#123;</div><div class="line">                connection.close();</div><div class="line">            &#125; catch (JMSException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>点击Run启动消费者Main()，可以看到控制台输出，成功接收10条消息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">消费者成功接收到消息： 消息-----1-------hello,MQ!</div><div class="line">消费者成功接收到消息： 消息-----2-------hello,MQ!</div><div class="line">消费者成功接收到消息： 消息-----3-------hello,MQ!</div><div class="line">消费者成功接收到消息： 消息-----4-------hello,MQ!</div><div class="line">消费者成功接收到消息： 消息-----5-------hello,MQ!</div><div class="line">消费者成功接收到消息： 消息-----6-------hello,MQ!</div><div class="line">消费者成功接收到消息： 消息-----7-------hello,MQ!</div><div class="line">消费者成功接收到消息： 消息-----8-------hello,MQ!</div><div class="line">消费者成功接收到消息： 消息-----9-------hello,MQ!</div><div class="line">消费者成功接收到消息： 消息-----10-------hello,MQ!</div></pre></td></tr></table></figure></p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/Queue-2.jpg" alt="image"></p>
<p>再次查看ActiveMQ的管理页面，点击Queues  </p>
<p>Number Of Pending Messages ：等待被消费的消息数变为 0，此时消息已经全部被消费  </p>
<p>Messages Enqueued： 进入队列的消息数为 10  （叠加）  </p>
<p>Messages Dequeued： 出队列的消息，此时为10  </p>
<h4 id="第二种方式（发布-订阅）——Topic"><a href="#第二种方式（发布-订阅）——Topic" class="headerlink" title="第二种方式（发布/订阅）——Topic"></a>第二种方式（发布/订阅）——Topic</h4><p><strong>两种方式的代码只有一处区别：由Session创建的目的地不同</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//Queue</div><div class="line">destination = session.createQueue(&quot;Queue-zy&quot;);</div><div class="line">//Topic</div><div class="line">destination = session.createTopic(&quot;Topic-zy&quot;);</div></pre></td></tr></table></figure>
<p>注意：<strong>先启动订阅者（消费者），再启动发布者（生产者）————因为在没有实现订阅消息持久化的情况下，只能在订阅者上线后才能接收到发布者发布的消息。</strong></p>
<h5 id="生产者-1"><a href="#生产者-1" class="headerlink" title="生产者"></a>生产者</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">import org.apache.activemq.ActiveMQConnectionFactory;</div><div class="line">import javax.jms.*;</div><div class="line"></div><div class="line">public class Producer &#123;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">        //连接工厂</div><div class="line">        ConnectionFactory connectionFactory;</div><div class="line">        //连接</div><div class="line">        Connection connection = null;</div><div class="line">        //会话</div><div class="line">        Session session;</div><div class="line">        //目的地</div><div class="line">        Destination destination;</div><div class="line">        //消息生产者</div><div class="line">        MessageProducer messageProducer;</div><div class="line"></div><div class="line">        try &#123;</div><div class="line">            connectionFactory = new ActiveMQConnectionFactory(ActiveMQConnectionFactory.DEFAULT_USER,ActiveMQConnectionFactory.DEFAULT_PASSWORD,</div><div class="line">                    ActiveMQConnectionFactory.DEFAULT_BROKER_URL);</div><div class="line">            connection = connectionFactory.createConnection();</div><div class="line">            connection.start();</div><div class="line">            session = connection.createSession(false,Session.AUTO_ACKNOWLEDGE);   //不开启事务</div><div class="line"></div><div class="line">            //destination = session.createQueue(&quot;Queue-zy&quot;);</div><div class="line">            destination = session.createTopic(&quot;Topic-zy&quot;);</div><div class="line">            messageProducer = session.createProducer(destination);</div><div class="line">            messageProducer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);       //是否持久化（默认持久化）</div><div class="line"></div><div class="line">            for(int i = 1; i&lt;11; i++)&#123;</div><div class="line">                System.out.println(&quot;生产者成功发出消息——Topic-zy：序号---&quot;+i);</div><div class="line">                TextMessage message = session.createTextMessage(&quot;消息-----&quot;+i+&quot;-------hello,MQ!&quot;);</div><div class="line">                messageProducer.send(message);</div><div class="line">            &#125;</div><div class="line">        &#125; catch (JMSException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; finally&#123;</div><div class="line">            try &#123;</div><div class="line">                connection.close();</div><div class="line">            &#125; catch (JMSException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="消费者-1"><a href="#消费者-1" class="headerlink" title="消费者 1"></a>消费者 1</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">import org.apache.activemq.ActiveMQConnectionFactory;</div><div class="line"></div><div class="line">import javax.jms.*;</div><div class="line"></div><div class="line">public class Consumer &#123;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">        //连接工厂</div><div class="line">        ConnectionFactory connectionFactory;</div><div class="line">        //连接</div><div class="line">        Connection connection = null;</div><div class="line">        //会话</div><div class="line">        Session session;</div><div class="line">        //目的地</div><div class="line">        Destination destination;</div><div class="line">        //消息生产者</div><div class="line">        MessageConsumer messageConsumer ;</div><div class="line"></div><div class="line">        try &#123;</div><div class="line">            connectionFactory = new ActiveMQConnectionFactory(ActiveMQConnectionFactory.DEFAULT_USER,ActiveMQConnectionFactory.DEFAULT_PASSWORD,</div><div class="line">                    ActiveMQConnectionFactory.DEFAULT_BROKER_URL);</div><div class="line">            connection = connectionFactory.createConnection();</div><div class="line">            connection.start();</div><div class="line">            session = connection.createSession(false,Session.AUTO_ACKNOWLEDGE);</div><div class="line"></div><div class="line">            //destination = session.createQueue(&quot;Queue-zy&quot;);</div><div class="line">            destination = session.createTopic(&quot;Topic-zy&quot;);</div><div class="line">            messageConsumer = session.createConsumer(destination);</div><div class="line"></div><div class="line">            while(true)&#123;</div><div class="line">                TextMessage textMessage = (TextMessage) messageConsumer.receive(10000);</div><div class="line">                if(textMessage != null)&#123;</div><div class="line">                    System.out.println(&quot;消费者 1 成功接收到消息： &quot;+textMessage.getText());</div><div class="line">                &#125;else&#123;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="消费者-2"><a href="#消费者-2" class="headerlink" title="消费者 2"></a>消费者 2</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">import org.apache.activemq.ActiveMQConnectionFactory;</div><div class="line">import javax.jms.*;</div><div class="line"></div><div class="line">public class Consumer2 &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">        //连接工厂</div><div class="line">        ConnectionFactory connectionFactory;</div><div class="line">        //连接</div><div class="line">        Connection connection = null;</div><div class="line">        //会话</div><div class="line">        Session session;</div><div class="line">        //目的地</div><div class="line">        Destination destination;</div><div class="line">        //消息生产者</div><div class="line">        MessageConsumer messageConsumer ;</div><div class="line"></div><div class="line">        try &#123;</div><div class="line">            connectionFactory = new ActiveMQConnectionFactory(ActiveMQConnectionFactory.DEFAULT_USER,ActiveMQConnectionFactory.DEFAULT_PASSWORD,</div><div class="line">                    ActiveMQConnectionFactory.DEFAULT_BROKER_URL);</div><div class="line">            connection = connectionFactory.createConnection();</div><div class="line">            connection.start();</div><div class="line">            session = connection.createSession(false,Session.AUTO_ACKNOWLEDGE);</div><div class="line"></div><div class="line">            //destination = session.createQueue(&quot;Queue-zy&quot;);</div><div class="line">            destination = session.createTopic(&quot;Topic-zy&quot;);</div><div class="line">            messageConsumer = session.createConsumer(destination);</div><div class="line"></div><div class="line">            while(true)&#123;</div><div class="line">                TextMessage textMessage = (TextMessage) messageConsumer.receive(10000);</div><div class="line">                if(textMessage != null)&#123;</div><div class="line">                    System.out.println(&quot;消费者 2 成功接收到消息： &quot;+textMessage.getText());</div><div class="line">                &#125;else&#123;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>先启动消费者 1 和 2，再启动生产者，可以看到控制台输出，消费者 1 、2都接收到了消息:</p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/c1.jpg" alt="image"></p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/c2.jpg" alt="image"></p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/Topic-2.jpg" alt="image"></p>
<p>查看ActiveMQ的管理页面，点击Topics，查看名为 Topic-zy 的主题：    </p>
<p>Number Of Consumers ：表示消费者数目为 2    </p>
<p>Messages Enqueued： 进入队列的消息数为 10    </p>
<p>Messages Dequeued： 出队列的消息，为20 （因为2个消费者） </p>
<p>以上就是直接使用 ActiveMQ 在<strong>点对点</strong>和<strong>发布订阅</strong> 两种模式下收发消息的过程。</p>
<p>下一篇，将介绍<a href="http://youngforzy.top/2018/02/15/ActiveMQ%E7%BB%93%E5%90%88Spring%E6%94%B6%E5%8F%91%E6%B6%88%E6%81%AF/" target="_blank" rel="external">ActiveMQ结合Spring收发消息</a>的过程。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;ActiveMQ的简单使用&quot;&gt;&lt;a href=&quot;#ActiveMQ的简单使用&quot; class=&quot;headerlink&quot; title=&quot;ActiveMQ的简单使用&quot;&gt;&lt;/a&gt;ActiveMQ的简单使用&lt;/h3&gt;&lt;p&gt;ActiveMQ 是一种消息队列，是Apache提供
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="ActiveMQ" scheme="http://yoursite.com/tags/ActiveMQ/"/>
    
      <category term="消息队列" scheme="http://yoursite.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Mysql自动还原脚本（.sh文件）</title>
    <link href="http://yoursite.com/2018/01/25/Mysql%E8%87%AA%E5%8A%A8%E8%BF%98%E5%8E%9F%E8%84%9A%E6%9C%AC/"/>
    <id>http://yoursite.com/2018/01/25/Mysql自动还原脚本/</id>
    <published>2018-01-25T07:12:12.000Z</published>
    <updated>2018-04-14T16:25:02.165Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Mysql自动还原脚本（-sh文件）"><a href="#Mysql自动还原脚本（-sh文件）" class="headerlink" title="Mysql自动还原脚本（.sh文件）"></a>Mysql自动还原脚本（.sh文件）</h3><h4 id="还原数据库的基本指令"><a href="#还原数据库的基本指令" class="headerlink" title="还原数据库的基本指令"></a>还原数据库的基本指令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">source d:/abc.sql</div></pre></td></tr></table></figure>
<p>当连接数据库之后，可以直接使用 以上命令来还原指定数据库。</p>
<h4 id="自动还原脚本"><a href="#自动还原脚本" class="headerlink" title="自动还原脚本"></a>自动还原脚本</h4><p>那么能不能使用脚本的方式自动还原呢？<br><strong>当每次都是还原同一个数据库，或者还原同一个数据库中的指定表时，便可以采用脚本的方式执行。</strong></p>
<p>当数据库备份文件存储在云端时，可采用以下脚本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">HOSTNAME = &quot;bd.gameplat2dev.w.qiyi.db&quot;         #数据库信息    </div><div class="line">PORT = &quot;1516&quot;                                  #端口</div><div class="line">USERNAME = &quot;username&quot;                          #用户名</div><div class="line">PASSWORD = &quot;123456&quot;                            #密码</div><div class="line"></div><div class="line">DBNAME = &quot;game_product&quot;                        #数据库名称</div><div class="line">#TABLENAME1 = &quot;t_approve&quot;                      #表名</div><div class="line">#TABLENAME2 = &quot;t_approve_role&quot;  </div><div class="line"></div><div class="line">#sql文件下载路径</div><div class="line">URL = &quot;http://osuskkx7k.bkt.clouddn.com/ab.sql&quot;</div><div class="line"></div><div class="line">#定义文件名（自定义）</div><div class="line">FILE = &quot;sqlfile.sql&quot;</div><div class="line"></div><div class="line">#下载sql文件</div><div class="line">wget $&#123;URL&#125; -O $&#123;FILE&#125;</div><div class="line"></div><div class="line">#输出(可无)</div><div class="line">echo $&#123;FILE&#125;</div><div class="line"></div><div class="line">#定义 source 命令</div><div class="line">restore_sql = &quot;source  $&#123;FILE&#125;&quot;</div><div class="line"></div><div class="line">#还原指令</div><div class="line">mysql -h$&#123;HOSTNAME&#125;  -P$&#123;PORT&#125;  -u$&#123;USERNAME&#125; -p$&#123;PASSWORD&#125; $&#123;DBNAME&#125; -e&quot;$&#123;restore_sql&#125;&quot;</div></pre></td></tr></table></figure>
<p><strong>记得另存为时，后缀是 .sh，双击即可运行</strong></p>
<h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><ul>
<li>若为本地数据库可将数据库名改为 localhost ，端口无需指定</li>
<li>脚本中 wget 工具需要安装</li>
<li>若sql文件不是存储云端，可直接指定路径</li>
<li>FILE文件名可自定义</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Mysql自动还原脚本（-sh文件）&quot;&gt;&lt;a href=&quot;#Mysql自动还原脚本（-sh文件）&quot; class=&quot;headerlink&quot; title=&quot;Mysql自动还原脚本（.sh文件）&quot;&gt;&lt;/a&gt;Mysql自动还原脚本（.sh文件）&lt;/h3&gt;&lt;h4 id=&quot;还
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Mysql" scheme="http://yoursite.com/tags/Mysql/"/>
    
      <category term="自动还原脚本" scheme="http://yoursite.com/tags/%E8%87%AA%E5%8A%A8%E8%BF%98%E5%8E%9F%E8%84%9A%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>Map 的4种遍历方式及比较</title>
    <link href="http://yoursite.com/2018/01/07/Map%20%E7%9A%844%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%E5%8F%8A%E6%AF%94%E8%BE%83/"/>
    <id>http://yoursite.com/2018/01/07/Map 的4种遍历方式及比较/</id>
    <published>2018-01-07T07:12:12.000Z</published>
    <updated>2018-04-14T16:37:56.168Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Map-的4种遍历方式及比较"><a href="#Map-的4种遍历方式及比较" class="headerlink" title="Map 的4种遍历方式及比较"></a>Map 的4种遍历方式及比较</h3><h4 id="KeySet"><a href="#KeySet" class="headerlink" title="KeySet"></a>KeySet</h4><p>第一种方式：   <strong>keySet 其实遍历了两次，第一次获取Iterator，第二次根据key获取value，因此性能较差。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public void testKetSet(Map&lt;String, String&gt; map) &#123;</div><div class="line">    Set&lt;String&gt; keys = map.keySet();</div><div class="line">    for (String key : keys) &#123;</div><div class="line">        String value =  map.get(key);</div><div class="line">        System.out.println(&quot;key: &quot;+ key + &quot;  value: &quot; + value );</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="EntrySet"><a href="#EntrySet" class="headerlink" title="EntrySet"></a>EntrySet</h4><p>第二种方式: <strong>entrySet 优于keySet，因为一次就把key和value放入了entry)</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public void testEntrySet(Map&lt;String, String&gt; map) &#123;</div><div class="line">      Set&lt;Map.Entry&lt;String, String&gt;&gt; entry = map.entrySet();</div><div class="line">      for (Map.Entry&lt;String, String&gt; stringEntry : entry) &#123;</div><div class="line">          System.out.println(&quot;key: &quot;+ stringEntry.getKey() + &quot;  value: &quot; + stringEntry.getValue());</div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<h4 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h4><p>第三种方式：<strong>Iterator （可用 it.remove()在遍历时删除）</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"> public void testIterator(Map&lt;String, String&gt; map) &#123;</div><div class="line">        Iterator&lt;Map.Entry&lt;String, String&gt;&gt; it = map.entrySet().iterator();</div><div class="line">        while (it.hasNext()) &#123;</div><div class="line">            Map.Entry&lt;String, String&gt; entry1 = it.next();</div><div class="line">            System.out.println(&quot;key: &quot;+ entry1.getKey() + &quot;  value: &quot; + entry1.getValue());</div><div class="line">//            if (&quot;1&quot;.equals(entry1.getKey())) &#123;</div><div class="line">//                it.remove();</div><div class="line">//            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h4 id="Lambda-（JDK8）"><a href="#Lambda-（JDK8）" class="headerlink" title="Lambda （JDK8）"></a>Lambda （JDK8）</h4><p>第四种方式：Lambda （<strong>本质是 entrySet</strong>）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public void testLambda(Map&lt;String, String&gt; map) &#123;</div><div class="line">       map.forEach((key, value) -&gt; &#123;</div><div class="line">           System.out.println(&quot;key: &quot;+ key + &quot;  value: &quot; + value );</div><div class="line">       &#125;);</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<h4 id="Values"><a href="#Values" class="headerlink" title="Values"></a>Values</h4><p>获取map所有的值，values()返回的是一个集合 <strong>Collection（可转List/Set）</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public void testValues(Map&lt;String, String&gt; map) &#123;</div><div class="line">       Collection&lt;String&gt; collection = map.values();</div><div class="line">       for (String s : collection) &#123;</div><div class="line">           System.out.println(&quot;value: &quot; + s);</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Map-的4种遍历方式及比较&quot;&gt;&lt;a href=&quot;#Map-的4种遍历方式及比较&quot; class=&quot;headerlink&quot; title=&quot;Map 的4种遍历方式及比较&quot;&gt;&lt;/a&gt;Map 的4种遍历方式及比较&lt;/h3&gt;&lt;h4 id=&quot;KeySet&quot;&gt;&lt;a href=&quot;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="HashMap" scheme="http://yoursite.com/tags/HashMap/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java(spring)实现Mysql的定时备份与还原</title>
    <link href="http://yoursite.com/2017/12/25/Java(spring)%E5%AE%9E%E7%8E%B0Mysql%E7%9A%84%E5%AE%9A%E6%97%B6%E5%A4%87%E4%BB%BD%E4%B8%8E%E8%BF%98%E5%8E%9F/"/>
    <id>http://yoursite.com/2017/12/25/Java(spring)实现Mysql的定时备份与还原/</id>
    <published>2017-12-25T11:23:12.000Z</published>
    <updated>2018-02-24T18:19:31.342Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、数据库的定时备份"><a href="#一、数据库的定时备份" class="headerlink" title="一、数据库的定时备份"></a>一、数据库的定时备份</h3><h4 id="备份命令"><a href="#备份命令" class="headerlink" title="备份命令"></a>备份命令</h4><p>Mysql的备份指令：</p>
<ol>
<li>指定数据库：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysqldump -h localhost -uroot -proot  tuser&gt;d:\user_2017-12-25_15-42-10.sql</div></pre></td></tr></table></figure>
</li>
</ol>
<p>tuser：数据库名<br>user_2017-12-25_15-42-10.sql：文件名</p>
<ol>
<li>指定数据库中的多个表：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysqldump -h localhost -uroot -proot --databases tuser --tables t_user t_user2&gt;d:\user_2017-12-25_15-42-two.sql</div></pre></td></tr></table></figure>
<p>在 –tables 之后加上所需备份的表名</p>
<h4 id="定时（Spring-Task）"><a href="#定时（Spring-Task）" class="headerlink" title="定时（Spring-Task）"></a>定时（Spring-Task）</h4><p>了解了mysql的备份命令，那么如何实现定时呢？<br><strong>这里采用Spring的定时任务来实现，基于注解的方式。</strong></p>
<p>主要有两点注意：</p>
<h5 id="1-Spring-xml中开启定时任务注解的配置："><a href="#1-Spring-xml中开启定时任务注解的配置：" class="headerlink" title="1. Spring.xml中开启定时任务注解的配置："></a>1. Spring.xml中开启定时任务注解的配置：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"> &lt;!--开启定时任务注解--&gt;</div><div class="line">&lt;task:annotation-driven /&gt;</div></pre></td></tr></table></figure>
<p>注意在头部引入task的标签及描述</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">xmlns:task=&quot;http://www.springframework.org/schema/task&quot;</div><div class="line">http://www.springframework.org/schema/task</div><div class="line">http://www.springframework.org/schema/task/spring-task-4.0.xsd</div></pre></td></tr></table></figure>
<h5 id="2-在相应的方法中添加注解-Scheduled"><a href="#2-在相应的方法中添加注解-Scheduled" class="headerlink" title="2.在相应的方法中添加注解@Scheduled"></a>2.在相应的方法中添加注解@Scheduled</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@Scheduled(cron=&quot;0/5 * *  * * ? &quot;)   //每5秒执行一次</div><div class="line">public void task1()&#123;</div><div class="line">    System.out.println(&quot;北京时间：&quot;+new Date());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意(cron=”0/5 <em> </em>  <em> </em> ? “)  表达式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">cron=&quot;0/5 * *  * * ? &quot;   表示每隔5s执行一次</div><div class="line">cron=&quot; * * 0/1 * * ? &quot;   表示每隔1小时执行一次</div><div class="line"></div><div class="line">关于cronExpression的配置可以百度</div></pre></td></tr></table></figure>
<p>对数据库  tuser  中的两张表 t_user 和 t_user2 进行备份:<br>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">//定时备份方案</div><div class="line">   @Scheduled(cron=&quot;0/5 * *  * * ? &quot;)   //每5秒执行一次  @Scheduled(cron=&quot; * * 0/1 * * ? &quot;) 每小时一次</div><div class="line">   public void back()&#123;</div><div class="line">       System.out.println(&quot;现在时间是&quot;+new Date());</div><div class="line">       Runtime runtime = Runtime.getRuntime();  //获取Runtime实例</div><div class="line">       String user = &quot;root&quot;;</div><div class="line">       String password = &quot;root&quot;;</div><div class="line">       String database1 = &quot;tuser&quot;; // 需要备份的数据库名</div><div class="line">       String table1 = &quot;t_user&quot;;</div><div class="line">       String table2 = &quot;t_user2&quot;;</div><div class="line">       Date currentDate = new Date();</div><div class="line">       SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd_HH-mm-ss&quot;);</div><div class="line">       String sdfDate = sdf.format(currentDate);</div><div class="line">       String filepath = &quot;d:\\time_&quot; + sdfDate + &quot;.sql&quot;; // 备份的路径地址</div><div class="line">       //执行命令</div><div class="line">       String stmt = &quot;mysqldump  -h localhost -u &quot;+user+&quot; -p&quot;+password+&quot; --databases &quot;+database1+&quot; --tables &quot;+table1+&quot; &quot;+table2 +&quot; &gt; &quot;+filepath;   </div><div class="line">       System.out.println(stmt);</div><div class="line">       try &#123;</div><div class="line">           String[] command = &#123; &quot;cmd&quot;, &quot;/c&quot;, stmt&#125;;</div><div class="line">           Process process = runtime.exec(command);</div><div class="line">           InputStream input = process.getInputStream();</div><div class="line">           System.out.println(IOUtils.toString(input, &quot;UTF-8&quot;));</div><div class="line">           //若有错误信息则输出</div><div class="line">           InputStream errorStream = process.getErrorStream();</div><div class="line">           System.out.println(IOUtils.toString(errorStream, &quot;UTF-8&quot;));</div><div class="line">       &#125; catch (IOException e) &#123;</div><div class="line">           e.printStackTrace();</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h3 id="二、数据库的还原"><a href="#二、数据库的还原" class="headerlink" title="二、数据库的还原"></a>二、数据库的还原</h3><h4 id="还原命令"><a href="#还原命令" class="headerlink" title="还原命令"></a>还原命令</h4><p>可以通过两种方式来进行还原操作。</p>
<h5 id="1-mysql-利用sql文件还原数据库"><a href="#1-mysql-利用sql文件还原数据库" class="headerlink" title="1. mysql 利用sql文件还原数据库"></a>1. mysql 利用sql文件还原数据库</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql -h localhost -uroot -proot tuser&lt; D:\user_2017-12-25_15-42-10.sql</div></pre></td></tr></table></figure>
<h5 id="2-source-命令"><a href="#2-source-命令" class="headerlink" title="2. source 命令"></a>2. source 命令</h5><p>这也是导入sql文件的方式，登录mysql之后，输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">source d:/game_product2018-01-02_10-41-30.sql</div></pre></td></tr></table></figure></p>
<p>注意反斜杠的方向，“source d:\ab.sql” 这样会执行失败。<br><strong>注：在Navicat中无法使用 source 命令</strong></p>
<h4 id="还原"><a href="#还原" class="headerlink" title="还原"></a>还原</h4><p>在代码中采用第一种方式实现还原操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public void restore() &#123;</div><div class="line">    String user = &quot;root&quot;;</div><div class="line">    String password = &quot;root&quot;;</div><div class="line">    String database = &quot;tuser&quot;; // 需要备份的数据库名</div><div class="line">    System.out.println(&quot;现在时间是&quot; + new Date());</div><div class="line">    Runtime runtime = Runtime.getRuntime();</div><div class="line"></div><div class="line">    String cmd = &quot;mysql  -h localhost&quot; + &quot; -u &quot; + user + &quot; -p&quot; + password + &quot; &quot; + database;</div><div class="line">    System.out.println(cmd);</div><div class="line">    try &#123;</div><div class="line">        String filePath =  &quot;D:\\user_2017-12-25_15-42-10.sql&quot;; // sql文件路径</div><div class="line">        String stmt = cmd + &quot; &lt; &quot; + filePath;</div><div class="line">        String[] command = &#123;&quot;cmd&quot;, &quot;/c&quot;, stmt&#125;;</div><div class="line">        Process process = runtime.exec(command);</div><div class="line">        //若有错误信息则输出</div><div class="line">        InputStream errorStream = process.getErrorStream();</div><div class="line">        System.out.println(IOUtils.toString(errorStream, &quot;utf-8&quot;));</div><div class="line">        //等待操作</div><div class="line">        int processComplete = process.waitFor();</div><div class="line">        if (processComplete == 0) &#123;</div><div class="line">            System.out.println(&quot;还原成功.&quot;);</div><div class="line">        &#125; else &#123;</div><div class="line">            throw new RuntimeException(&quot;还原数据库失败.&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125; catch (Exception e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、数据库的定时备份&quot;&gt;&lt;a href=&quot;#一、数据库的定时备份&quot; class=&quot;headerlink&quot; title=&quot;一、数据库的定时备份&quot;&gt;&lt;/a&gt;一、数据库的定时备份&lt;/h3&gt;&lt;h4 id=&quot;备份命令&quot;&gt;&lt;a href=&quot;#备份命令&quot; class=&quot;head
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="spring定时任务" scheme="http://yoursite.com/tags/spring%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    
      <category term="Mysql备份还原" scheme="http://yoursite.com/tags/Mysql%E5%A4%87%E4%BB%BD%E8%BF%98%E5%8E%9F/"/>
    
  </entry>
  
  <entry>
    <title>中缀表达式转后缀表达式（逆波兰）</title>
    <link href="http://yoursite.com/2017/12/18/%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E9%80%86%E6%B3%A2%E5%85%B0%EF%BC%89/"/>
    <id>http://yoursite.com/2017/12/18/中缀表达式转后缀表达式（逆波兰）/</id>
    <published>2017-12-18T11:23:12.000Z</published>
    <updated>2018-02-24T18:13:36.958Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、中缀表达式转后缀表达式"><a href="#一、中缀表达式转后缀表达式" class="headerlink" title="一、中缀表达式转后缀表达式"></a>一、中缀表达式转后缀表达式</h3><p>中缀表达式就是普通的表达式。如：9+（3-1）*3+10/2<br>后缀表达式是一种不需要括号的表示法，又叫逆波兰表达式。</p>
<p>上面的式子用后缀法表示：9 3 1 - 3 * + 10 2 / +</p>
<p>那么如何转化成后缀表达式？</p>
<h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>从左往右遍历：<br><strong>1. 如果是数字则直接输出</strong><br><strong>2. 如果是符号则入栈，但要通过以下判断</strong></p>
<ul>
<li><strong>若该符号c是右括号或者c的优先级≤栈顶符号，则栈中元素依次出栈输出，c入栈</strong></li>
</ul>
<p>代码实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line">//中缀转后缀表达式（逆波兰）------栈实现</div><div class="line">public class NiPoLan2 &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		//创建栈</div><div class="line">		Stack&lt;String&gt; s = new Stack&lt;String&gt;();</div><div class="line">		String s1 = &quot;9+(3-1)*3+10/2&quot;; 	//例子  (1-2)*(4+5)   9+(3-1)*3+10/2</div><div class="line">		char[] o = s1.toCharArray();</div><div class="line">		String r = &quot;&quot;;	//字符串r记录输出</div><div class="line">		//遍历</div><div class="line">		for(int i=0;i&lt;o.length;i++)&#123;</div><div class="line">		//符号是数字</div><div class="line">		if(Character.isDigit(o[i]))&#123;</div><div class="line">			//判断两位整数，如10</div><div class="line">			if(i&lt;o.length-1&amp;&amp;Character.isDigit(o[i+1]))&#123;</div><div class="line">				r = r+o[i]+o[i+1]+&quot; &quot;;</div><div class="line">				i++; //减少一次循环</div><div class="line">				continue;</div><div class="line">			&#125;</div><div class="line">			r = r+o[i]+&quot; &quot;;</div><div class="line">		&#125;</div><div class="line">		//符号是 (</div><div class="line">		if(o[i]==&apos;(&apos;)&#123;</div><div class="line">			s.push(o[i]+&quot;&quot;);</div><div class="line">		&#125;</div><div class="line">		//符号是+ or -</div><div class="line">		if(o[i]==&apos;+&apos;|o[i]==&apos;-&apos;)&#123;</div><div class="line">			//栈不为空，且有乘除符号，则弹出</div><div class="line">			if(!s.isEmpty()&amp;&amp;(s.peek().equals(&quot;*&quot;)|s.peek().equals(&quot;/&quot;)))&#123;</div><div class="line">				//全部出栈</div><div class="line">				while(!s.isEmpty())&#123;</div><div class="line">					r = r + s.pop()+&quot; &quot;;</div><div class="line">				&#125;</div><div class="line">				//出栈后，再将+-入栈</div><div class="line">				s.push(o[i]+&quot;&quot;);</div><div class="line">				//栈为空</div><div class="line">			&#125;else&#123;</div><div class="line">				s.push(o[i]+&quot;&quot;);</div><div class="line">				System.out.println(o[i]+&quot;&quot;);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		//符号是右括号则配对</div><div class="line">		if(o[i]==&apos;)&apos;)&#123;</div><div class="line">			String a = s.pop();</div><div class="line">			System.out.println(a);</div><div class="line">			r = r + a+&quot; &quot;;</div><div class="line">			s.pop();</div><div class="line">		&#125;</div><div class="line">		//符号是乘除</div><div class="line">		if(o[i]==&apos;*&apos;|o[i]==&apos;/&apos;)&#123;</div><div class="line">			System.out.println(s.peek());</div><div class="line">			//栈顶是加减、括号</div><div class="line">			if(s.isEmpty())&#123;</div><div class="line">				s.push(o[i]+&quot;&quot;);</div><div class="line">			&#125;else if(s.peek().equals(&quot;+&quot;)|s.peek().equals(&quot;-&quot;)|s.peek().equals(&quot;(&quot;))&#123;	//s.peek()==&quot;-&quot;|s.peek()==&quot;+&quot;|s.peek()==&quot;(&quot;</div><div class="line">				s.push(o[i]+&quot;&quot;);</div><div class="line">			&#125;</div><div class="line">		    //栈顶是乘除，则出栈</div><div class="line">			else if(s.peek()==&quot;*&quot;|s.peek()==&quot;/&quot;)&#123;</div><div class="line">				//全部出栈</div><div class="line">				while(!s.isEmpty())&#123;</div><div class="line">					r = r + s.pop();</div><div class="line">				&#125;</div><div class="line">				s.push(o[i]+&quot;&quot;);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		&#125;</div><div class="line">		//最后栈中不为空，全部出栈</div><div class="line">		while(!s.isEmpty())&#123;</div><div class="line">			r = r + s.pop()+&quot; &quot;; </div><div class="line">		&#125;</div><div class="line">		System.out.println(r);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">9 3 1 - 3 * + 10 2 / +</div></pre></td></tr></table></figure></p>
<h3 id="二、计算后缀表达式"><a href="#二、计算后缀表达式" class="headerlink" title="二、计算后缀表达式"></a>二、计算后缀表达式</h3><p>中缀表达式容易计算：9+（3-1）*3+10/2=20<br>那么后缀表达式如何计算呢？</p>
<p>还是上面的例子： 9 3 1 - 3 * + 10 2 / + </p>
<h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h4><p><strong>从左往右遍历：</strong>   </p>
<ol>
<li><strong>遇到数字就入栈</strong>  </li>
<li><strong>遇到符号就将栈顶的两个元素取出计算，将结果入栈；最后栈中的数就是最终结果</strong></li>
</ol>
<p>代码实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">public class NiPoLan &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		</div><div class="line">		Stack&lt;Integer&gt; s = new Stack&lt;Integer&gt;();</div><div class="line">		String s1 = &quot;9 3 1 - 3 * + 10 2 / +&quot;;</div><div class="line">		String[] r = s1.split(&quot; &quot;);				//转为字符串数组</div><div class="line">		System.out.println(s1);</div><div class="line">		for(int i=0;i&lt;r.length;i++)&#123;</div><div class="line">			//判断字符串r[i]是数字还是符号</div><div class="line">			//r[i]是数字，入栈</div><div class="line">			if(Character.isDigit(r[i].charAt(0)))&#123;</div><div class="line">				int c = Integer.valueOf(r[i]);</div><div class="line">				s.push(c);</div><div class="line">			&#125;else&#123;</div><div class="line">				//r[i]是符号，则运算</div><div class="line">				switch (r[i]) &#123;</div><div class="line">				case &quot;-&quot;:</div><div class="line">					int a = s.pop();  </div><div class="line">					int b = s.pop();  </div><div class="line">					s.push(b-a);</div><div class="line">					break;</div><div class="line">				case &quot;+&quot;:</div><div class="line">					 a = s.pop();  </div><div class="line">					 b = s.pop();  </div><div class="line">					s.push(b+a); </div><div class="line">					break;</div><div class="line">				case &quot;/&quot;:</div><div class="line">					 a = s.pop();  </div><div class="line">					 b = s.pop();  </div><div class="line">					s.push(b/a);</div><div class="line">			break;</div><div class="line">				case &quot;*&quot;:</div><div class="line">					 a = s.pop();  </div><div class="line">					 b = s.pop();  </div><div class="line">					s.push(b*a);</div><div class="line">			break;</div><div class="line">				default:</div><div class="line">					break;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">	&#125;</div><div class="line">		//输出结果</div><div class="line">		System.out.println(s.pop());</div><div class="line">	&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">9 3 1 - 3 * + 10 2 / +</div><div class="line">20</div></pre></td></tr></table></figure></p>
<p>结果为 20。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、中缀表达式转后缀表达式&quot;&gt;&lt;a href=&quot;#一、中缀表达式转后缀表达式&quot; class=&quot;headerlink&quot; title=&quot;一、中缀表达式转后缀表达式&quot;&gt;&lt;/a&gt;一、中缀表达式转后缀表达式&lt;/h3&gt;&lt;p&gt;中缀表达式就是普通的表达式。如：9+（3-1）*3+
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="逆波兰表达式" scheme="http://yoursite.com/tags/%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java并发工具类之Semaphore</title>
    <link href="http://yoursite.com/2017/12/12/Java%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%B9%8BSemaphore/"/>
    <id>http://yoursite.com/2017/12/12/Java并发工具类之Semaphore/</id>
    <published>2017-12-12T09:42:18.000Z</published>
    <updated>2018-02-24T18:08:10.476Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、Semaphore的概念"><a href="#一、Semaphore的概念" class="headerlink" title="一、Semaphore的概念"></a>一、Semaphore的概念</h3><p><strong>Semaphore又叫信号量，用来控制同时访问特定资源的线程数量</strong>。它通过协调各个线程，以保证合理地使用公共资源。</p>
<p><strong>Semaphore和CountDownLatch一样，也是维护了一个计数器，其本质是一个共享锁。</strong></p>
<p><strong>Semaphore有公平性和非公平性之分。</strong></p>
<p><strong>Semaphore的工作过程：</strong></p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/timg.jpg" alt="image">  </p>
<ol>
<li>当一个线程想要访问某个共享资源时，它必须要先获取Semaphore；</li>
<li>当Semaphore &gt; 0 时，获取该资源并使Semaphore – 1；</li>
<li>当Semaphore = 0，则表示全部的共享资源已经被其他线程全部占用，线程必须要等待其他线程释放资源；</li>
<li>当有线程释放资源时，Semaphore+1，其他线程可以争抢资源；</li>
</ol>
<h3 id="二、Semaphore的实现分析"><a href="#二、Semaphore的实现分析" class="headerlink" title="二、Semaphore的实现分析"></a>二、Semaphore的实现分析</h3><p>前面分析可知，<strong>Semaphore的实现是共享锁。</strong></p>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>Semaphore有两个构造函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public Semaphore(int permits) &#123;</div><div class="line">        sync = new NonfairSync(permits);</div><div class="line">    &#125;</div><div class="line">public Semaphore(int permits, boolean fair) &#123;</div><div class="line">    sync = fair ? new FairSync(permits) : new NonfairSync(permits);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>第一个构造函数中传入的是资源许可的数量，默认是非公平锁。<br>第二个构造函数传入资源许可的数量和一个boolean变量，该变量可实现公平锁。</p>
<p>Semaphore在使用时有两个主要方法，acquire()方法表示获取一个资源许可，而 release()方法表示释放一个资源许可。</p>
<h4 id="资源获取：acquire-方法"><a href="#资源获取：acquire-方法" class="headerlink" title="资源获取：acquire()方法"></a>资源获取：acquire()方法</h4><p>调用acquire()方法获取一个资源：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public void acquire() throws InterruptedException &#123;</div><div class="line">        sync.acquireSharedInterruptibly(1);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>该方法调用AQS的acquireSharedInterruptibly()方法，以共享的模式获取同步状态：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public final void acquireSharedInterruptibly(int arg)</div><div class="line">            throws InterruptedException &#123;</div><div class="line">        if (Thread.interrupted())</div><div class="line">            throw new InterruptedException();</div><div class="line">        if (tryAcquireShared(arg) &lt; 0)</div><div class="line">            doAcquireSharedInterruptibly(arg);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>然后调用tryAcquireShared()方法，该方法由Sync的子类来实现：</p>
<ul>
<li>如果是非公平模式，调用NonfairSync的tryAcquireShared()方法；</li>
<li>如果是公平模式，调用FairSync的tryAcquireShared()方法。</li>
</ul>
<p>在前面的文章 <a href="http://blog.csdn.net/babylove_bale/article/details/78317204" target="_blank" rel="external">ReentrantLock重入锁</a> 中有提到公平与非公平的实现。</p>
<p><strong>非公平模式</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">final int nonfairTryAcquireShared(int acquires) &#123;</div><div class="line">            for (;;) &#123;</div><div class="line">                int available = getState();</div><div class="line">                int remaining = available - acquires;</div><div class="line">                if (remaining &lt; 0 ||</div><div class="line">                    compareAndSetState(available, remaining))</div><div class="line">                    return remaining;</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p>
<p>remaining 表示剩余的资源许可，如果&lt; 0，表示目前没有剩余的许可。当前线程继续等待。如果remaining &gt;0 则执行CAS操作获取资源许可。</p>
<p><strong>公平模式</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">protected int tryAcquireShared(int acquires) &#123;</div><div class="line">            for (;;) &#123;</div><div class="line">                if (hasQueuedPredecessors())</div><div class="line">                    return -1;</div><div class="line">                int available = getState();</div><div class="line">                int remaining = available - acquires;</div><div class="line">                if (remaining &lt; 0 ||</div><div class="line">                    compareAndSetState(available, remaining))</div><div class="line">                    return remaining;</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p><strong>在公平模式的方法中，增加了一个判断，判断同步队列中是否有等待的线程：</strong></p>
<ul>
<li>有，则插入作为尾节点，线程阻塞；</li>
<li>没有，则参与资源竞争；</li>
</ul>
<p>简而言之，公平模式就是要按等待队列中的顺序获取资源许可。</p>
<h4 id="资源释放：release-方法"><a href="#资源释放：release-方法" class="headerlink" title="资源释放：release()方法"></a>资源释放：release()方法</h4><p>Semaphore调用release()方法释放资源许可，默认释放1个。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public void release() &#123;</div><div class="line">        sync.releaseShared(1);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>调用AQS的releaseShared()方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public final boolean releaseShared(int arg) &#123;</div><div class="line">        if (tryReleaseShared(arg)) &#123;</div><div class="line">            doReleaseShared();</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line">        return false;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>调用Sync中重写的tryReleaseShared()方法（<strong>公平与非公平都是调用该方法</strong>），<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">protected final boolean tryReleaseShared(int releases) &#123;</div><div class="line">            for (;;) &#123;</div><div class="line">                int current = getState();</div><div class="line">                int next = current + releases;</div><div class="line">                if (next &lt; current) // overflow</div><div class="line">                    throw new Error(&quot;Maximum permit count exceeded&quot;);</div><div class="line">                if (compareAndSetState(current, next))</div><div class="line">                    return true;</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p>
<p><strong>next代表如果许可释放成功，可用资源许可的数量。<br>这里可能有多个线程同时释放，因此利用CAS操作将资源许可数量置为next。<br>释放成功后，进入doReleaseShared()唤醒队列中等待的线程。</strong></p>
<p><strong>注：公平模式与非公平模式都是调用该release()方法。</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、Semaphore的概念&quot;&gt;&lt;a href=&quot;#一、Semaphore的概念&quot; class=&quot;headerlink&quot; title=&quot;一、Semaphore的概念&quot;&gt;&lt;/a&gt;一、Semaphore的概念&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Semaphore又叫信号量
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="Semaphore" scheme="http://yoursite.com/tags/Semaphore/"/>
    
  </entry>
  
  <entry>
    <title>Java并发工具类之CyclicBarrier</title>
    <link href="http://yoursite.com/2017/12/08/Java%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%B9%8BCyclicBarrier/"/>
    <id>http://yoursite.com/2017/12/08/Java并发工具类之CyclicBarrier/</id>
    <published>2017-12-08T10:42:18.000Z</published>
    <updated>2018-02-24T18:06:39.939Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、CyclicBarrier的概念"><a href="#一、CyclicBarrier的概念" class="headerlink" title="一、CyclicBarrier的概念"></a>一、CyclicBarrier的概念</h3><p>CyclicBarrier的意思是可循环使用的屏障。<strong>它可以让一组线程到达一个屏障时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有阻塞的线程才会继续执行。</strong></p>
<p>它就好像一道关卡，只有所有的部队（线程）都到了才能放行。</p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/cycle.png" alt="image"></p>
<h3 id="二、CyclicBarrier的实现分析"><a href="#二、CyclicBarrier的实现分析" class="headerlink" title="二、CyclicBarrier的实现分析"></a>二、CyclicBarrier的实现分析</h3><p><strong>部分源码：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class CyclicBarrier &#123;</div><div class="line">    </div><div class="line">    private final ReentrantLock lock = new ReentrantLock();</div><div class="line">    private final Condition trip = lock.newCondition();</div><div class="line">    private final int parties;</div><div class="line">    private final Runnable barrierCommand;</div><div class="line">    private Generation generation = new Generation();</div><div class="line">    private int count;</div><div class="line">    private static class Generation &#123;</div><div class="line">        boolean broken = false;</div><div class="line">    &#125;</div><div class="line">    ....</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到，<strong>CyclicBarrier是基于ReentrantLock和Condition实现的。</strong></p>
<ul>
<li>parties 表示拦截线程的数量</li>
<li>barrierCommand 表示所有线程到达屏障后优先执行的命令</li>
<li>Generation 表示屏障循环利用</li>
</ul>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>CyclicBarrier有两个构造函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public CyclicBarrier(int parties) &#123;</div><div class="line">        this(parties, null);</div><div class="line">    &#125;</div><div class="line">public CyclicBarrier(int parties, Runnable barrierAction) &#123;</div><div class="line">        if (parties &lt;= 0) throw new IllegalArgumentException();</div><div class="line">        this.parties = parties;</div><div class="line">        this.count = parties;</div><div class="line">        this.barrierCommand = barrierAction;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>第一个构造函数调用的其实也是第二个构造函数，只是第二个参数barrierAction为null。这个参数其实是一个线程任务命令，用于在所有线程到达屏障时，优先执行该线程任务，方便处理更加复杂的业务场景。</p>
<h4 id="await-方法："><a href="#await-方法：" class="headerlink" title="await()方法："></a>await()方法：</h4><p>每当一个线程调用await()方法表示该线程到达屏障，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public int await() throws InterruptedException, BrokenBarrierException &#123;</div><div class="line">        try &#123;</div><div class="line">            return dowait(false, 0L);</div><div class="line">        &#125; catch (TimeoutException toe) &#123;</div><div class="line">            throw new Error(toe); </div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>进入dowait()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line">private int dowait(boolean timed, long nanos)</div><div class="line">        throws InterruptedException, BrokenBarrierException,</div><div class="line">               TimeoutException &#123;</div><div class="line">        final ReentrantLock lock = this.lock;</div><div class="line">        lock.lock();</div><div class="line">        try &#123;</div><div class="line">            final Generation g = generation;</div><div class="line">            </div><div class="line">            //当前generation“已损坏”，抛出异常</div><div class="line">            if (g.broken)</div><div class="line">                throw new BrokenBarrierException();</div><div class="line">                </div><div class="line">            //如果线程中断，终止CyclicBarrier</div><div class="line">            if (Thread.interrupted()) &#123;</div><div class="line">                breakBarrier();</div><div class="line">                throw new InterruptedException();</div><div class="line">            &#125;</div><div class="line">            //每当线程进入，计数-1</div><div class="line">            int index = --count;</div><div class="line">            if (index == 0) &#123;  //计数为0时，进入</div><div class="line">                boolean ranAction = false;</div><div class="line">                try &#123;</div><div class="line">                    final Runnable command = barrierCommand;</div><div class="line">                    if (command != null)   //如果有barrierCommand，则优先执行该任务</div><div class="line">                        command.run();</div><div class="line">                    ranAction = true;</div><div class="line">                    nextGeneration();//唤醒所有等待线程，并更新generation</div><div class="line">                    return 0;</div><div class="line">                &#125; finally &#123;</div><div class="line">                    if (!ranAction)</div><div class="line">                        breakBarrier();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            // loop until tripped, broken, interrupted, or timed out</div><div class="line">            //自旋</div><div class="line">            for (;;) &#123;</div><div class="line">                try &#123;</div><div class="line">                    if (!timed)//如果不是超时等待，则调用Condition.await()方法等待</div><div class="line">                        trip.await();</div><div class="line">                    else if (nanos &gt; 0L)//超时等待，调用Condition.awaitNanos()方法等待</div><div class="line">                        nanos = trip.awaitNanos(nanos);</div><div class="line">                &#125; catch (InterruptedException ie) &#123;</div><div class="line">                    //如果等待过程中，线程被中断，则执行下面的函数。</div><div class="line">                    if (g == generation &amp;&amp; ! g.broken) &#123;</div><div class="line">                        breakBarrier();</div><div class="line">                        throw ie;</div><div class="line">                    &#125; else &#123;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                </div><div class="line">                //当前generation“已损坏”，抛出异常</div><div class="line">                if (g.broken)</div><div class="line">                    throw new BrokenBarrierException();</div><div class="line">                    </div><div class="line">                //generation已经更新，返回index</div><div class="line">                if (g != generation)</div><div class="line">                    return index;</div><div class="line"></div><div class="line">                //“超时等待”，并且时间已到,终止CyclicBarrier，并抛出异常</div><div class="line">                if (timed &amp;&amp; nanos &lt;= 0L) &#123;</div><div class="line">                    breakBarrier();</div><div class="line">                    throw new TimeoutException();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; finally &#123;</div><div class="line">            lock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>dowait()的主要处理逻辑如下：如果该线程不是到达的最后一个线程，则它会一直处于等待状态，除非发生以下情况：</p>
<ol>
<li>最后一个线程到达，即index == 0</li>
<li>超出了指定时间（超时等待）</li>
<li>其他的某个线程中断当前线程</li>
<li>其他的某个线程中断另一个等待的线程</li>
<li>其他的某个线程在等待barrier超时</li>
<li>其他的某个线程在此barrier调用reset()方法。reset()方法用于将屏障重置为初始状态。</li>
</ol>
<p>Generation对象描述着CyclicBarrier的更新换代。在CyclicBarrier中，同一批线程属于同一代。当有parties个线程到达barrier，generation就会被更新换代。</p>
<h3 id="三、CyclicBarrier与CountDownLatch的对比"><a href="#三、CyclicBarrier与CountDownLatch的对比" class="headerlink" title="三、CyclicBarrier与CountDownLatch的对比"></a>三、CyclicBarrier与CountDownLatch的对比</h3><p><strong>CyclicBarrier允许一系列线程相互等待对方到达屏障，先到达的线程被阻塞在屏障前，必须等到所有线程都到达了屏障，所有线程才能运行；CountDownLatch允许一个或多个线程等待一些特定的操作完成，而这些操作是在其它的线程中进行的，只有“被等的线程”的操作完成后，“等待的线程”才能执行；</strong></p>
<p><strong>CyclicBarrier强调的是n个线程互相等待，CountDownLatch强调的是1个线程或n个线程等待其他线程操作。</strong></p>
<p><strong>CyclicBarrier的计数器可以循环使用（出现错误可重置计数），CountDownLatch的计数器只能用一次；</strong></p>
<p><strong>CyclicBarrier可以在所有线程到达屏障后先执行一个线程任务，再运行所有线程，用于处理复杂的业务，CountDownLatch不可以。</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、CyclicBarrier的概念&quot;&gt;&lt;a href=&quot;#一、CyclicBarrier的概念&quot; class=&quot;headerlink&quot; title=&quot;一、CyclicBarrier的概念&quot;&gt;&lt;/a&gt;一、CyclicBarrier的概念&lt;/h3&gt;&lt;p&gt;Cyclic
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="CyclicBarrier" scheme="http://yoursite.com/tags/CyclicBarrier/"/>
    
  </entry>
  
  <entry>
    <title>Java并发工具类之CountDownLatch</title>
    <link href="http://yoursite.com/2017/12/03/Java%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%B9%8BCountDownLatch/"/>
    <id>http://yoursite.com/2017/12/03/Java并发工具类之CountDownLatch/</id>
    <published>2017-12-03T10:42:18.000Z</published>
    <updated>2018-02-24T18:04:34.623Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h3><p>CountDownLatch也叫闭锁，是并发包的工具类之一，允许一个或多个线程等待其他线程完成操作后再执行。</p>
<p>回忆之前，我们知道Join方法，用于让当前线程等待join的线程执行结束。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">while(isAlive())&#123;</div><div class="line">    wait(0);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其原理就是不停地检查join线程是否存活，如果存活则一直等待。<br>CountDownLatch也可以实现join的功能，且功能更多。  </p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/CountDownLatch.png" alt="image"></p>
<p>CountDownLatch是通过一个计数器来实现的，当new 一个CountDownLatch对象的时候需要传入该计数器值。<br>CountDownLatch有两个最主要的方法await()和countDown()。</p>
<p>当一个线程调用await()时会阻塞；每当一个其他线程完成自己的任务调用countDown()后，计数器的值就会减1。当计数器的值为0时，就表示所有的线程均已经完成了任务，然后阻塞的线程就可以继续执行了。</p>
<h3 id="二、实现分析"><a href="#二、实现分析" class="headerlink" title="二、实现分析"></a>二、实现分析</h3><p><strong>部分源码</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public class CountDownLatch &#123;</div><div class="line">    private final Sync sync;</div><div class="line">    //内部类Sync（继承AQS）</div><div class="line">    private static final class Sync extends AbstractQueuedSynchronizer &#123;</div><div class="line">        Sync(int count) &#123;</div><div class="line">            setState(count);</div><div class="line">        &#125;</div><div class="line">        //重写</div><div class="line">        protected int tryAcquireShared(int acquires) &#123;</div><div class="line">            return (getState() == 0) ? 1 : -1;</div><div class="line">        &#125;</div><div class="line">        protected boolean tryReleaseShared(int releases) &#123;</div><div class="line">            for (;;) &#123;</div><div class="line">                int c = getState();</div><div class="line">                if (c == 0)</div><div class="line">                    return false;</div><div class="line">                int nextc = c-1;</div><div class="line">                if (compareAndSetState(c, nextc))</div><div class="line">                    return nextc == 0;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    //构造方法</div><div class="line">     public CountDownLatch(int count) &#123;</div><div class="line">        if (count &lt; 0) throw new IllegalArgumentException(&quot;count &lt; 0&quot;);</div><div class="line">        this.sync = new Sync(count);</div><div class="line">    &#125;</div><div class="line">    ....</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到，CountDownLatch的实现同样依赖AQS，可见AQS作用之大。<br>观察Sync重写的方法（tryAcquireShared、tryReleaseShared），我们可以断定：<br><strong>CountDownLatch使用的是共享锁。</strong></p>
<h4 id="await-的实现"><a href="#await-的实现" class="headerlink" title="await()的实现"></a>await()的实现</h4><p>调用await()方法会阻塞当前线程，直到计数器为0或被中断。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public void await() throws InterruptedException &#123;</div><div class="line">        sync.acquireSharedInterruptibly(1);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>可以看到，其实调用了AQS的acquireSharedInterruptibly()方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public final void acquireSharedInterruptibly(int arg)</div><div class="line">            throws InterruptedException &#123;</div><div class="line">        if (Thread.interrupted())</div><div class="line">            throw new InterruptedException();</div><div class="line">        if (tryAcquireShared(arg) &lt; 0)</div><div class="line">            doAcquireSharedInterruptibly(arg);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>该方法中，如果线程被中断则抛出异常；否则尝试获取锁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">protected int tryAcquireShared(int acquires) &#123;</div><div class="line">            return (getState() == 0) ? 1 : -1;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>尝试获取锁时调用了Sync重写的tryAcquireShared()方法：<br>很简单只有一行代码，但却是CountDownLatch的原理：<strong>如果同步状态为0（计数器值为0）那么返回1，表示获取锁成功；否则返回-1，获取锁失败</strong>，并进入doAcquireSharedInterruptibly()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">private void doAcquireSharedInterruptibly(int arg)</div><div class="line">        throws InterruptedException &#123;</div><div class="line">        final Node node = addWaiter(Node.SHARED);</div><div class="line">        boolean failed = true;</div><div class="line">        try &#123;</div><div class="line">            for (;;) &#123;</div><div class="line">                final Node p = node.predecessor();</div><div class="line">                if (p == head) &#123;</div><div class="line">                    int r = tryAcquireShared(arg);</div><div class="line">                    //注意r只会等于 0 or -1；</div><div class="line">                    if (r &gt;= 0) &#123;</div><div class="line">                        setHeadAndPropagate(node, r);</div><div class="line">                        p.next = null; // help GC</div><div class="line">                        failed = false;</div><div class="line">                        return;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div class="line">                    parkAndCheckInterrupt())</div><div class="line">                    throw new InterruptedException();</div><div class="line">            &#125;</div><div class="line">        &#125; finally &#123;</div><div class="line">            if (failed)</div><div class="line">                cancelAcquire(node);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>该方法在前面共享锁的文章中有提到，它是一个自旋尝试获取锁的方法，这里不再赘述。<strong>注意18行的代码：int r = tryAcquireShared(arg)，在获取同步状态时只会返回两个值0和-1。</strong></p>
<h4 id="countDown-的实现"><a href="#countDown-的实现" class="headerlink" title="countDown()的实现"></a>countDown()的实现</h4><p>每次调用countDown()时，计数器的数量就会减1。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public void countDown() &#123;</div><div class="line">        sync.releaseShared(1);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>调用的是AQS的releaseShared()方法，释放同步状态：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public final boolean releaseShared(int arg) &#123;</div><div class="line">        if (tryReleaseShared(arg)) &#123;</div><div class="line">            doReleaseShared();</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line">        return false;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>进入releaseShared()方法，调用Sync重写的tryReleaseShared()方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">protected boolean tryReleaseShared(int releases) &#123;</div><div class="line">            for (;;) &#123;</div><div class="line">                int c = getState();</div><div class="line">                if (c == 0)</div><div class="line">                    return false;</div><div class="line">                int nextc = c-1;</div><div class="line">                if (compareAndSetState(c, nextc))</div><div class="line">                    return nextc == 0;</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p>
<p>可以看到，<strong>该方法自旋CAS操作释放同步状态（可能多个线程同时调用countDown()方法，所以用CAS保证原子性），计数器每次-1，但是直到同步状态为0（计数器为0）时，才返回true</strong>。然后进入doReleaseShared()方法，唤醒阻塞的线程，使其从await()方法退出。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>CountDownLatch的内部实现是共享锁。</strong></p>
<p><strong>创建CountDownLatch时，需要传入计数器的初始值，可以理解为共享锁的总次数。</strong><br><strong>当一个线程调用await()方法，会检查计数器的值，不为0则阻塞直到为0。<br>当其他线程调用countDown()方法时（可以一个线程调用多次），会释放共享状态，计数器-1。</strong><br><strong>当计数器减为0时，阻塞的线程才会运行。</strong></p>
<h3 id="三、应用场景"><a href="#三、应用场景" class="headerlink" title="三、应用场景"></a>三、应用场景</h3><p>CountDownLatch的应用场景：<strong>主线程等到N个子线程执行完毕之后，再继续往下执行。</strong> 如跑步比赛统计排名、启动程序等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">public class CountDownLatchDemo &#123;</div><div class="line">	</div><div class="line">	private CountDownLatch cd = new CountDownLatch(5);</div><div class="line">	/*</div><div class="line">	 * 飞船类</div><div class="line">	 */</div><div class="line">	 class Plane extends Thread&#123;</div><div class="line">		 @Override</div><div class="line">		public void run() &#123;</div><div class="line">			System.out.println(&quot;飞船准备就绪，倒计时5s：&quot;);</div><div class="line">			System.out.println(cd.getCount());//计数器的值</div><div class="line">			try &#123;</div><div class="line">				cd.await();</div><div class="line">			&#125; catch (InterruptedException e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">			System.out.println(&quot;飞船起飞啦！！！！&quot;);</div><div class="line">		&#125;</div><div class="line">	 &#125;</div><div class="line">	 /*</div><div class="line">	 * 倒计时类</div><div class="line">	 */</div><div class="line">	 class Time extends Thread&#123;</div><div class="line">		 @Override</div><div class="line">		public void run() &#123;</div><div class="line">			 for(int i=5;i&gt;0;i--)&#123;</div><div class="line">				 System.out.println(&quot;起飞倒计时：&quot;+i+&quot;s&quot;);</div><div class="line">				 cd.countDown();</div><div class="line">			 &#125;</div><div class="line">		&#125;</div><div class="line">	 &#125;</div><div class="line">	</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		CountDownLatchDemo cdemo = new CountDownLatchDemo();</div><div class="line">		Plane p = cdemo.new Plane();</div><div class="line">		p.start();</div><div class="line">		Time t = cdemo.new Time();</div><div class="line">		t.start();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">飞船准备就绪，倒计时5s：</div><div class="line">5</div><div class="line">起飞倒计时：5s</div><div class="line">起飞倒计时：4s</div><div class="line">起飞倒计时：3s</div><div class="line">起飞倒计时：2s</div><div class="line">起飞倒计时：1s</div><div class="line">飞船起飞啦！！！！</div></pre></td></tr></table></figure></p>
<p><strong>当调用CountDownLatch的countDown方法时，计数器N就会-1，无论是在多个线程调用，还是一个线程调用多次（上面的例子就是在一个线程中多次调用）。</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、概念&quot;&gt;&lt;a href=&quot;#一、概念&quot; class=&quot;headerlink&quot; title=&quot;一、概念&quot;&gt;&lt;/a&gt;一、概念&lt;/h3&gt;&lt;p&gt;CountDownLatch也叫闭锁，是并发包的工具类之一，允许一个或多个线程等待其他线程完成操作后再执行。&lt;/p&gt;
&lt;p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="CountDownLatch" scheme="http://yoursite.com/tags/CountDownLatch/"/>
    
  </entry>
  
  <entry>
    <title>Java并发之Condition的实现分析</title>
    <link href="http://yoursite.com/2017/12/01/Java%E5%B9%B6%E5%8F%91%E4%B9%8BCondition%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2017/12/01/Java并发之Condition的实现分析/</id>
    <published>2017-12-01T07:42:18.000Z</published>
    <updated>2018-02-24T18:01:24.796Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、Condition的概念"><a href="#一、Condition的概念" class="headerlink" title="一、Condition的概念"></a>一、Condition的概念</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>回忆synchronized关键字，它配合Object的wait()、notify()系列方法可以实现等待/通知模式。</p>
<p>对于Lock，通过Condition也可以实现等待/通知模式。</p>
<p>Condition是一个接口。<br>Condition接口的实现类是Lock（AQS）中的ConditionObject。<br>Lock接口中有个 newCondition()方法，通过这个方法可以获得Condition对象（其实就是ConditionObject）。<br>因此，<strong>通过Lock对象可以获得Condition对象。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Lock lock  = new ReentrantLock();</div><div class="line">Condition c1 = lock.newCondition();</div><div class="line">Condition c2 = lock.newCondition();</div></pre></td></tr></table></figure></p>
<h3 id="二、Condition的实现分析"><a href="#二、Condition的实现分析" class="headerlink" title="二、Condition的实现分析"></a>二、Condition的实现分析</h3><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>ConditionObject类是AQS的内部类，实现了Condition接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public class ConditionObject implements Condition, java.io.Serializable &#123;</div><div class="line">        private transient Node firstWaiter;</div><div class="line">        private transient Node lastWaiter;</div><div class="line">        ...</div></pre></td></tr></table></figure>
<p>可以看到，等待队列和同步队列一样，使用的都是同步器AQS中的节点类Node。<br>同样拥有首节点和尾节点，<br>每个Condition对象都包含着一个FIFO队列。<br>结构图：</p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/condition.jpg" alt="image"></p>
<h4 id="等待"><a href="#等待" class="headerlink" title="等待"></a>等待</h4><p>调用Condition的await()方法会使线程进入等待队列，并释放锁，线程状态变为等待状态。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public final void await() throws InterruptedException &#123;</div><div class="line">            if (Thread.interrupted())</div><div class="line">                throw new InterruptedException();</div><div class="line">            Node node = addConditionWaiter();</div><div class="line">            //释放同步状态（锁）</div><div class="line">            int savedState = fullyRelease(node);</div><div class="line">            int interruptMode = 0;</div><div class="line">            //判断节点是否放入同步对列</div><div class="line">            while (!isOnSyncQueue(node)) &#123;</div><div class="line">                //阻塞</div><div class="line">                LockSupport.park(this);</div><div class="line">                //如果已经中断了，则退出</div><div class="line">                if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)</div><div class="line">                    break;</div><div class="line">            &#125;</div><div class="line">            if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</div><div class="line">                interruptMode = REINTERRUPT;</div><div class="line">            if (node.nextWaiter != null) // clean up if cancelled</div><div class="line">                unlinkCancelledWaiters();</div><div class="line">            if (interruptMode != 0)</div><div class="line">                reportInterruptAfterWait(interruptMode);</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p>
<p>分析上述方法的大概过程：</p>
<ol>
<li>将当前线程创建为节点，加入等待队列</li>
<li>释放锁，唤醒同步队列中的后继节点</li>
<li>while循环判断节点是否放入同步队列：</li>
</ol>
<ul>
<li>没有放入，则阻塞，继续while循环（如果已经中断了，则退出）</li>
<li>放入，则退出while循环，执行后面的判断</li>
</ul>
<ol>
<li>退出while说明节点已经在同步队列中，调用acquireQueued()方法加入同步状态竞争。</li>
<li>竞争到锁后从await()方法返回，即退出该方法。  </li>
</ol>
<p><img src="http://osuskkx7k.bkt.clouddn.com/enterCon.png" alt="image"></p>
<p><strong>addConditionWaiter()方法：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">private Node addConditionWaiter() &#123;</div><div class="line">            Node t = lastWaiter;</div><div class="line">            if (t != null &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</div><div class="line">                //清除条件队列中所有状态不为Condition的节点</div><div class="line">                unlinkCancelledWaiters();</div><div class="line">                t = lastWaiter;</div><div class="line">            &#125;</div><div class="line">            //将该线程创建节点，放入等待队列</div><div class="line">            Node node = new Node(Thread.currentThread(), Node.CONDITION);</div><div class="line">            if (t == null)</div><div class="line">                firstWaiter = node;</div><div class="line">            else</div><div class="line">                t.nextWaiter = node;</div><div class="line">            lastWaiter = node;</div><div class="line">            return node;</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p>
<p>过程分析：同步队列的首节点移动到等待队列。加入尾节点之前会清除所有状态不为Condition的节点。</p>
<hr>
<h4 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h4><p>调用Condition的signal()方法，可以唤醒等待队列的首节点（等待时间最长），唤醒之前会将该节点移动到同步队列中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public final void signal() &#123;</div><div class="line">            //判断是否获取了锁</div><div class="line">            if (!isHeldExclusively())</div><div class="line">                throw new IllegalMonitorStateException();</div><div class="line">            Node first = firstWaiter;</div><div class="line">            if (first != null)</div><div class="line">                doSignal(first);</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>过程：</p>
<ol>
<li>先判断当前线程是否获取了锁</li>
<li>然后对首节点调用doSignal()方法</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">private void doSignal(Node first) &#123;</div><div class="line">            do &#123;</div><div class="line">                if ( (firstWaiter = first.nextWaiter) == null)</div><div class="line">                    lastWaiter = null;</div><div class="line">                first.nextWaiter = null;</div><div class="line">            &#125; while (!transferForSignal(first) &amp;&amp;</div><div class="line">                     (first = firstWaiter) != null);</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>过程：</p>
<ol>
<li>修改首节点</li>
<li>调用transferForSignal()方法将节点移动到同步队列</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">final boolean transferForSignal(Node node) &#123;</div><div class="line">        //将节点状态变为0   </div><div class="line">        if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))</div><div class="line">            return false;</div><div class="line">        //将该节点加入同步队列</div><div class="line">        Node p = enq(node);</div><div class="line">        int ws = p.waitStatus;</div><div class="line">        //如果结点p的状态为cancel 或者修改waitStatus失败，则直接唤醒</div><div class="line">        if (ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</div><div class="line">            LockSupport.unpark(node.thread);</div><div class="line">        return true;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>调用同步器的enq方法，将节点移动到同步队列，<br>满足条件后使用LockSupport唤醒该线程。  </p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/signalcon.png" alt="image"></p>
<hr>
<p>当Condition调用signalAll()方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public final void signalAll() &#123;</div><div class="line">            if (!isHeldExclusively())</div><div class="line">                throw new IllegalMonitorStateException();</div><div class="line">            Node first = firstWaiter;</div><div class="line">            if (first != null)</div><div class="line">                doSignalAll(first);</div><div class="line">        &#125;</div><div class="line">private void doSignalAll(Node first) &#123;</div><div class="line">            lastWaiter = firstWaiter = null;</div><div class="line">            do &#123;</div><div class="line">                Node next = first.nextWaiter;</div><div class="line">                first.nextWaiter = null;</div><div class="line">                transferForSignal(first);</div><div class="line">                first = next;</div><div class="line">            &#125; while (first != null);</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p>
<p>可以看到doSignalAll()方法使用了do-while循环来唤醒每一个等待队列中的节点，直到first为null时，停止循环。</p>
<p>一句话总结signalAll()的作用：<strong>将等待队列中的全部节点移动到同步队列中，并唤醒每个节点的线程。</strong></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>整个过程可以分为三步：</p>
<p>第一步：一个线程获取锁后，通过调用Condition的await()方法，会将当前线程先加入到等待队列中，并释放锁。然后就在await()中的一个while循环中判断节点是否已经在同步队列，是则尝试获取锁，否则一直阻塞。</p>
<p>第二步：当线程调用signal()方法后，程序首先检查当前线程是否获取了锁，然后通过doSignal(Node first)方法将节点移动到同步队列，并唤醒节点中的线程。</p>
<p>第三步：被唤醒的线程，将从await()中的while循环中退出来，然后调用acquireQueued()方法竞争同步状态。竞争成功则退出await()方法，继续执行。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、Condition的概念&quot;&gt;&lt;a href=&quot;#一、Condition的概念&quot; class=&quot;headerlink&quot; title=&quot;一、Condition的概念&quot;&gt;&lt;/a&gt;一、Condition的概念&lt;/h3&gt;&lt;h4 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="Condition" scheme="http://yoursite.com/tags/Condition/"/>
    
  </entry>
  
  <entry>
    <title>Java并发之Executor框架</title>
    <link href="http://yoursite.com/2017/11/22/Java%E5%B9%B6%E5%8F%91%E4%B9%8BExecutor%E6%A1%86%E6%9E%B6/"/>
    <id>http://yoursite.com/2017/11/22/Java并发之Executor框架/</id>
    <published>2017-11-22T08:42:18.000Z</published>
    <updated>2018-02-24T17:54:29.392Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、Executor框架的介绍"><a href="#一、Executor框架的介绍" class="headerlink" title="一、Executor框架的介绍"></a>一、Executor框架的介绍</h3><p>Java中的线程既是工作单元又是执行机制。JDK1.5开始，把工作单元与执行机制分离开来。<strong>工作单元为Runnable（Thread实现该接口）和Callable，执行机制就是Executor框架。</strong> 使用Executor框架时不用显式的创建线程Thread。</p>
<p>Executor框架由三部分组成：  </p>
<ul>
<li><strong>任务</strong>：Runnable或Callable  </li>
<li><strong>任务的执行</strong>：ExecutorService接口及其实现。  </li>
<li><strong>异步计算的结果</strong>：Future接口或其实现类FutureTask</li>
</ul>
<h4 id="Executor的结构"><a href="#Executor的结构" class="headerlink" title="Executor的结构"></a>Executor的结构</h4><p><img src="http://osuskkx7k.bkt.clouddn.com/Executor1.png" alt="image"></p>
<h4 id="Executor接口"><a href="#Executor接口" class="headerlink" title="Executor接口"></a><strong>Executor接口</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Executor &#123;</div><div class="line">        void execute(Runnable command);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>Executor接口中只有一个execute()方法，用来执行已经提交的Runnable实例，可见即使是Callable实例，最后也会被封装成Runnable来执行。</strong></p>
<h4 id="ExecutorService接口"><a href="#ExecutorService接口" class="headerlink" title="ExecutorService接口"></a><strong>ExecutorService接口</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public interface ExecutorService extends Executor &#123;</div><div class="line">        void shutdown();</div><div class="line">        List&lt;Runnable&gt; shutdownNow();</div><div class="line">        &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);</div><div class="line">        &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);</div><div class="line">        Future&lt;?&gt; submit(Runnable task);</div><div class="line">        ....</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><strong>ExecutorService扩展了Executor接口，添加了许多方法用于服务、管理和关闭线程池。</strong><br>submit()方法最终执行时也是调用了execute()方法。</p>
<p>ExecutorService接口有两个实现类，ThreadPoolExecutor（核心）和ScheduledThreadPoolExecutor（定时执行）。</p>
<h4 id="Executors工具类"><a href="#Executors工具类" class="headerlink" title="Executors工具类"></a><strong>Executors工具类</strong></h4><p><strong>Executors工具类中包含了许多静态工厂方法。采用了多方法静态工厂模式。</strong> 本质是根据不同的输入创建出不同类型的对象。</p>
<p>通过Executors工具类可以创建3种类型的线程池，即3种ThreadPoolExecutor对象。实质是创建ThreadPoolExecutor时传入的参数不同。</p>
<h3 id="二、3种常用线程池"><a href="#二、3种常用线程池" class="headerlink" title="二、3种常用线程池"></a>二、3种常用线程池</h3><h4 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h4><p><strong>FixedThreadPool是固定大小的线程池。内部线程可重用。</strong><br>Executors工具类中的静态方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</div><div class="line">        return new ThreadPoolExecutor(nThreads, nThreads,</div><div class="line">                                      0L, TimeUnit.MILLISECONDS,</div><div class="line">                                      new LinkedBlockingQueue&lt;Runnable&gt;());</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p><strong>特点</strong>：</p>
<ol>
<li>参数corePoolSize和maximumPoolSize大小都是nThreads，说明最大线程数就是核心线程数，所以线程大小固定</li>
<li>参数keepAliveTime为0L，说明不会有空闲的线程</li>
<li>参数BlockingQueue是无界队列LinkedBlockingQueue，说明任务会一直放入，不会采用饱和策略。</li>
</ol>
<p><strong>应用场景</strong>：需要限制线程数量，适用于负载较重的服务器</p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/fixed.png" alt="image"></p>
<p><strong>工作过程</strong>：</p>
<ol>
<li>当前线程数小于corePoolSize，创建新线程执行任务</li>
<li>当前线程数等于corePoolSize，任务加入阻塞队列</li>
<li>线程反复执行阻塞队列中的任务</li>
</ol>
<h4 id="SingleThreadExecutor"><a href="#SingleThreadExecutor" class="headerlink" title="SingleThreadExecutor"></a>SingleThreadExecutor</h4><p><strong>SingleThreadExecutor是只有一个线程的线程池。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public static ExecutorService newSingleThreadExecutor() &#123;</div><div class="line">        return new FinalizableDelegatedExecutorService</div><div class="line">            (new ThreadPoolExecutor(1, 1,</div><div class="line">                                    0L, TimeUnit.MILLISECONDS,</div><div class="line">                                    new LinkedBlockingQueue&lt;Runnable&gt;()));</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><strong>特点</strong>：</p>
<ol>
<li>参数corePoolSize和maximumPoolSize大小都是1，说明线程数固定为1</li>
<li>参数keepAliveTime为0L，说明不会有空闲的线程</li>
<li>参数BlockingQueue是无界队列LinkedBlockingQueue，说明任务会一直放入，不会采用饱和策略。</li>
</ol>
<p><strong>应用场景</strong>：<strong>适用于执行的任务需要保证顺序；并且在任意时间点，不会有多个线程是活动的场景。</strong></p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/single1.png" alt="image"></p>
<p><strong>工作过程</strong>：</p>
<ol>
<li>当前线程数小于1，创建一个唯一的线程执行任务</li>
<li>当前线程数等于1，任务加入阻塞队列</li>
<li>这个唯一的线程反复执行阻塞队列中的任务</li>
</ol>
<h4 id="CachedThreadPool"><a href="#CachedThreadPool" class="headerlink" title="CachedThreadPool"></a>CachedThreadPool</h4><p><strong>CachedThreadPool是一个根据需要创建线程的线程池。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public static ExecutorService newCachedThreadPool() &#123;</div><div class="line">        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</div><div class="line">                                      60L, TimeUnit.SECONDS,</div><div class="line">                                      new SynchronousQueue&lt;Runnable&gt;());</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><strong>特点</strong>：</p>
<ol>
<li>参数corePoolSize为0，maximumPoolSize为Integer.MAX_VALUE（2147483647），说明可创建的线程数巨大，且都是可销毁的</li>
<li>参数keepAliveTime为60L，说明空闲的线程等待时间最长60s</li>
<li>参数BlockingQueue是一个没有容量的阻塞队列SynchronousQueue，说明任务会一直被线程执行。</li>
</ol>
<p><strong>应用场景</strong>：<strong>大小无界的线程池，适用于执行很多的短期异步任务的小程序，或者负载较轻的服务器。<br>注：使用时需控制并发的任务数，否则创建大量的线程可能导致严重的性能问题。</strong></p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/cached1.png" alt="image"></p>
<p><strong>工作过程</strong>：</p>
<ol>
<li>首先执行SynchronousQueue.offer()，如果有空闲的线程在执行SynchronousQueue.poll()，表示配对成功，任务交给空闲线程执行。</li>
<li>初始化时，如果没有空闲的线程，那么创建一个新的线程执行任务。</li>
<li>步骤2中的线程任务完成后，会执行SynchronousQueue.poll()等待60s，若没有任务提交，则该空闲线程销毁。</li>
</ol>
<p>SynchronousQueue队列的每个插入操作都要等待一个移除操作，因此是没有容量的队列。</p>
<hr>
<p>除上述3种常用线程池外，Executors还可以创建以下几种线程池。</p>
<p><strong>newScheduledThreadPool</strong>：可以定时或周期性执行任务的线程池（线程数目指定）</p>
<p><strong>newSingleThreadScheduledExecutor：</strong> 可以定时或周期性执行任务的线程池。只有一个线程。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、Executor框架的介绍&quot;&gt;&lt;a href=&quot;#一、Executor框架的介绍&quot; class=&quot;headerlink&quot; title=&quot;一、Executor框架的介绍&quot;&gt;&lt;/a&gt;一、Executor框架的介绍&lt;/h3&gt;&lt;p&gt;Java中的线程既是工作单元又是执行
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="Executor框架" scheme="http://yoursite.com/tags/Executor%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Java线程池的实现分析</title>
    <link href="http://yoursite.com/2017/11/18/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2017/11/18/Java线程池的实现分析/</id>
    <published>2017-11-18T12:42:18.000Z</published>
    <updated>2018-02-24T17:52:30.529Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、线程池的介绍"><a href="#一、线程池的介绍" class="headerlink" title="一、线程池的介绍"></a>一、线程池的介绍</h3><p>线程池是一种并发框架。</p>
<p>优势：</p>
<ol>
<li><strong>降低资源消耗。</strong>（重复利用线程，减少开销）</li>
<li><strong>提高响应速度。</strong>（任务到达可直接执行，不需要等待创建线程）</li>
<li><strong>提高线程的可管理性</strong>。（统一分配、监控、调优）</li>
</ol>
<p><strong>ThreadPoolExecutor是线程池的核心实现类</strong>。可以通过ThreadPoolExecutor来创建一个线程池。</p>
<h3 id="二、线程池的实现分析"><a href="#二、线程池的实现分析" class="headerlink" title="二、线程池的实现分析"></a>二、线程池的实现分析</h3><p>线程池的实现是ThreadPoolExecutor类，因此重点描述ThreadPoolExecutor类的实现。  </p>
<h4 id="ThreadPoolExecutor的结构"><a href="#ThreadPoolExecutor的结构" class="headerlink" title="ThreadPoolExecutor的结构"></a>ThreadPoolExecutor的结构</h4><p>ThreadPoolExecutor的构造方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public ThreadPoolExecutor(int corePoolSize,</div><div class="line">                              int maximumPoolSize,</div><div class="line">                              long keepAliveTime,</div><div class="line">                              TimeUnit unit,</div><div class="line">                              BlockingQueue&lt;Runnable&gt; workQueue,</div><div class="line">                              ThreadFactory threadFactory,</div><div class="line">                              RejectedExecutionHandler handler) &#123;</div><div class="line">        ...(省略部分)</div><div class="line">        this.corePoolSize = corePoolSize;</div><div class="line">        this.maximumPoolSize = maximumPoolSize;</div><div class="line">        this.workQueue = workQueue;</div><div class="line">        this.keepAliveTime = unit.toNanos(keepAliveTime);</div><div class="line">        this.threadFactory = threadFactory;</div><div class="line">        this.handler = handler;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>构造函数中省略了部分判断的代码。<br>主要有7个参数：  </p>
<p><strong>corePoolSize</strong>：核心线程池的大小  </p>
<p><strong>maximumPoolSize</strong>：线程池的大小  </p>
<p><strong>keepAliveTime</strong>：存活时间（超过核心数目的线程空闲后的存活时间）  </p>
<p><strong>TimeUnit</strong>：时间单位  </p>
<p><strong>BlockingQueue<runnable></runnable></strong>：任务队列（保存等待任务的阻塞队列）  </p>
<p><strong>ThreadFactory</strong>：创建线程的工厂类   </p>
<p><strong>RejectedExecutionHandler</strong> ：饱和策略（拒绝策略）</p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/%E7%BA%BF%E7%A8%8B%E6%B1%A0.png" alt="image"></p>
<h4 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h4><p>当提交一个新任务时，线程池的工作过程：</p>
<ol>
<li><p><strong>判断核心线程池（corePool）中的线程是否都在执行任务。如果不是，创建一个新的线程执行任务。核心线程池已满，进入2</strong>；  </p>
</li>
<li><p><strong>判断任务队列是否已满。未满，则将新的任务存入；满了，进入3；</strong></p>
</li>
<li><strong>判断线程池（maximumPoolSize）里的线程是否都在工作。如果没有，创建一个新的线程执行任务；否则，交给饱和策略4</strong>；</li>
<li><strong>根据不同的饱和策略处理这个任务</strong>。</li>
</ol>
<p><img src="http://osuskkx7k.bkt.clouddn.com/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B.png" alt="image"></p>
<p>饱和策略有4种：</p>
<ul>
<li><strong>AbortPolicy（默认）</strong>：直接抛出异常</li>
<li><strong>CallerRunsPolicy</strong>：只用调用者所在线程来处理</li>
<li><strong>DiscardOldestPolicy</strong>：丢弃任务队列中最后一个任务，执行当前任务</li>
<li><strong>DiscardPolicy</strong>：不处理丢弃掉</li>
</ul>
<p>线程池回收线程时，对所谓的“核心线程”和“非核心线程”是一视同仁的，直到线程池中线程的数量等于corePoolSize参数时，回收过程才会停止。<br>如果设置的corePoolSize参数和maximumPoolSize参数一致时，线程池在任何情况下都不会回收空闲线程。keepAliveTime和timeUnit也就失去了意义。<br>可以调用以下方法回收核心线程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">threadPoolExecutor.allowCoreThreadTimeOut(true);</div></pre></td></tr></table></figure></p>
<h4 id="线程池处理任务"><a href="#线程池处理任务" class="headerlink" title="线程池处理任务"></a>线程池处理任务</h4><p>线程池处理任务的方法主要有两种，execute()和submit()。</p>
<p><strong>execute()</strong>  </p>
<p><strong>execute()方法用于提交不需要返回值的任务</strong>，Runnable实例。所以无法判断任务是否被线程池执行成功。</p>
<p><strong>submit()</strong><br><strong>submit()方法用于提交需要返回值的任务</strong>。线程池会返回一个future类型的对象，通过这个对象可以判断任务是否执行成功。</p>
<p>future的get()方法会阻塞当前线程直到任务完成，返回结果。</p>
<p>submit()最终调用的也是execute(Runnable runable)，submit()只是将Callable或Runnable封装成一个FutureTask对象，因为FutureTask是个Runnable，所以调用的是execute()方法。</p>
<h4 id="线程池的关闭"><a href="#线程池的关闭" class="headerlink" title="线程池的关闭"></a>线程池的关闭</h4><p>线程池关闭的方法主要有两种，shutdown()和shutdownNow()。</p>
<p><strong>原理</strong>：遍历线程池中的工作线程，逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法停止。</p>
<p><strong>区别</strong>：<br><strong>shutdown()只是将线程池的状态设置成SHUTDOWN状态，然后中断没有在执行任务的线程。</strong></p>
<p><strong>shutdownNow()首先将线程池的状态设置成STOP，然后尝试停止所有正在执行或暂停任务的线程，并返回等待执行任务的列表。</strong></p>
<p>如果任务不一定要执行完，可以调用shutdownNow()方法。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、线程池的介绍&quot;&gt;&lt;a href=&quot;#一、线程池的介绍&quot; class=&quot;headerlink&quot; title=&quot;一、线程池的介绍&quot;&gt;&lt;/a&gt;一、线程池的介绍&lt;/h3&gt;&lt;p&gt;线程池是一种并发框架。&lt;/p&gt;
&lt;p&gt;优势：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;降低
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="Java线程池" scheme="http://yoursite.com/tags/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>ConcurrentHashMap在JDK1.8中的实现分析</title>
    <link href="http://yoursite.com/2017/11/10/ConcurrentHashMap%E5%9C%A8JDK1.8%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2017/11/10/ConcurrentHashMap在JDK1.8中的实现分析/</id>
    <published>2017-11-10T08:42:18.000Z</published>
    <updated>2018-02-24T17:40:51.020Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、ConcurrentHashMap的介绍"><a href="#一、ConcurrentHashMap的介绍" class="headerlink" title="一、ConcurrentHashMap的介绍"></a>一、ConcurrentHashMap的介绍</h3><p><strong>ConcurrentHashMap在JDK8中进行了巨大改动，它舍弃了锁分段的技术，大量引入了CAS操作，以此来实现并发操作。</strong>   </p>
<p>回忆JDK1.7中的ConcurrentHashmap，当hash碰撞频繁时，链表长度会拉长，而链表的增改删查操作都会消耗很长的时间，影响性能，因此和JDK1.8中的HashMap一样，当链表过长时，将其结构转化为红黑树，由此提高性能。</p>
<h3 id="二、ConcurrentHashMap的实现原理"><a href="#二、ConcurrentHashMap的实现原理" class="headerlink" title="二、ConcurrentHashMap的实现原理"></a>二、ConcurrentHashMap的实现原理</h3><p><strong>ConcurrentHashMap的结构图</strong></p>
<p>ConcurrentHashMap在JDK1.8的实现原理是“<strong>数组+链表+红黑树</strong>”。（与HashMap在1.8中的实现思想一致，但是<strong>红黑树的节点不同</strong>，HashMap是Node节点，ConcurrentHashMap是TreeBin对象）</p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/1.8hash.PNG" alt="image"></p>
<hr>
<p>下面介绍一下ConcurrentHashMap主要方法put()和get()的实现。</p>
<h4 id="put-方法"><a href="#put-方法" class="headerlink" title="put()方法"></a>put()方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line">final V putVal(K key, V value, boolean onlyIfAbsent) &#123;</div><div class="line">---第一部分</div><div class="line">        if (key == null || value == null) throw new NullPointerException();</div><div class="line">        //计算hash值</div><div class="line">        int hash = spread(key.hashCode());</div><div class="line">        int binCount = 0;</div><div class="line">        for (Node&lt;K,V&gt;[] tab = table;;) &#123;</div><div class="line">            Node&lt;K,V&gt; f; int n, i, fh;</div><div class="line">            //如果tab为null，则初始化</div><div class="line">            if (tab == null || (n = tab.length) == 0)</div><div class="line">                tab = initTable();</div><div class="line">            //判断数组索引位置的元素是否为null</div><div class="line">            else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123;</div><div class="line">                //CAS操作设置该数组索引位置为新节点Node</div><div class="line">                if (casTabAt(tab, i, null,</div><div class="line">                             new Node&lt;K,V&gt;(hash, key, value, null)))</div><div class="line">                    break;                   // no lock when adding to empty bin</div><div class="line">            &#125;</div><div class="line">            //f节点是MOVED节点，表示有其他线程在扩容，帮助一起扩容</div><div class="line">            else if ((fh = f.hash) == MOVED)</div><div class="line">                tab = helpTransfer(tab, f);</div><div class="line">                </div><div class="line">---第二部分-----</div><div class="line">            else &#123;</div><div class="line">                V oldVal = null;</div><div class="line">                synchronized (f) &#123;</div><div class="line">                    if (tabAt(tab, i) == f) &#123;</div><div class="line">                        //表示是链表，还未转化成红黑树</div><div class="line">                        if (fh &gt;= 0) &#123;</div><div class="line">                            binCount = 1;</div><div class="line">                            for (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</div><div class="line">                                K ek;</div><div class="line">                                //如果key已存在，则替换value</div><div class="line">                                if (e.hash == hash &amp;&amp;</div><div class="line">                                    ((ek = e.key) == key ||</div><div class="line">                                     (ek != null &amp;&amp; key.equals(ek)))) &#123;</div><div class="line">                                    oldVal = e.val;</div><div class="line">                                    if (!onlyIfAbsent)</div><div class="line">                                        e.val = value;</div><div class="line">                                    break;</div><div class="line">                                &#125;</div><div class="line">                                Node&lt;K,V&gt; pred = e;</div><div class="line">                                //将新的节点插入尾部</div><div class="line">                                if ((e = e.next) == null) &#123;</div><div class="line">                                    pred.next = new Node&lt;K,V&gt;(hash, key,</div><div class="line">                                                              value, null);</div><div class="line">                                    break;</div><div class="line">                                &#125;</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                        //节点f是TreeBin对象，表示链表转为了红黑树</div><div class="line">                        else if (f instanceof TreeBin) &#123;</div><div class="line">                            Node&lt;K,V&gt; p;</div><div class="line">                            binCount = 2;</div><div class="line">                            if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</div><div class="line">                                                           value)) != null) &#123;</div><div class="line">                                oldVal = p.val;</div><div class="line">                                if (!onlyIfAbsent)</div><div class="line">                                    p.val = value;</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                if (binCount != 0) &#123;</div><div class="line">                    //如果大于8，转化为红黑树</div><div class="line">                    if (binCount &gt;= TREEIFY_THRESHOLD)</div><div class="line">                        treeifyBin(tab, i);</div><div class="line">                    if (oldVal != null)</div><div class="line">                        return oldVal;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        addCount(1L, binCount);</div><div class="line">        return null;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>由于整个put()方法较长，分成两部分来分析。<br><strong>第一部分：</strong></p>
<ol>
<li>遍历数组tab，如果为null，初始化数组；</li>
<li><strong>调用tabAt()方法查找数组索引i处的节点f，如果f为null，说明该位置还没有节点，调用casTabAt()利用CAS操作插入新的节点</strong></li>
</ol>
<ul>
<li><strong>CAS成功</strong>：break跳出，直到最后的addCount(1L, binCount)方法，判断插入这一个节点后是否需要扩容; </li>
<li><strong>CAS失败</strong>：说明有其它线程提前插入了节点，自旋重新尝试在这个位置插入节点；<br>tabAt()和casTabAt()方法源码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"> private static final sun.misc.Unsafe U;</div><div class="line"> </div><div class="line">static final &lt;K,V&gt; Node&lt;K,V&gt; tabAt(Node&lt;K,V&gt;[] tab, int i) &#123;</div><div class="line">        return (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((long)i &lt;&lt; ASHIFT) + ABASE);</div><div class="line">    &#125;</div><div class="line">static final &lt;K,V&gt; boolean casTabAt(Node&lt;K,V&gt;[] tab, int i,</div><div class="line">                                        Node&lt;K,V&gt; c, Node&lt;K,V&gt; v) &#123;</div><div class="line">        return U.compareAndSwapObject(tab, ((long)i &lt;&lt; ASHIFT) + ABASE, c, v);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>可以看到，都是<strong>调用Unsafe类的方法（原子性），Unsafe.getObjectVolatile可以直接获取指定内存的数据，保证了每次拿到数据都是最新的。</strong></p>
<ol>
<li><strong>若前面的情况都不满足，判断f节点是否为MOVED节点，是则表示有其他线程在扩容，帮助一起扩容</strong>；否则进入第二部分。  </li>
</ol>
<p><strong>第二部分：</strong>  </p>
<p>第二部分表示把新的节点Node插入链表或红黑树，可以看到使用了synchronized关键字实现同步。<strong>但是注意，只在节点f上进行同步，表示只能有一个线程访问该节点。</strong> 节点插入之前，再次利用 tabAt(tab, i) == f 判断头节点是否还是f，防止被其它线程修改。</p>
<ol>
<li>如果f.hash &gt;= 0，说明f是链表结构的头结点，遍历链表，如果key已存在，则修改value，否则在链表尾部插入节点。</li>
<li>如果f是TreeBin类型节点，说明链表变成红黑树，则在树结构上遍历元素，更新或增加节点。</li>
<li>最后判断链表中的节点数binCount &gt;= 8，则转化为红黑树。</li>
</ol>
<hr>
<h4 id="get-方法"><a href="#get-方法" class="headerlink" title="get()方法"></a>get()方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public V get(Object key) &#123;</div><div class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek;</div><div class="line">        //获取key的hash值</div><div class="line">        int h = spread(key.hashCode());</div><div class="line">        if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</div><div class="line">            (e = tabAt(tab, (n - 1) &amp; h)) != null) &#123;</div><div class="line">            if ((eh = e.hash) == h) &#123;</div><div class="line">                if ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))</div><div class="line">                    return e.val;</div><div class="line">            &#125;</div><div class="line">            else if (eh &lt; 0)</div><div class="line">                return (p = e.find(h, key)) != null ? p.val : null;</div><div class="line">            //遍历    </div><div class="line">            while ((e = e.next) != null) &#123;</div><div class="line">                if (e.hash == h &amp;&amp;</div><div class="line">                    ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek))))</div><div class="line">                    return e.val;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return null;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ol>
<li>如果table为null或者遍历之后没找到对应的value，返回null；</li>
<li>根据key的hash值找到table中指定的Node节点，遍历链表或红黑树找到对应的value值。<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4></li>
</ol>
<p>最后总结一下<strong>ConcurrentHashMap从JDK1.7（1.6）到JDK1.8的变化</strong>：</p>
<ol>
<li><strong>底层结构改变</strong>，从“<strong>数组+数组+链表</strong>”到“<strong>数组+链表+红黑树</strong>”</li>
<li><strong>锁方式改变，取消了Segment重入锁，变成CAS+Synchronized实现锁</strong></li>
<li><strong>锁粒度变小</strong>，<strong>由Segment数组变成table的元素</strong>。</li>
<li>JDK1.8中size()实现更简单</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、ConcurrentHashMap的介绍&quot;&gt;&lt;a href=&quot;#一、ConcurrentHashMap的介绍&quot; class=&quot;headerlink&quot; title=&quot;一、ConcurrentHashMap的介绍&quot;&gt;&lt;/a&gt;一、ConcurrentHashMap的
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="ConcurrentHashMap" scheme="http://yoursite.com/tags/ConcurrentHashMap/"/>
    
      <category term="JDK1.8" scheme="http://yoursite.com/tags/JDK1-8/"/>
    
  </entry>
  
  <entry>
    <title>ConcurrentHashMap在JDK1.7中的实现分析</title>
    <link href="http://yoursite.com/2017/11/06/ConcurrentHashMap%E5%9C%A8JDK1.7%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2017/11/06/ConcurrentHashMap在JDK1.7中的实现分析/</id>
    <published>2017-11-06T09:48:18.000Z</published>
    <updated>2018-02-24T17:36:40.387Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、ConcurrentHashMap的介绍"><a href="#一、ConcurrentHashMap的介绍" class="headerlink" title="一、ConcurrentHashMap的介绍"></a>一、ConcurrentHashMap的介绍</h3><p>ConcurrentHashMap是线程安全且高效的HashMap，可以在多线程的环境下使用。<br><strong>ConcurrentHashMap允许多个线程并发访问，其关键在于使用了锁分段技术。</strong><br>锁分段：首先将数据分成一段一段地存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个数据段的时候，其他数据段也能被其他线程访问。</p>
<h3 id="二、ConcurrentHashMap的实现原理"><a href="#二、ConcurrentHashMap的实现原理" class="headerlink" title="二、ConcurrentHashMap的实现原理"></a>二、ConcurrentHashMap的实现原理</h3><p><strong>ConcurrentHashMap的结构图</strong>  </p>
<p>ConcurrentHashMap在JDK1.8之前的实现原理是“<strong>数组+数组+链表</strong>”。（可能描述不妥）<br><img src="http://osuskkx7k.bkt.clouddn.com/concurrentHashmap.PNG" alt="image"></p>
<p>第一个数组是Segment[ ]，每一个Segment类似于HashMap；<br>第二个数组是HashEntry[ ]，每个元素可能是一个链表；<br>链表是HashEntry形成的链表，HashEntry是一个节点。</p>
<hr>
<h4 id="HashEntry类"><a href="#HashEntry类" class="headerlink" title="HashEntry类"></a>HashEntry类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">static final class HashEntry&lt;K,V&gt; &#123;</div><div class="line">        final int hash;</div><div class="line">        final K key;</div><div class="line">        volatile V value;</div><div class="line">        volatile HashEntry&lt;K,V&gt; next;</div><div class="line">        ....</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>HashEntry类相当于HashMap中的Entry类（节点类），储存了key和value，并拥有指向下一个元素的引用next。<br>注：<strong>value采用volatile修饰，保证了线程之间的可见性</strong>。</p>
<h4 id="Segment类"><a href="#Segment类" class="headerlink" title="Segment类"></a>Segment类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">static final class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable &#123;</div><div class="line"></div><div class="line">        transient volatile HashEntry&lt;K,V&gt;[] table;</div><div class="line">        transient int count;</div><div class="line">        transient int modCount;</div><div class="line">        transient int threshold;</div><div class="line">        final float loadFactor; </div><div class="line">        ....</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>每个Segment都拥有一个HashEntry[]数组，还有threshold和loadFactor分别表示极限容量和负载因子，count表示元素个数，modCount表示修改的记录。如此看来，<strong>每个Segment就好比是一个缩小版的HashMap</strong>，从上面ConcurrentHashMap结构图也可以看出来。</p>
<p><strong>Segment继承自ReentrantLock重入锁，因此它支持一个线程重进入同一个Segment，访问其中的数据。</strong></p>
<hr>
<p>下面介绍一下ConcurrentHashMap主要的几个方法的实现:put()方法、get()方法、size()方法</p>
<h4 id="put-方法"><a href="#put-方法" class="headerlink" title="put()方法"></a>put()方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public V put(K key, V value) &#123;</div><div class="line">        Segment&lt;K,V&gt; s;</div><div class="line">        if (value == null)</div><div class="line">            throw new NullPointerException();</div><div class="line">        int hash = hash(key);</div><div class="line">        int j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</div><div class="line">        if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject</div><div class="line">             (segments, (j &lt;&lt; SSHIFT) + SBASE)) == null) </div><div class="line">            // 扩容 </div><div class="line">            s = ensureSegment(j);</div><div class="line">        return s.put(key, hash, value, false);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>首先定位到相应的Segment。<br>如果需要扩容则进入ensureSegment(j)方法，<strong>注意ConcurrentHashMap不会对整个容器扩容，而只对当前的Segment进行扩容。</strong>  扩容为原来的2倍。<br>如果不需要扩容，调用Segment中的put()方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">final V put(K key, int hash, V value, boolean onlyIfAbsent) &#123;</div><div class="line">            HashEntry&lt;K,V&gt; node = tryLock() ? null :</div><div class="line">                scanAndLockForPut(key, hash, value);</div><div class="line">            V oldValue;</div><div class="line">            try &#123;</div><div class="line">                HashEntry&lt;K,V&gt;[] tab = table;</div><div class="line">                int index = (tab.length - 1) &amp; hash;</div><div class="line">                //取出头节点</div><div class="line">                HashEntry&lt;K,V&gt; first = entryAt(tab, index);</div><div class="line">                //遍历链表</div><div class="line">                for (HashEntry&lt;K,V&gt; e = first;;) &#123;</div><div class="line">                    if (e != null) &#123;</div><div class="line">                        K k;</div><div class="line">                        //key已存在，替换value</div><div class="line">                        if ((k = e.key) == key ||</div><div class="line">                            (e.hash == hash &amp;&amp; key.equals(k))) &#123;</div><div class="line">                            oldValue = e.value;</div><div class="line">                            if (!onlyIfAbsent) &#123;</div><div class="line">                                e.value = value;</div><div class="line">                                ++modCount;</div><div class="line">                            &#125;</div><div class="line">                            break;</div><div class="line">                        &#125;</div><div class="line">                        e = e.next;</div><div class="line">                    &#125;</div><div class="line">                    else &#123;</div><div class="line">                        //scanAndLockForPut()方法中已经返回了node，设置为first节点</div><div class="line">                        if (node != null)</div><div class="line">                            node.setNext(first);</div><div class="line">                        else</div><div class="line">                            //新建HashEntry节点作为头节点first</div><div class="line">                            node = new HashEntry&lt;K,V&gt;(hash, key, value, first);</div><div class="line">                        int c = count + 1;</div><div class="line">                        //判断是否扩容</div><div class="line">                        if (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</div><div class="line">                            rehash(node);</div><div class="line">                        else</div><div class="line">                            setEntryAt(tab, index, node);</div><div class="line">                        ++modCount; //记录修改次数</div><div class="line">                        count = c;  //修改count值</div><div class="line">                        oldValue = null;</div><div class="line">                        break;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125; finally &#123;</div><div class="line">                unlock();</div><div class="line">            &#125;</div><div class="line">            return oldValue;</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p>
<p>过程分析：  </p>
<ol>
<li>首先调用tryLock()方法尝试获取锁，如果获取失败，则进入scanAndLockForPut()方法，该方法实际上是先自旋一定的次数等待其他线程释放锁。若自旋过程中，其他线程释放了锁，导致本线程直接获得了锁，就避免了本线程进入等待锁的场景，提高了效率。若自旋一定次数后，仍未获取锁，则调用lock方法进入等待锁的场景。（这是JDK1.7的实现，如果是1.6则没有自旋，直接获取锁）</li>
<li>获取锁成功，找到对应的链表作相应的操作。具体见代码注释。</li>
</ol>
<h4 id="get-方法"><a href="#get-方法" class="headerlink" title="get()方法"></a>get()方法</h4><p>get()方法不需要锁。<strong>因为value字段是volatile修饰，保证了线程之间的可见性，可以被多线程同时读，但只能被单线程写。一句话，get操作只需要读共享变量value，所以不用加锁。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public V get(Object key) &#123;</div><div class="line">        Segment&lt;K,V&gt; s; // manually integrate access methods to reduce overhead</div><div class="line">        HashEntry&lt;K,V&gt;[] tab;</div><div class="line">        int h = hash(key); //第一次散列</div><div class="line">        //第二次散列</div><div class="line">        long u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</div><div class="line">        if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != null &amp;&amp;</div><div class="line">            (tab = s.table) != null) &#123;</div><div class="line">            //第三次散列（for循环中）</div><div class="line">            //遍历链表</div><div class="line">            for (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile</div><div class="line">                     (tab, ((long)(((tab.length - 1) &amp; h)) &lt;&lt; TSHIFT) + TBASE);</div><div class="line">                 e != null; e = e.next) &#123;</div><div class="line">                K k;</div><div class="line">                if ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))</div><div class="line">                    return e.value;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return null;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>（get()方法中用到了许多UNSAFE类的方法，这是在JDK1.6中没有的，主要是利用Native方法来快速的定位元素。）  </p>
<p>get()的过程经过了三次散列：  </p>
<p><strong>第一次：对key进行散列得到h<br>第二次：对h进行散列定位到哪个Segment<br>第三次：对h进行散列定位到哪个HashEntry</strong> </p>
<p>定位到HashEntry之后就对该链表遍历，查找key对应的value，若没有找到则返回null。  </p>
<h4 id="size-方法"><a href="#size-方法" class="headerlink" title="size()方法"></a>size()方法</h4><p><strong>size()方法需要跨Segment操作，因为要统计每个Segment中的count值。而count值是volatile变量，一般来说将所有的count变量相加就可以得到整个ConcurrentHashMap的大小。</strong> 但可能在累加前使用的count发生了变化，那么结果就不正确。那么该如何统计呢？</p>
<ol>
<li>第一种方法，将所有Segment的put、remove、clean方法都锁住，然后统计count值。做法可行，但是低效。</li>
<li><strong>第二种方法，先尝试连续2次不通过锁住Segment的方式计算各个count值的和：</strong></li>
</ol>
<ul>
<li>若没有发生变化，则作为size的大小。</li>
<li>若发生变化说明有线程在操作元素，则锁住Segment统计所有的count值。</li>
</ul>
<p><strong>如何判断容器大小没有发生变化？</strong>   </p>
<p><strong>modCount变量。这个变量记录了每个Segment中put、remove、clean等操作的次数，因此在连续两次统计count的值时，比较modCount是否变化，就可得知容器大小是否变化。</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、ConcurrentHashMap的介绍&quot;&gt;&lt;a href=&quot;#一、ConcurrentHashMap的介绍&quot; class=&quot;headerlink&quot; title=&quot;一、ConcurrentHashMap的介绍&quot;&gt;&lt;/a&gt;一、ConcurrentHashMap的
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="ConcurrentHashMap" scheme="http://yoursite.com/tags/ConcurrentHashMap/"/>
    
      <category term="JDK1.7" scheme="http://yoursite.com/tags/JDK1-7/"/>
    
  </entry>
  
  <entry>
    <title>HashMap引发的线程安全问题</title>
    <link href="http://yoursite.com/2017/11/03/HashMap%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2017/11/03/HashMap引发的线程安全问题/</id>
    <published>2017-11-03T09:48:18.000Z</published>
    <updated>2018-02-24T17:48:06.945Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、线程安全性"><a href="#一、线程安全性" class="headerlink" title="一、线程安全性"></a>一、线程安全性</h3><p>我们知道，HashMap是非线程安全的，只能在单线程的情况下使用。那么为什么不能在并发的情况下使用呢？<strong>因为在并发时，HashMap的扩容会产生错误而形成环形链表，导致读取数据时发生死循环</strong>。</p>
<p>回忆前面描述的扩容过程，调用了transfer()方法将旧链表转化为新链表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">void transfer(Entry[] newTable) &#123;  </div><div class="line">    Entry[] src = table;  </div><div class="line">    int newCapacity = newTable.length;  </div><div class="line">    for (int j = 0; j &lt; src.length; j++) &#123;  </div><div class="line">        Entry&lt;K,V&gt; e = src[j];  </div><div class="line">        if (e != null) &#123;  </div><div class="line">            src[j] = null;  </div><div class="line">            do &#123;  </div><div class="line">                Entry&lt;K,V&gt; next = e.next;  </div><div class="line">                int i = indexFor(e.hash, newCapacity);  </div><div class="line">                e.next = newTable[i];  </div><div class="line">                newTable[i] = e;  </div><div class="line">                e = next;  </div><div class="line">            &#125; while (e != null);  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>关键代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">do &#123;  </div><div class="line">Entry&lt;K,V&gt; next = e.next;  </div><div class="line">int i = indexFor(e.hash, newCapacity);  </div><div class="line">e.next = newTable[i];  </div><div class="line">newTable[i] = e;  </div><div class="line">e = next;  </div><div class="line">&#125; while (e != null);</div></pre></td></tr></table></figure>
<p>循环操作将旧链表中的节点放入新链表，直到下一个节点next为null。<br>分别在单线程和多线程的环境下描述扩容过程。</p>
<h4 id="单线程扩容"><a href="#单线程扩容" class="headerlink" title="单线程扩容"></a>单线程扩容</h4><p>假设hash数组的大小为2，负载因子为1，即超过1×2=2个元素时扩容，添加3个元素5、7、3，数组大小扩大为4，扩容过程如下：</p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/h1.png?imageView2/2/w/900/h/450" alt="image"></p>
<p>原链表中3个元素，循环3次，具体如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">第一次循环</div><div class="line">e = 3,next = 7</div><div class="line">3.next = tab[i] = null  (此时数组tab[i]为空)</div><div class="line">tab[i] = 3</div><div class="line">e = 7 </div><div class="line"></div><div class="line">第二次循环</div><div class="line">e = 7,next = 5</div><div class="line">7.next = tab[i] = 3</div><div class="line">tab[i] = 7</div><div class="line">e = 5</div><div class="line"></div><div class="line">第三次循环</div><div class="line">e = 5,next = null</div><div class="line">5.next = tab[i2] = null  (此时数组tab[i2]为空)</div><div class="line">tab[i2] = 5</div><div class="line">e = null </div><div class="line"></div><div class="line">(停止循环)</div></pre></td></tr></table></figure></p>
<h4 id="多线程扩容"><a href="#多线程扩容" class="headerlink" title="多线程扩容"></a>多线程扩容</h4><p>为什么多线程环境下扩容会形成环形链表呢？<br>还是刚刚的例子，两个线程并发执行，线程1在进入do循环的第一行挂起，线程2继续执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">do &#123;  </div><div class="line">    Entry&lt;K,V&gt; next = e.next;  //线程1在此处挂起</div><div class="line">    int i = indexFor(e.hash, newCapacity);  </div><div class="line">    e.next = newTable[i];  </div><div class="line">    newTable[i] = e;  </div><div class="line">    e = next;  </div><div class="line">    &#125; while (e != null);</div></pre></td></tr></table></figure>
<p>由前面单线程的情况可知，线程2此时成功扩容，结果如下：</p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/h2.png" alt="image"></p>
<p>线程1恢复执行，已知线程1的 e 指向了key(3)，而next指向了key(7)，扩容过程如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">第一次循环</div><div class="line">e = 3,next = 7</div><div class="line">3.next = tab[i] = null  (此时数组tab[i]为空)</div><div class="line">tab[i] = 3</div><div class="line">e = 7 </div><div class="line"></div><div class="line">第二次循环</div><div class="line">e = 7,next = 3</div><div class="line">7.next = tab[i] = 3</div><div class="line">tab[i] = 7</div><div class="line">e = 3</div><div class="line"></div><div class="line">第三次循环</div><div class="line">e = 3,next = null</div><div class="line">3.next = tab[i] = 7</div><div class="line">tab[i] = 3</div><div class="line">e = null</div><div class="line"></div><div class="line">(停止循环)</div></pre></td></tr></table></figure>
<p>第一次循环图：  </p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/h3.png" alt="image">  </p>
<p>第二次循环图：</p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/h22.png" alt="image"></p>
<p>第三次循环图：</p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/h4.png" alt="image"></p>
<p>在停止循环后，问题就出现了，如图所示，key(3)和key(7)构成了环形链表。<br><strong>于是，当我们调用HashMap的get方法时，由于查找链表节点时无法退出，就会产生无限循环。</strong></p>
<h3 id="二、解决方法"><a href="#二、解决方法" class="headerlink" title="二、解决方法"></a>二、解决方法</h3><p>解决方法就是采用同步的数据结构，主要有以下三种：</p>
<ol>
<li><strong>Hashtable</strong></li>
<li><strong>Collections.synchronizedMap()</strong></li>
<li><strong>ConcurrentHashMap</strong></li>
</ol>
<h4 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h4><p>Hashtable是线程安全的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public synchronized V put(K key, V value) &#123;...&#125;</div><div class="line"></div><div class="line">public synchronized V get(Object key) &#123;...&#125;</div></pre></td></tr></table></figure>
<p>可以看到，<strong>Hashtable是通过在方法上加上synchronized关键字来实现同步功能的</strong>。当一个线程访问时，其他线程都被阻塞住，这种方式效率很低，目前几乎不被使用。</p>
<h4 id="Collections-synchronizedMap"><a href="#Collections-synchronizedMap" class="headerlink" title="Collections.synchronizedMap()"></a>Collections.synchronizedMap()</h4><p>调用Collections的synchronizedMap()方法，传入一个Map，可以得到一个线程安全的SynchronizedMap。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">private static class SynchronizedMap&lt;K,V&gt;</div><div class="line">        implements Map&lt;K,V&gt;, Serializable &#123;</div><div class="line">        private final Map&lt;K,V&gt; m;     </div><div class="line">        final Object      mutex;        // Object on which to synchronize</div><div class="line"></div><div class="line">        SynchronizedMap(Map&lt;K,V&gt; m) &#123;</div><div class="line">            this.m = Objects.requireNonNull(m);</div><div class="line">            mutex = this;</div><div class="line">        &#125;</div><div class="line">        ....</div><div class="line">        public V get(Object key) &#123;</div><div class="line">            synchronized (mutex) &#123;return m.get(key);&#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public V put(K key, V value) &#123;</div><div class="line">            synchronized (mutex) &#123;return m.put(key, value);&#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>可以看到，<strong>它同步的原理同样也是使用了Synchronized关键字，不同的是Synchronized修饰代码块，并且将自身（this）作为了锁对象（mutex）。</strong></p>
<h4 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><p>ConcurrentHashMap是JDK1.5之后引入的，是为了替代上面提到的二者。<br>ConcurrentHashMap是线程安全且高效的HashMap，它使用了多个锁来控制对hash数组不同部分的修改。  </p>
<p>关于它的实现原理可以查看<a href="https://youngforzy.github.io/2017/11/10/ConcurrentHashMap在JDK1.8中的实现分析/" target="_blank" rel="external">ConcurrentHashMap</a>这篇文章中的分析。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、线程安全性&quot;&gt;&lt;a href=&quot;#一、线程安全性&quot; class=&quot;headerlink&quot; title=&quot;一、线程安全性&quot;&gt;&lt;/a&gt;一、线程安全性&lt;/h3&gt;&lt;p&gt;我们知道，HashMap是非线程安全的，只能在单线程的情况下使用。那么为什么不能在并发的情况下使用呢
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="HashMap" scheme="http://yoursite.com/tags/HashMap/"/>
    
      <category term="线程安全" scheme="http://yoursite.com/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>HashMap 在JDK1.8中的实现（与JDK1.7对比）</title>
    <link href="http://yoursite.com/2017/11/01/HashMap%20%E5%9C%A8JDK1.8%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%B8%8EJDK1.7%E5%AF%B9%E6%AF%94%EF%BC%89/"/>
    <id>http://yoursite.com/2017/11/01/HashMap 在JDK1.8中的实现（与JDK1.7对比）/</id>
    <published>2017-11-01T09:48:18.000Z</published>
    <updated>2018-02-24T17:30:16.587Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HashMap的实现分析"><a href="#HashMap的实现分析" class="headerlink" title="HashMap的实现分析"></a>HashMap的实现分析</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>通过前面JDK1.7的分析，我们知道，当负载因子和Hash算法设计的很好时，可以降低hash碰撞的概率，但在数据量过大时也避免不了会出现链表变长的情况，一旦出现链表过长，查找元素变慢，则会严重影响HashMap的性能。<br>于是，在JDK1.8中，对数据结构做了进一步的优化，引入了红黑树。<strong>而当链表长度太长（默认超过8）时，链表就转换为红黑树</strong>，利用红黑树快速增删改查的特点提高HashMap的性能，其中会用到红黑树的插入、删除、查找等算法。</p>
<h4 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h4><p>HashMap的底层实现是<strong>数组+链表+红黑树</strong>。</p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/1.8hash.PNG" alt="image"></p>
<h4 id="数组索引位置"><a href="#数组索引位置" class="headerlink" title="数组索引位置"></a>数组索引位置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//第一步</div><div class="line">static final int hash(Object key) &#123;</div><div class="line">        int h;</div><div class="line">        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">//第二步，代码中：    </div><div class="line">    tab[i = (n - 1) &amp; hash]</div></pre></td></tr></table></figure>
<p>确定数组索引的位置同样是两步法：<br>第一步计算hash，与JDK1.7中的计算方法不同；<br>计算过程如下：  </p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/hash.png" alt="image">  </p>
<p>第二步确定索引，与JDK1.7中的相同，只是不作为一个独立的方法；</p>
<h4 id="put-、get-方法"><a href="#put-、get-方法" class="headerlink" title="put()、get()方法"></a>put()、get()方法</h4><p><strong>put()方法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public V put(K key, V value) &#123;</div><div class="line">        return putVal(hash(key), key, value, false, true);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>调用了putVal()方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</div><div class="line">                   boolean evict) &#123;</div><div class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</div><div class="line">        //如果tab为空或长度为0，则分配内存resize()</div><div class="line">        if ((tab = table) == null || (n = tab.length) == 0)</div><div class="line">            n = (tab = resize()).length;</div><div class="line">        //数组索引位置为null，直接put</div><div class="line">        //同时这一步p赋值为tab[i]</div><div class="line">        if ((p = tab[i = (n - 1) &amp; hash]) == null)</div><div class="line">            tab[i] = newNode(hash, key, value, null);</div><div class="line">        else &#123;</div><div class="line">            Node&lt;K,V&gt; e; K k;</div><div class="line">            //判断hash值和key是否都相同，都相同则后面替换value值</div><div class="line">            if (p.hash == hash &amp;&amp;</div><div class="line">                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</div><div class="line">                e = p;</div><div class="line">            //红黑书处理冲突    </div><div class="line">            else if (p instanceof TreeNode)</div><div class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</div><div class="line">            //链表处理冲突</div><div class="line">            else &#123;</div><div class="line">                for (int binCount = 0; ; ++binCount) &#123;</div><div class="line">                    // 在链表尾部插入新结点</div><div class="line">                    if ((e = p.next) == null) &#123;</div><div class="line">                        p.next = newNode(hash, key, value, null);</div><div class="line">                        //节点数 &gt;= 7，转化为红黑树</div><div class="line">                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) </div><div class="line">                            treeifyBin(tab, hash);</div><div class="line">                        break;</div><div class="line">                    &#125;</div><div class="line">                    //已经存在key，退出循环，后面替换value值</div><div class="line">                    if (e.hash == hash &amp;&amp;</div><div class="line">                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</div><div class="line">                        break;</div><div class="line">                    //与e = p.next组合，遍历链表</div><div class="line">                    p = e;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            //已经存在key，替换value值</div><div class="line">            if (e != null) &#123; // existing mapping for key</div><div class="line">                V oldValue = e.value;</div><div class="line">                if (!onlyIfAbsent || oldValue == null)</div><div class="line">                    e.value = value;</div><div class="line">                afterNodeAccess(e);</div><div class="line">                return oldValue;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        ++modCount;</div><div class="line">        //扩容</div><div class="line">        if (++size &gt; threshold)</div><div class="line">            resize();</div><div class="line">        afterNodeInsertion(evict);</div><div class="line">        return null;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>put过程分析：</p>
<ol>
<li>如果数组索引位置tab[i]为null，直接put；否则进入2；</li>
<li>与第一个节点hash值相同且key值也相同，则直接到后面替换value值，否则进入3；</li>
<li>判断链表是否形成红黑树，并根据结果进入不同的处理。</li>
</ol>
<hr>
<p><strong>get()方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public V get(Object key) &#123;</div><div class="line">        Node&lt;K,V&gt; e;</div><div class="line">        return (e = getNode(hash(key), key)) == null ? null : e.value;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>调用getNode()方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;</div><div class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;</div><div class="line">        if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</div><div class="line">            (first = tab[(n - 1) &amp; hash]) != null) &#123;</div><div class="line">            //判断目标是不是first，是直接返回first</div><div class="line">            if (first.hash == hash &amp;&amp; // always check first node</div><div class="line">                ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))</div><div class="line">                return first;</div><div class="line">            //已经形成链表</div><div class="line">            if ((e = first.next) != null) &#123;</div><div class="line">                //第一个节点是TreeNode，说明形成了红黑树</div><div class="line">                if (first instanceof TreeNode)</div><div class="line">                    return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</div><div class="line">                // 还未形成红黑树，按链表处理   </div><div class="line">                do &#123;</div><div class="line">                    if (e.hash == hash &amp;&amp;</div><div class="line">                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</div><div class="line">                        return e;</div><div class="line">                &#125; while ((e = e.next) != null);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return null;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>方法分析：</p>
<ol>
<li>首先判断第一个节点first是不是要寻找的节点，如果是直接返回；不是进入2；</li>
<li>判断第一个节点first是不是树节点，如果是说明形成红黑树，调用红黑树的查找方法；不是则进入3；</li>
<li>说明还是链表，未形成红黑树，调用链表查找方法。</li>
</ol>
<h4 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h4><p>我们知道，当往HashMap中不断地添加元素时，它就会扩大数组的长度，把小的数组用大的数组来代替。<br><strong>回忆JDK1.7中的扩容，对于链表中的每个元素都需要重新计算hash值，而在JDK1.8中，只需要看看原来的hash值新增的那个bit是1还是0就好了</strong>，是0的话索引没变，是1的话索引变成“原索引+oldCap（原容量）”，工作过程如下图：</p>
<p>数组由16扩大到32的过程中，索引位置为15的元素变化：<br><img src="http://osuskkx7k.bkt.clouddn.com/1.8hahs%E6%89%A9%E5%AE%B9.png" alt="image"></p>
<p><strong>注：JDK1.7中旧链表的元素如果刚好又在新链表中，那么元素的顺序是倒置的，而JDK1.8不会倒置。</strong></p>
<h4 id="JDK1-8和JDK1-7的区别（HashMap）"><a href="#JDK1-8和JDK1-7的区别（HashMap）" class="headerlink" title="JDK1.8和JDK1.7的区别（HashMap）"></a>JDK1.8和JDK1.7的区别（HashMap）</h4><p><strong>相同点</strong></p>
<ol>
<li><strong>默认初始容量都是16，默认负载因子都是0.75。数组的长度length都是2的次幂，扩容时都是2倍</strong></li>
<li><strong>通过hash计算索引的方法相同（hash &amp; length-1）</strong></li>
<li><strong>key为null的键值对都会放入table[0]中</strong></li>
<li><strong>都是懒加载，初始时表为空，在插入第一个键值对时初始</strong>化</li>
</ol>
<p><strong>不同点</strong></p>
<ol>
<li><strong>结构不同，JDK1.8增加了红黑树优化结构</strong></li>
<li><strong>put方法的区别，JDK1.7中put时，添加到头节点；JDK1.8中添加到尾节点</strong></li>
<li><strong>计算hash的方法不同，JDK1.8更优化</strong></li>
<li><strong>JDK1.7新链表的顺序倒置，JDK1.8新链表顺序不倒置</strong></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;HashMap的实现分析&quot;&gt;&lt;a href=&quot;#HashMap的实现分析&quot; class=&quot;headerlink&quot; title=&quot;HashMap的实现分析&quot;&gt;&lt;/a&gt;HashMap的实现分析&lt;/h3&gt;&lt;h4 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="HashMap" scheme="http://yoursite.com/tags/HashMap/"/>
    
      <category term="JDK1.8" scheme="http://yoursite.com/tags/JDK1-8/"/>
    
  </entry>
  
  <entry>
    <title>HashMap 在JDK1.7中的实现原理分析</title>
    <link href="http://yoursite.com/2017/10/30/HashMap%20%E5%9C%A8JDK1.7%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2017/10/30/HashMap 在JDK1.7中的实现原理分析/</id>
    <published>2017-10-30T10:48:18.000Z</published>
    <updated>2018-02-24T17:26:41.879Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、HashMap的介绍"><a href="#一、HashMap的介绍" class="headerlink" title="一、HashMap的介绍"></a>一、HashMap的介绍</h3><p>HashMap是存储键值对（key，value）的一种数据结构。<br>每一个元素都是一个key-value。<br>HashMap最多只允许一个key为null，允许多个key的value值为null。<br>HashMap是非线程安全的，只适用于单线程环境。<br>HashMap实现了Serializable、Cloneable接口，因此它支持序列化和克隆。</p>
<h3 id="二、HashMap的实现原理"><a href="#二、HashMap的实现原理" class="headerlink" title="二、HashMap的实现原理"></a>二、HashMap的实现原理</h3><p>从<strong>底层结构、put和get方法、hash数组索引、扩容机制</strong>等几个方面来分析HashMap的实现原理：</p>
<h4 id="1-底层结构"><a href="#1-底层结构" class="headerlink" title="1.底层结构"></a>1.底层结构</h4><p>HashMap的底层结构是由<strong>数组+链表</strong>构成的。  </p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/hash2.PNG" alt="image"></p>
<p>数组（紫色）：hash数组（桶），数组元素是每个链表的头节点<br>链表（绿色）：解决hash冲突，不同的key映射到了数组的同一索引处，则形成链表。</p>
<p><strong>构成链表的节点类Node：</strong> （jdk 1.7 中的源码）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</div><div class="line">        final K key;</div><div class="line">        V value;</div><div class="line">        Entry&lt;K,V&gt; next;</div><div class="line">        int hash;</div><div class="line">        ....</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到，key和value都储存于节点之中，next表示下一个节点。</p>
<h4 id="2-put、get方法"><a href="#2-put、get方法" class="headerlink" title="2.put、get方法"></a>2.put、get方法</h4><p><strong>put()方法：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public V put(K key, V value) &#123;  </div><div class="line">    // 若key为null，则将该键值对添加到table[0]中。  </div><div class="line">    if (key == null)  </div><div class="line">        return putForNullKey(value);  </div><div class="line">    // 若key不为null，则计算该key的hash值，然后将其添加到该哈希值对应的数组索引处的链表中。</div><div class="line">    int hash = hash(key.hashCode());  </div><div class="line">    int i = indexFor(hash, table.length);  </div><div class="line">    //遍历该数组索引位置处的链表</div><div class="line">    for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123;  </div><div class="line">        Object k;  </div><div class="line">        // 若该key对应的键值对已经存在，则用新的value替换旧的value，退出  </div><div class="line">        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;  </div><div class="line">            V oldValue = e.value;  </div><div class="line">            e.value = value;  </div><div class="line">            e.recordAccess(this);  </div><div class="line">            return oldValue;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    modCount++;</div><div class="line">    // 若数组索引位置处table[i]没有链表，即没有元素</div><div class="line">    // 则将key-value添加到数组索引table[i]处，成为头节点</div><div class="line">    addEntry(hash, key, value, i);  </div><div class="line">    return null;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>put()方法大概过程如下：</p>
<ol>
<li><strong>如果添加的key值为null，那么将该键值对添加到数组索引为0的链表中，不一定是链表的首节点。</strong></li>
<li><strong>如果添加的key不为null，则根据key计算数组索引的位置</strong>：  </li>
</ol>
<ul>
<li><strong>数组索引处存在链表</strong>，则遍历该链表，如果发现key已经存在，那么将新的value值替换旧的value值</li>
<li><strong>数组索引处不存在链表</strong>，将该key-value添加到此处，成为头节点</li>
</ul>
<p><strong>addEntry()方法如下：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">void addEntry(int hash, K key, V value, int bucketIndex) &#123;  </div><div class="line">    // bucketIndex是数组位置索引，保存“bucketIndex”位置的值到“e”中  </div><div class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];  </div><div class="line">    // 设置“bucketIndex”位置的元素为“新Entry”，设置“e”为“新Entry的下一个节点”  </div><div class="line">    table[bucketIndex] = new Entry&lt;K,V&gt;(hash, key, value, e);  </div><div class="line">    // size超过阈值，则调整HashMap的大小  </div><div class="line">    if (size++ &gt;= threshold)  </div><div class="line">        resize(2 * table.length);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>将新的节点（假设为节点n）添加到数组索引位置处，将原来的节点e作为n的next节点，即下一个节点。</strong></p>
<p>由此可知：<strong>每一次添加的新节点总是作为头节点。</strong></p>
<hr>
<p><strong>get()方法：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public V get(Object key) &#123;  </div><div class="line">    if (key == null)  </div><div class="line">        return getForNullKey();  </div><div class="line">    // 获取key的hash值  </div><div class="line">    int hash = hash(key.hashCode());  </div><div class="line">    // 在“该hash值对应的链表”上查找“键值等于key”的元素  </div><div class="line">    for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];  </div><div class="line">         e != null;  </div><div class="line">         e = e.next) &#123;  </div><div class="line">        Object k;  </div><div class="line">        //判断key是否相同</div><div class="line">        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))  </div><div class="line">            return e.value;  </div><div class="line">    &#125;</div><div class="line">    //没找到则返回null</div><div class="line">    return null;  </div><div class="line">&#125;  </div><div class="line"> </div><div class="line">// 获取“key为null”的元素的值  </div><div class="line">// HashMap将“key为null”的元素存储在table[0]位置，但不一定是该链表的第一个位置！  </div><div class="line">private V getForNullKey() &#123;  </div><div class="line">    for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) &#123;  </div><div class="line">        if (e.key == null)  </div><div class="line">            return e.value;  </div><div class="line">    &#125;  </div><div class="line">    return null;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>get()方法的大概过程：</p>
<ol>
<li>如果key为null，那么在数组索引table[0]处的链表中遍历查找key为null的value</li>
<li>如果key不为null，根据key找到数组索引位置处的链表，遍历查找key的value，找到返回value，若没找到则返回null</li>
</ol>
<h4 id="3-hash数组索引位置"><a href="#3-hash数组索引位置" class="headerlink" title="3.hash数组索引位置"></a>3.hash数组索引位置</h4><p>前面多次提到了数组索引位置，那么这个位置该如何确定呢？<br>两步：</p>
<ol>
<li>确定key的hash值</li>
<li>根据hash计算索引</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">static int hash(int h) &#123;</div><div class="line">        h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);</div><div class="line">        return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">static int indexFor(int h, int length) &#123;</div><div class="line">        return h &amp; (length-1);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>第一步：采用位操作计算hash值，这么做的<strong>目的是为了下一步的索引值分布均匀，减少碰撞，提高效率。</strong><br>第二步：根据hash值计算索引的值，把hash值和数组长度-1做一个”与”操作，保留的值作为索引。</p>
<p><strong>为什么是length-1？</strong><br><strong>这也是HashMap的数组长度要取2的整次幂的原因之一。  因为length为2的整数次幂时，（length-1）正好相当于一个“低位掩码”**</strong>。“与”操作的结果就可以保留低位作为数组索引。**<br>例如：length = 16和某个hash值进行 &amp; 操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">某个hash           10110110 11100010 01000101</div><div class="line">length-1=15    &amp;   00000000 00000000 00001111</div><div class="line">           ---------------------------------</div><div class="line">                   00000000 00000000 00000101   //只保留末四位，索引值=5</div></pre></td></tr></table></figure>
<p><strong>另一个原因</strong>：HashMap的数组长度length为2的整次幂时，length-1为奇数（偶数-1），此时进行 &amp; 操作时可保证最后一位可能是 0 或 1 ，保证了数组索引的均匀性；而如果length-1为偶数，那么 &amp; 操作时最后一位只能是 0，也就是数组索引只能是偶数索引位置，这样就浪费了一半的空间，所以length为2的整次幂。<br><strong>综上，数组长度取2的整次幂，是为了减少hash碰撞的概率，使元素散列更加均匀。</strong></p>
<h4 id="4-扩容机制"><a href="#4-扩容机制" class="headerlink" title="4.扩容机制"></a>4.扩容机制</h4><p>先看一个例子，创建一个HashMap，初始容量默认为16，负载因子默认为0.75，那么什么时候它会扩容呢？<br>来看以下公式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">实际容量 = 初始容量 × 负载因子</div></pre></td></tr></table></figure></p>
<p>计算可知，16×0.75=12，也就是当实际容量超过12时，这个HashMap就会扩容。</p>
<p><strong>初始容量</strong>  </p>
<p>当构造一个hashmap时，初始容量设为不小于指定容量的2的次方的一个数（new HashMap(5)， 指定容量为5，那么实际初始容量为8，2^3=8&gt;5），且最大值不能超过2的30次方。  </p>
<p><strong>负载因子</strong>  </p>
<p><strong>负载因子是哈希数组在其容量自动增加之前可以达到多满的一种尺度。（时间与空间的折衷）</strong> 当哈希数组中的条目数超出了加载因子与初始容量的乘积时，则要对该哈希数组进行扩容操作（即resize）。<br><strong>特点：</strong></p>
<ul>
<li><strong>负载因子越小，容易扩容，浪费空间，但查找效率高</strong></li>
<li><strong>负载因子越大，不易扩容，对空间的利用更加充分，查找效率低（链表拉长）</strong></li>
</ul>
<p><strong>扩容过程</strong>  </p>
<p> HashMap在扩容时，<strong>新数组的容量将是原来的2倍</strong>，由于容量发生变化，原有的每个元素需要重新计算数组索引Index，再存放到新数组中去，这就是所谓的rehash。</p>
<p>扩容代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">void resize(int newCapacity) &#123;  </div><div class="line">    Entry[] oldTable = table;  </div><div class="line">    int oldCapacity = oldTable.length;  </div><div class="line">    if (oldCapacity == MAXIMUM_CAPACITY) &#123;  </div><div class="line">        threshold = Integer.MAX_VALUE;  </div><div class="line">        return;  </div><div class="line">    &#125;  </div><div class="line">    // 新建一个HashMap，将“旧HashMap”的全部元素添加到“新HashMap”中</div><div class="line">    // 然后，将“新HashMap”赋值给“旧HashMap”。  </div><div class="line">    Entry[] newTable = new Entry[newCapacity];  </div><div class="line">    transfer(newTable);  </div><div class="line">    table = newTable;  </div><div class="line">    threshold = (int)(newCapacity * loadFactor);  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>调用transfer()方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">void transfer(Entry[] newTable) &#123;  </div><div class="line">    Entry[] src = table;  </div><div class="line">    int newCapacity = newTable.length;  </div><div class="line">    for (int j = 0; j &lt; src.length; j++) &#123;  </div><div class="line">        Entry&lt;K,V&gt; e = src[j];  </div><div class="line">        if (e != null) &#123;  </div><div class="line">            src[j] = null;  </div><div class="line">            do &#123;  </div><div class="line">                Entry&lt;K,V&gt; next = e.next;  </div><div class="line">                int i = indexFor(e.hash, newCapacity);  </div><div class="line">                e.next = newTable[i];  </div><div class="line">                newTable[i] = e;  </div><div class="line">                e = next;  </div><div class="line">            &#125; while (e != null);  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>第一步for循环遍历每一个数组元素（桶）；<br>第二步遍历每一个数组元素中的链表，将链表中的节点存入新数组指定的位置构成链表，注意此时新链表顺序反转。（原链表的头节点将变成新链表的尾节点）<br><strong>注：原链表中的节点可能存到不同的新链表中，因为rehash重新计算了索引位置。</strong></p>
<p>由此可知，<strong>扩容操作是一个耗时耗性能的操作，因为它需要重新计算元素的位置，并进行复制操作。因此，在使用时提前预估HashMap的大小有助于提高性能。</strong></p>
<p>HashMap未初始容量和初始容量的对比：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">long start1 = System.currentTimeMillis();</div><div class="line">		HashMap map = new HashMap&lt;&gt;(); //未初始容量</div><div class="line">		for(int i=0;i&lt;20000;i++)&#123;</div><div class="line">			map.put(i, &quot;I am zy&quot;);</div><div class="line">		&#125;</div><div class="line">		long end1 = System.currentTimeMillis();</div><div class="line">		System.out.println(&quot;不初始化时耗时：&quot;+(end1-start1)+ &quot;ms&quot;);</div><div class="line">		</div><div class="line">		long start2 = System.currentTimeMillis();</div><div class="line">		HashMap map2 = new HashMap&lt;&gt;(32768); //初始容量</div><div class="line">		for(int i=0;i&lt;20000;i++)&#123;</div><div class="line">			map2.put(i, &quot;I am zy&quot;);</div><div class="line">		&#125;</div><div class="line">		long end2 = System.currentTimeMillis();</div><div class="line">		System.out.println(&quot;初始化时耗时：&quot;+(end2-start2)+ &quot;ms&quot;);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">不初始化时耗时：5ms</div><div class="line">初始化时耗时：1ms</div></pre></td></tr></table></figure>
<p>可见初始化容量有助于提高性能，对于数据量大则越明显。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、HashMap的介绍&quot;&gt;&lt;a href=&quot;#一、HashMap的介绍&quot; class=&quot;headerlink&quot; title=&quot;一、HashMap的介绍&quot;&gt;&lt;/a&gt;一、HashMap的介绍&lt;/h3&gt;&lt;p&gt;HashMap是存储键值对（key，value）的一种数据结
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="JDK1.7" scheme="http://yoursite.com/tags/JDK1-7/"/>
    
      <category term="HashMap" scheme="http://yoursite.com/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>ReentrantReadWriteLock可重入读写锁</title>
    <link href="http://yoursite.com/2017/10/28/ReentrantReadWriteLock%E5%8F%AF%E9%87%8D%E5%85%A5%E8%AF%BB%E5%86%99%E9%94%81/"/>
    <id>http://yoursite.com/2017/10/28/ReentrantReadWriteLock可重入读写锁/</id>
    <published>2017-10-28T09:48:18.000Z</published>
    <updated>2018-02-24T07:44:19.001Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、ReentrantReadWriteLock的概念"><a href="#一、ReentrantReadWriteLock的概念" class="headerlink" title="一、ReentrantReadWriteLock的概念"></a>一、ReentrantReadWriteLock的概念</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>前面提到的锁（独占锁、ReentrantLock）等都是排他锁，这些锁在同一时刻只允许一个线程访问。<br>而<strong>读写锁在同一时刻可以允许多个读线程访问，但在写线程访问时，所有读线程和其他写线程都阻塞。</strong></p>
<p>ReadWriteLock并不是继承自Lock接口，而是一个单独的接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public interface ReadWriteLock &#123;</div><div class="line">    Lock readLock();</div><div class="line">    Lock writeLock();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ReentrantReadWriteLock则是这个接口的实现。通过readLock()和writeLock()方法可分别获得一个ReadLock实例和一个WriteLock实例，这两个实例实现了Lock接口。<br>因此，我们可以调用Lock接口的相关方法来完成锁的语义。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ReentrantReadWriteLock rw = new ReentrantReadWriteLock();</div><div class="line">Lock r = rw.readLock();</div><div class="line">Lock w = rw.writeLock();</div><div class="line">...</div></pre></td></tr></table></figure>
<h4 id="特性："><a href="#特性：" class="headerlink" title="特性："></a>特性：</h4><ol>
<li><p><strong>公平性：同样有公平锁和非公平锁；</strong>  </p>
</li>
<li><p><strong>重入性：读锁和写锁都支持重入（最大65535）；</strong></p>
</li>
<li><strong>锁降级：获取写锁之后，获取读锁，释放写锁，保留读锁；（按顺序）</strong></li>
</ol>
<h3 id="二、ReentrantReadWriteLock的实现原理"><a href="#二、ReentrantReadWriteLock的实现原理" class="headerlink" title="二、ReentrantReadWriteLock的实现原理"></a>二、ReentrantReadWriteLock的实现原理</h3><p>ReentrantReadWriteLock与ReentrantLock一样，锁的语义的实现依旧是依靠Sync（继承自AQS），它的读锁、写锁的实现原理如下：</p>
<ul>
<li><strong>读锁：AQS共享锁</strong></li>
<li><strong>写锁：AQS独占锁</strong></li>
</ul>
<h4 id="读写状态"><a href="#读写状态" class="headerlink" title="读写状态"></a>读写状态</h4><p>读写锁的实现同样是依赖AQS来实现同步功能。<br>那么它的读写状态如何表示呢？<br>同样是<strong>使用一个int型的变量</strong>表示，将这个变量“按位切割”成两部分，<strong>高16位表示读，低16位表示写</strong>。这样我们就能通过位运算确定它的读写状态。（如下图）  </p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/duxiesuo.jpg" alt="（图）">  </p>
<p>如果已知整体同步状态为S，那么：</p>
<ul>
<li><strong>写状态：S &amp; 0x0000FFFF</strong>（将高16位变0，抹去）</li>
<li><strong>读状态：S&gt;&gt;&gt;16</strong> （无符号补0右移16位）  </li>
</ul>
<p><strong>注：当写状态为0，S不为0时，表示读状态不为0，读锁被获取。</strong></p>
<h4 id="写锁的获取和释放"><a href="#写锁的获取和释放" class="headerlink" title="写锁的获取和释放"></a>写锁的获取和释放</h4><p>写锁是独占锁，获取时调用Sync中的tryAcquire()方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">protected final boolean tryAcquire(int acquires) &#123;</div><div class="line">            Thread current = Thread.currentThread();</div><div class="line">            //获取状态</div><div class="line">            int c = getState();</div><div class="line">            //获取写状态</div><div class="line">            int w = exclusiveCount(c);</div><div class="line">            if (c != 0) &#123;</div><div class="line">                //写状态为0表示存在读线程，获取失败</div><div class="line">                //或当前线程不是获取写锁的线程，获取失败</div><div class="line">                if (w == 0 || current != getExclusiveOwnerThread())</div><div class="line">                    return false;</div><div class="line">                //超过写锁总数量</div><div class="line">                if (w + exclusiveCount(acquires) &gt; MAX_COUNT)</div><div class="line">                    throw new Error(&quot;Maximum lock count exceeded&quot;);</div><div class="line">                //当前线程是获取写锁的线程，重进入，获取成功</div><div class="line">                setState(c + acquires);</div><div class="line">                return true;</div><div class="line">            &#125;</div><div class="line">            //是否需要阻塞</div><div class="line">            if (writerShouldBlock() ||</div><div class="line">                !compareAndSetState(c, c + acquires))</div><div class="line">                return false;</div><div class="line">            setExclusiveOwnerThread(current);</div><div class="line">            return true;</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p>
<p>写锁的获取过程如代码中注释所示。<br>只有在以下情况才能获取写锁：</p>
<ul>
<li><strong>不存在读锁或当前线程是已经获取写锁的线程（可重入）</strong></li>
</ul>
<hr>
<p>写锁的释放调用的是Sync的tryRelease()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">protected final boolean tryRelease(int releases) &#123;</div><div class="line">            if (!isHeldExclusively())</div><div class="line">                throw new IllegalMonitorStateException();</div><div class="line">            int nextc = getState() - releases;</div><div class="line">            boolean free = exclusiveCount(nextc) == 0;</div><div class="line">            if (free)</div><div class="line">                setExclusiveOwnerThread(null);</div><div class="line">            setState(nextc);</div><div class="line">            return free;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>写锁的释放与重入锁的释放过程类似，每次释放时将写状态减少，直到写锁状态为0时，表示写锁释放。</p>
<hr>
<h4 id="读锁的获取和释放"><a href="#读锁的获取和释放" class="headerlink" title="读锁的获取和释放"></a>读锁的获取和释放</h4><p>读锁是共享锁，调用的是Sync的tryAcquireShared()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">protected final int tryAcquireShared(int unused) &#123;</div><div class="line">            Thread current = Thread.currentThread();</div><div class="line">            int c = getState(); //获取状态</div><div class="line">            //写锁不为0  &amp;&amp; 且获取写锁的线程不是当前线程</div><div class="line">            //直接失败</div><div class="line">            if (exclusiveCount(c) != 0 &amp;&amp;</div><div class="line">                getExclusiveOwnerThread() != current) </div><div class="line">                return -1;</div><div class="line">            //获取读锁</div><div class="line">            int r = sharedCount(c);</div><div class="line">            //readerShouldBlock()：读锁是否要等待（公平or非公平）</div><div class="line">            // r &lt; MAX_COUNT：读锁小于最大值（65535）</div><div class="line">            //compareAndSetState(c, c + SHARED_UNIT))：CAS操作成功</div><div class="line">            if (!readerShouldBlock() &amp;&amp;</div><div class="line">                r &lt; MAX_COUNT &amp;&amp;</div><div class="line">                compareAndSetState(c, c + SHARED_UNIT)) &#123;</div><div class="line">                //r == 0：只有一个读锁（A），计数+1</div><div class="line">                if (r == 0) &#123;</div><div class="line">                    firstReader = current;</div><div class="line">                    firstReaderHoldCount = 1;</div><div class="line">                //持有读锁的线程（A）重进入，计数++</div><div class="line">                &#125; else if (firstReader == current) &#123;</div><div class="line">                    firstReaderHoldCount++;</div><div class="line">                &#125; else &#123;</div><div class="line">                //另一个线程（B）进入，此时找到缓存的rh，将计数++；</div><div class="line">                    HoldCounter rh = cachedHoldCounter;</div><div class="line">                    if (rh == null || rh.tid != getThreadId(current))</div><div class="line">                        cachedHoldCounter = rh = readHolds.get();</div><div class="line">                    else if (rh.count == 0)</div><div class="line">                        readHolds.set(rh);</div><div class="line">                    rh.count++;</div><div class="line">                &#125;</div><div class="line">                return 1;</div><div class="line">            &#125;</div><div class="line">            //循环尝试</div><div class="line">            return fullTryAcquireShared(current);</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>获取锁的过程如注释所示。<br>如果不满足第二个if语句中的判断，比如读锁需要阻塞，则会进入fullTryAcquireShared（current）方法，<strong>该方法循环不断尝试修改状态直到成功或被写入锁占有。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">final int fullTryAcquireShared(Thread current) &#123;</div><div class="line">            HoldCounter rh = null;</div><div class="line">            for (;;) &#123;</div><div class="line">                int c = getState();</div><div class="line">                //写锁存在但不是当前线程，直接失败</div><div class="line">                if (exclusiveCount(c) != 0) &#123;</div><div class="line">                    if (getExclusiveOwnerThread() != current)</div><div class="line">                        return -1;</div><div class="line">                //读锁是否要阻塞（公平 or 非公平）</div><div class="line">                &#125; else if (readerShouldBlock()) &#123;</div><div class="line">                    if (firstReader == current) &#123;</div><div class="line">                    &#125; else &#123;</div><div class="line">                        if (rh == null) &#123;</div><div class="line">                            rh = cachedHoldCounter;</div><div class="line">                            if (rh == null || rh.tid != getThreadId(current)) &#123;</div><div class="line">                                rh = readHolds.get();</div><div class="line">                                if (rh.count == 0)</div><div class="line">                                    readHolds.remove();</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                        if (rh.count == 0)</div><div class="line">                            return -1;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                //读锁达到最大值，不能再获取</div><div class="line">                if (sharedCount(c) == MAX_COUNT)</div><div class="line">                    throw new Error(&quot;Maximum lock count exceeded&quot;);</div><div class="line">                //CAS操作</div><div class="line">                if (compareAndSetState(c, c + SHARED_UNIT)) &#123;</div><div class="line">                    if (sharedCount(c) == 0) &#123;</div><div class="line">                        firstReader = current;</div><div class="line">                        firstReaderHoldCount = 1;</div><div class="line">                    &#125; else if (firstReader == current) &#123;</div><div class="line">                        firstReaderHoldCount++;</div><div class="line">                    &#125; else &#123;</div><div class="line">                        if (rh == null)</div><div class="line">                            rh = cachedHoldCounter;</div><div class="line">                        if (rh == null || rh.tid != getThreadId(current))</div><div class="line">                            rh = readHolds.get();</div><div class="line">                        else if (rh.count == 0)</div><div class="line">                            readHolds.set(rh);</div><div class="line">                        rh.count++;</div><div class="line">                        cachedHoldCounter = rh; </div><div class="line">                    &#125;</div><div class="line">                    return 1;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>以上的代码中多次出现了一个rh变量（HoldCounter），我们知道重入锁的原理就是计数器，同理这个rh变量也相当于一个计数器，记录线程获取读锁的次数。来看它的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//HoldCounter类</div><div class="line">static final class HoldCounter &#123;</div><div class="line">            int count = 0;</div><div class="line">            final long tid = getThreadId(Thread.currentThread());</div><div class="line">        &#125;</div><div class="line">//继承ThreadLocal类        </div><div class="line">static final class ThreadLocalHoldCounter</div><div class="line">            extends ThreadLocal&lt;HoldCounter&gt; &#123;</div><div class="line">            public HoldCounter initialValue() &#123;</div><div class="line">                return new HoldCounter();</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>HoldCounter的定义只包含一个计数器和当前线程的Id，它的作用就是记录该线程获取读锁的次数，那么它是如何与线程绑定的呢？我们知道ThreadLocal类是线程维护的私有变量，利用它就可以和线程绑定。  </p>
<p>注：（需要说明的是这样<strong>HoldCounter绑定线程id而不绑定线程对象的原因是**</strong>避免HoldCounter和ThreadLocal互相绑定而GC难以释放它们**，所以其实这样做只是为了帮助GC快速回收对象而已。）</p>
<hr>
<p>当读锁释放时，调用的是Sync的tryReleaseShared()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">protected final boolean tryReleaseShared(int unused) &#123;</div><div class="line">            Thread current = Thread.currentThread();</div><div class="line">            if (firstReader == current) &#123;</div><div class="line">                if (firstReaderHoldCount == 1)</div><div class="line">                    firstReader = null;</div><div class="line">                else</div><div class="line">                    firstReaderHoldCount--;</div><div class="line">            &#125; else &#123;</div><div class="line">                HoldCounter rh = cachedHoldCounter;</div><div class="line">                if (rh == null || rh.tid != getThreadId(current))</div><div class="line">                    rh = readHolds.get();</div><div class="line">                int count = rh.count;</div><div class="line">                if (count &lt;= 1) &#123;</div><div class="line">                    readHolds.remove();</div><div class="line">                    if (count &lt;= 0)</div><div class="line">                        throw unmatchedUnlockException();</div><div class="line">                &#125;</div><div class="line">                --rh.count;</div><div class="line">            &#125;</div><div class="line">            for (;;) &#123;</div><div class="line">                int c = getState();</div><div class="line">                int nextc = c - SHARED_UNIT;</div><div class="line">                if (compareAndSetState(c, nextc))</div><div class="line">                    return nextc == 0;</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>循环CAS操作直到读锁的状态为0。</p>
<h4 id="锁降级"><a href="#锁降级" class="headerlink" title="锁降级"></a>锁降级</h4><p>前面提到，读写锁有个特性是锁降级。<br>锁降级指的是：<strong>写锁降级为读锁</strong>。</p>
<p>具体过程：<strong>获取写锁的线程把持住写锁，然后获取读锁，再释放写锁。</strong>  </p>
<p><strong>目的：保证写锁修改的数据可以被其他线程看见，保证了数据的可见性。</strong> </p>
<p>锁降级中读锁的获取是否为必要？肯定是必要的。试想，假如当前线程A不获取读锁而是直接释放了写锁，这个时候另外一个线程B获取了写锁，那么这个线程B对数据的修改是不会对当前线程A可见的。   如果获取了读锁，则线程B在获取写锁过程中判断如果有读锁还没有释放则会被阻塞，只有当前线程A释放读锁后，线程B才会获取写锁成功。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、ReentrantReadWriteLock的概念&quot;&gt;&lt;a href=&quot;#一、ReentrantReadWriteLock的概念&quot; class=&quot;headerlink&quot; title=&quot;一、ReentrantReadWriteLock的概念&quot;&gt;&lt;/a&gt;一、Ree
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="ReentrantReadWriteLock" scheme="http://yoursite.com/tags/ReentrantReadWriteLock/"/>
    
      <category term="可重入读写锁" scheme="http://yoursite.com/tags/%E5%8F%AF%E9%87%8D%E5%85%A5%E8%AF%BB%E5%86%99%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>JVM之对象创建过程</title>
    <link href="http://yoursite.com/2017/10/26/JVM%E4%B9%8B%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2017/10/26/JVM之对象创建过程/</id>
    <published>2017-10-26T10:48:19.000Z</published>
    <updated>2018-02-24T07:33:25.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、Java对象的创建过程"><a href="#一、Java对象的创建过程" class="headerlink" title="一、Java对象的创建过程"></a>一、Java对象的创建过程</h3><p>在Java程序中，通常都是通过 new 关键字来创建对象，那么在虚拟机中对象是如何创建的？<br>（普通Java对象，不包含数组和Class对象）</p>
<p>虚拟机创建对象主要经历5个步骤：<strong>类加载检查、为对象分配内存、内存空间初始化、对象设置、执行对象<init>方法。</init></strong></p>
<h4 id="1-类加载检查"><a href="#1-类加载检查" class="headerlink" title="1 类加载检查"></a>1 类加载检查</h4><p>当虚拟机遇到 new 指令时，首先会去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且<strong>检查这个符号引用代表的类是否已被加载、解析和初始化过</strong>。如果没有，先执行类加载过程。</p>
<h4 id="2-为对象分配内存"><a href="#2-为对象分配内存" class="headerlink" title="2 为对象分配内存"></a>2 为对象分配内存</h4><p>对象所需的内存大小在类加载完成时已经确定，因此<strong>为对象分配内存等同于在Java堆中划分一块大小确定的内存空间</strong>。  </p>
<h5 id="两种分配方式："><a href="#两种分配方式：" class="headerlink" title="两种分配方式："></a>两种分配方式：</h5><ul>
<li><strong>指针碰撞</strong>：Java堆中的内存是完整的，将指针往空闲空间挪动一段与对象大小相等的距离</li>
<li><strong>空闲列表</strong>：Java堆中的内存不是完整的，JVM维护了一个记录可用内存的列表，分配时将列表中足够大的空间划分给对象，并更新列表</li>
</ul>
<p>因此选择何种分配方式由Java堆是否完整决定，而这又由垃圾收集器是否带有压缩整理功能决定。如：</p>
<ul>
<li><strong>Serial、ParNew等采用指针碰撞</strong></li>
<li><strong>CMS基于“标记-清除”采用空闲列表</strong></li>
</ul>
<h5 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h5><p>当处于并发情况下时，还要考虑线程安全问题。<br>两种解决方案：</p>
<ul>
<li><strong>对分配内存的动作进行同步处理</strong>。JVM采用CAS加失败重试的方式保证原子性</li>
<li><strong>把内存分配的动作按照线程划分在不同的空间进行</strong>。每个线程在Java堆中预先分配一小块内存（本地线程分配缓冲TLAB），只有TLAB用完重新分配时才同步锁定。<h4 id="3-内存空间初始化"><a href="#3-内存空间初始化" class="headerlink" title="3 内存空间初始化"></a>3 内存空间初始化</h4>JVM将分配到的内存空间都初始化为零值（不包括对象头）；若使用TLAB，则提前至TLAB分配时执行。</li>
</ul>
<p>这一步<strong>保证了对象实例字段在Java代码中可以不赋初值就直接使用</strong>，程序能访问到这些字段的数据类型所对应的零值。</p>
<h4 id="4-对象设置"><a href="#4-对象设置" class="headerlink" title="4 对象设置"></a>4 对象设置</h4><p>JVM设置对象头信息，如类元数据信息、对象的哈希码、对象的GC分代年龄信息等。还有是否启用偏向锁。</p>
<h4 id="5-执行对象方法"><a href="#5-执行对象方法" class="headerlink" title="5 执行对象方法"></a>5 执行对象<init>方法</init></h4><p>此时，对于JVM来说，对象已经产生；<br>对于Java程序来说，才刚刚开始，执行<init>方法进行初始化，一个对象才算真正创建完成。</init></p>
<h3 id="二、Java对象的初始化"><a href="#二、Java对象的初始化" class="headerlink" title="二、Java对象的初始化"></a>二、Java对象的初始化</h3><p>在Java对象初始化过程中，主要涉及三种执行对象初始化的结构，分别是 <strong>实例变量初始化、实例代码块初始化</strong> 以及 <strong>构造函数初始化</strong>。 </p>
<h4 id="实例变量初始化与实例代码块初始化"><a href="#实例变量初始化与实例代码块初始化" class="headerlink" title="实例变量初始化与实例代码块初始化"></a>实例变量初始化与实例代码块初始化</h4><p>在定义（声明）实例变量的同时，还可以直接对实例变量进行赋值或者使用实例代码块对其进行赋值。<br>如果我们<strong>以这两种方式为实例变量进行初始化，那么它们将在构造函数执行之前完成这些初始化操作。</strong> 实际上，如果我们对实例变量直接赋值或者使用实例代码块赋值，那么编译器会将其中的代码放到类的构造函数中去，并且这些代码会被放在对超类构造函数的调用语句之后(Super())，构造函数本身的代码之前。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public class Tdemo2 &#123;</div><div class="line">	//成员变量</div><div class="line">	private int i = 1;</div><div class="line">	private int j = 1;</div><div class="line">	public  Tdemo2(int c)&#123;</div><div class="line">		System.out.println(i);</div><div class="line">		System.out.println(j);</div><div class="line">		this.i = c;</div><div class="line">		System.out.println(i);</div><div class="line">	&#125;</div><div class="line">	//代码块</div><div class="line">	&#123;</div><div class="line">		j = j+1;</div><div class="line">	&#125;</div><div class="line">	//静态代码块</div><div class="line">	static&#123;</div><div class="line">		int a = 5;</div><div class="line">		System.out.println(a);</div><div class="line">	&#125;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		new Tdemo2(3);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">5</div><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td></tr></table></figure></p>
<p>可见执行顺序是static代码块、成员变量赋值、代码块、构造函数。</p>
<h4 id="构造函数初始化"><a href="#构造函数初始化" class="headerlink" title="构造函数初始化"></a>构造函数初始化</h4><p><strong>Java要求在实例化类之前，必须先实例化其超类，以保证所创建实例的完整性。</strong><br>Java强制要求Object对象(Object是Java的顶层对象，没有超类)之外的所有对象构造函数的第一条语句必须是超类构造函数的调用语句或者是类中定义的其他的构造函数，如果我们既没有调用其他的构造函数，也没有显式调用超类的构造函数，那么编译器会为我们自动生成一个对超类构造函数的调用。</p>
<p>实际上，实例化一个类的对象的过程是一个典型的递归过程。</p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/%E5%AE%9E%E4%BE%8B%E5%8C%96%E9%80%92%E5%BD%92%E8%BF%87%E7%A8%8B.png" alt="image"></p>
<p>在准备实例化一个类的对象前，首先准备实例化该类的父类，如果该类的父类还有父类，那么准备实例化该类的父类的父类，依次递归直到递归到Object类。</p>
<p><strong>注意：实例初始化不一定要在类初始化结束之后才开始初始化。</strong></p>
<p>回忆一下Java中赋值顺序： </p>
<ol>
<li>父类的静态变量赋值 </li>
<li>自身的静态变量赋值 </li>
<li>父类成员变量赋值和父类代码块赋值 </li>
<li>父类构造函数赋值 </li>
<li>自身成员变量赋值和自身块代码赋值 </li>
<li>自身构造函数赋值</li>
</ol>
<h3 id="三、Java对象的创建方式"><a href="#三、Java对象的创建方式" class="headerlink" title="三、Java对象的创建方式"></a>三、Java对象的创建方式</h3><p>Java对象的创建方式有 5 种：</p>
<ol>
<li><p>new 关键字</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Person p = new Person();</div></pre></td></tr></table></figure>
</li>
<li><p>Class类的newInstance()（反射）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Person p2 = Person.class.newInstance();</div></pre></td></tr></table></figure>
</li>
<li><p>Constructor类的newInstance方法（反射）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Constructor c = Person.class.getConstructor();</div><div class="line">Person p3 = (Person) c.newInstance();</div></pre></td></tr></table></figure>
</li>
<li><p>clone方法（实现Cloneable接口）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Person p4 = (Person) p3.clone();</div></pre></td></tr></table></figure>
</li>
<li><p>反序列化（实现Serializable接口）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//写对象</div><div class="line">ObjectOutputStream output = new ObjectOutputStream(new FileOutputStream(&quot;person.txt&quot;));</div><div class="line">output.writeObject(p);</div><div class="line">output.close();</div><div class="line"></div><div class="line">//读对象</div><div class="line">ObjectInputStream input = new ObjectInputStream(new FileInputStream(&quot;person.txt&quot;));</div><div class="line">Person p5 = (Person) input.readObject();</div></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、Java对象的创建过程&quot;&gt;&lt;a href=&quot;#一、Java对象的创建过程&quot; class=&quot;headerlink&quot; title=&quot;一、Java对象的创建过程&quot;&gt;&lt;/a&gt;一、Java对象的创建过程&lt;/h3&gt;&lt;p&gt;在Java程序中，通常都是通过 new 关键字来创建
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
      <category term="对象创建过程" scheme="http://yoursite.com/tags/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>JVM之类加载机制</title>
    <link href="http://yoursite.com/2017/10/24/JVM%E4%B9%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2017/10/24/JVM之类加载机制/</id>
    <published>2017-10-24T11:34:18.000Z</published>
    <updated>2018-02-24T07:28:54.050Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、类加载机制"><a href="#一、类加载机制" class="headerlink" title="一、类加载机制"></a>一、类加载机制</h3><p>虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被JVM直接使用的Java类型，这就是虚拟机的<strong>类加载机制</strong>。</p>
<h4 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h4><p>那么类到底什么时候会加载呢？（初始化）<br><strong>当对一个类进行主动引用的时候</strong>。</p>
<h5 id="主动引用"><a href="#主动引用" class="headerlink" title="主动引用"></a>主动引用</h5><p>主动引用有5种情况：</p>
<ol>
<li>new实例化对象、读取或设置一个类的静态字段时、调用一个类的静态方法时</li>
<li>使用java.lang.reflect包的方法对类进行反射调用时</li>
<li>初始化一个类时，父类还没初始化，则先触发父类的初始化</li>
<li>虚拟机启动时，初始化包含main()方法的主类</li>
<li>使用JDK1.7的动态语言支持的时候，如java.lang.invoke.MethodHandle实例</li>
</ol>
<h5 id="被动引用"><a href="#被动引用" class="headerlink" title="被动引用"></a>被动引用</h5><p>被动引用有以下几种情况：</p>
<ol>
<li>子类调用父类的静态变量，子类不会被初始化，只有父类会被初始化。（只有定义静态字段的类才会被初始化）</li>
<li>通过数组来定义引用类，不会初始化</li>
<li>访问类的final常量(编译期静态常量)，不会初始化</li>
<li>通过类名获取Class对象，不会触发类的初始化(其余两种getClass()和Class.forName()会)<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//类名.class获取Class对象</div><div class="line">Class clazz = A.class;</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="二、类加载过程"><a href="#二、类加载过程" class="headerlink" title="二、类加载过程"></a>二、类加载过程</h3><h4 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h4><p><img src="http://osuskkx7k.bkt.clouddn.com/%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F2.jpg.png" alt="image"></p>
<p><strong>类的生命周期包括：加载、验证、准备、解析、初始化、使用和卸载7个阶段。</strong> 验证、准备、解析这三个阶段称为连接。<br>解析阶段的顺序不是确定的，可以在初始化之后开始。</p>
<p><strong>类加载过程</strong>包括<strong>加载、验证、准备、解析、初始化</strong>。</p>
<h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p>JVM完成以下3件事：</p>
<ol>
<li>通过一个类的全限定名来获取定义此类的二进制字节流（不一定是Class文件）。</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</li>
</ol>
<p>注：</p>
<ul>
<li>数组类本身不通过类加载器创建，由虚拟机直接创建</li>
<li>内存中实例化的Class对象并不是在堆中，存放于方法区（HotSpot虚拟机）<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4>验证的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求。<br>主要完成以下4个检验动作：</li>
</ul>
<ol>
<li>文件格式验证：如魔数、版本号、常量类型….</li>
<li>元数据验证：这个类是否有父类？是不是抽象类？是否继承了不允许被继承的类？</li>
<li>字节码验证：对类的方法体进行校验分析，确定程序语义是合法、符合逻辑的。</li>
<li>符号引用验证：（发生在解析阶段）符号引用中通过字符串描述的全限定名是否能找到对应的类？…</li>
</ol>
<p>验证阶段是一个很重要但不一定是必要的阶段。</p>
<h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p><strong>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。</strong>（这里的类变量仅为Static修饰的变量，不包括实例变量，实例变量是在对象实例化时随着对象分配在堆中）</p>
<p>假设一个类变量定义为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public static int value = 666;</div></pre></td></tr></table></figure></p>
<p>那么在准备阶段过后，初始值为0，而不是666，因为把value赋值为666的动作在初始化阶段才会执行。</p>
<p>但是下面这种情况除外：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public static final int value = 666;</div></pre></td></tr></table></figure>
<p>当用final修饰时，会在准备阶段赋值为666。</p>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p><strong>解析阶段是虚拟机将常量池中的符号引用替换为直接引用的过程。</strong>  </p>
<p><strong>符号引用</strong>：定义在Java虚拟机规范的Class文件格式中（与虚拟机内存布局无关）<br><strong>直接引用</strong>：直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。（与虚拟机内存布局相关）</p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>类初始化阶段是类加载过程的最后一步。<strong>初始化阶段才真正开始执行类中定义的Java程序代码。</strong></p>
<p>在准备阶段，类变量被赋了初始值，在初始化阶段才会真正赋值。或者说，初始化阶段是执行类构造器<clinit>()方法的过程。</clinit></p>
<h5 id="方法"><a href="#方法" class="headerlink" title="()方法"></a><clinit>()方法</clinit></h5><ul>
<li><clinit>()方法是编译器自动收集类中的所有变量的赋值动作和静态语句块（static{}）中的语句合并产生的，顺序由源文件顺序决定。</clinit></li>
<li><clinit>()方法与类的构造函数不同（实例构造器<init>()），它不需要显示地调用父类构造器，虚拟机保证子类<clinit>()方法执行之前，父类<clinit>()方法已经执行完毕。因此，JVM中第一个执行的<clinit>()方法的类是java.lang.Object。</clinit></clinit></clinit></init></clinit></li>
<li><clinit>()方法对于类或接口来说不是必须的，一个类没有静态语句块或者没有对变量的赋值操作，可以没有<clinit>()方法</clinit></clinit></li>
<li>接口中有变量初始化赋值的操作时，会生成<clinit>()方法。但接口不需要执行父接口的<clinit>()方法。接口的实现类在初始化时也不要=会执行接口的<clinit>()方法。</clinit></clinit></clinit></li>
<li>虚拟机保证一个类的<clinit>()方法会在多线程情况下加锁、同步。只有一个线程会执行<clinit>()方法成功。</clinit></clinit></li>
</ul>
<h3 id="三、类加载器"><a href="#三、类加载器" class="headerlink" title="三、类加载器"></a>三、类加载器</h3><p>在加载阶段中，<strong>“通过一个类的全限定名来获取定义此类的二进制字节流”这个动作的实现是由类加载器来完成的。</strong><br>这个动作在JVM外部实现，以便让应用程序自己决定如何去获取所需要的类。</p>
<p><strong>简而言之，类加载器用于实现类的加载动作。</strong></p>
<p>只有由同一个类加载器加载的两个类才相等。若同一个Class文件由不同的类加载器加载，则不相等。</p>
<h4 id="3种类加载器"><a href="#3种类加载器" class="headerlink" title="3种类加载器"></a>3种类加载器</h4><p><img src="http://osuskkx7k.bkt.clouddn.com/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8.png" alt="image"></p>
<ul>
<li><strong>启动类加载器（Bootstrap ClassLoader）</strong>：负责加载<java_home>\lib目录中，或者被-Xbootclasspath参数所指定的路径中，并且被虚拟机识别的如rt.jar等类库</java_home></li>
<li><strong>扩展类加载器（Extension ClassLoader）</strong>：加载<java_home>\lib\ext目录中的，或通过java.ext.dirs系统变量指定路径中的类库</java_home></li>
<li><strong>应用程序类加载器（Application ClassLoader</strong>）：加载用户类路径（ClassPath）上指定的类库，也叫系统类加载器，程序默认的类加载器</li>
</ul>
<h4 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h4><p>工作过程：<strong>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此。因此所有的加载请求最终都会传送到顶层的启动类加载器中，只有当父加载器无法完成这个加载请求时，子加载器才会自己去加载。</strong></p>
<p>双亲委派模型有什么好处？  </p>
<p>保证了Java程序的稳定运行。<br>例如，java.lang.Object存放在rt.jar中，无论哪一个类加载器加载这个类，最终都会委派给启动类加载器进行加载，<strong>因此Object类在程序的各种类加载器环境中都是同一个类。</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、类加载机制&quot;&gt;&lt;a href=&quot;#一、类加载机制&quot; class=&quot;headerlink&quot; title=&quot;一、类加载机制&quot;&gt;&lt;/a&gt;一、类加载机制&lt;/h3&gt;&lt;p&gt;虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被J
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
      <category term="类加载机制" scheme="http://yoursite.com/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
</feed>
