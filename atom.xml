<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZY&#39;s Blog</title>
  <subtitle>Young for you.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-02-24T17:54:29.392Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Z Yong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java并发之Executor框架</title>
    <link href="http://yoursite.com/2017/11/22/Java%E5%B9%B6%E5%8F%91%E4%B9%8BExecutor%E6%A1%86%E6%9E%B6/"/>
    <id>http://yoursite.com/2017/11/22/Java并发之Executor框架/</id>
    <published>2017-11-22T08:42:18.000Z</published>
    <updated>2018-02-24T17:54:29.392Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、Executor框架的介绍"><a href="#一、Executor框架的介绍" class="headerlink" title="一、Executor框架的介绍"></a>一、Executor框架的介绍</h3><p>Java中的线程既是工作单元又是执行机制。JDK1.5开始，把工作单元与执行机制分离开来。<strong>工作单元为Runnable（Thread实现该接口）和Callable，执行机制就是Executor框架。</strong> 使用Executor框架时不用显式的创建线程Thread。</p>
<p>Executor框架由三部分组成：  </p>
<ul>
<li><strong>任务</strong>：Runnable或Callable  </li>
<li><strong>任务的执行</strong>：ExecutorService接口及其实现。  </li>
<li><strong>异步计算的结果</strong>：Future接口或其实现类FutureTask</li>
</ul>
<h4 id="Executor的结构"><a href="#Executor的结构" class="headerlink" title="Executor的结构"></a>Executor的结构</h4><p><img src="http://osuskkx7k.bkt.clouddn.com/Executor1.png" alt="image"></p>
<h4 id="Executor接口"><a href="#Executor接口" class="headerlink" title="Executor接口"></a><strong>Executor接口</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Executor &#123;</div><div class="line">        void execute(Runnable command);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>Executor接口中只有一个execute()方法，用来执行已经提交的Runnable实例，可见即使是Callable实例，最后也会被封装成Runnable来执行。</strong></p>
<h4 id="ExecutorService接口"><a href="#ExecutorService接口" class="headerlink" title="ExecutorService接口"></a><strong>ExecutorService接口</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public interface ExecutorService extends Executor &#123;</div><div class="line">        void shutdown();</div><div class="line">        List&lt;Runnable&gt; shutdownNow();</div><div class="line">        &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);</div><div class="line">        &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);</div><div class="line">        Future&lt;?&gt; submit(Runnable task);</div><div class="line">        ....</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><strong>ExecutorService扩展了Executor接口，添加了许多方法用于服务、管理和关闭线程池。</strong><br>submit()方法最终执行时也是调用了execute()方法。</p>
<p>ExecutorService接口有两个实现类，ThreadPoolExecutor（核心）和ScheduledThreadPoolExecutor（定时执行）。</p>
<h4 id="Executors工具类"><a href="#Executors工具类" class="headerlink" title="Executors工具类"></a><strong>Executors工具类</strong></h4><p><strong>Executors工具类中包含了许多静态工厂方法。采用了多方法静态工厂模式。</strong> 本质是根据不同的输入创建出不同类型的对象。</p>
<p>通过Executors工具类可以创建3种类型的线程池，即3种ThreadPoolExecutor对象。实质是创建ThreadPoolExecutor时传入的参数不同。</p>
<h3 id="二、3种常用线程池"><a href="#二、3种常用线程池" class="headerlink" title="二、3种常用线程池"></a>二、3种常用线程池</h3><h4 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h4><p><strong>FixedThreadPool是固定大小的线程池。内部线程可重用。</strong><br>Executors工具类中的静态方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</div><div class="line">        return new ThreadPoolExecutor(nThreads, nThreads,</div><div class="line">                                      0L, TimeUnit.MILLISECONDS,</div><div class="line">                                      new LinkedBlockingQueue&lt;Runnable&gt;());</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p><strong>特点</strong>：</p>
<ol>
<li>参数corePoolSize和maximumPoolSize大小都是nThreads，说明最大线程数就是核心线程数，所以线程大小固定</li>
<li>参数keepAliveTime为0L，说明不会有空闲的线程</li>
<li>参数BlockingQueue是无界队列LinkedBlockingQueue，说明任务会一直放入，不会采用饱和策略。</li>
</ol>
<p><strong>应用场景</strong>：需要限制线程数量，适用于负载较重的服务器</p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/fixed.png" alt="image"></p>
<p><strong>工作过程</strong>：</p>
<ol>
<li>当前线程数小于corePoolSize，创建新线程执行任务</li>
<li>当前线程数等于corePoolSize，任务加入阻塞队列</li>
<li>线程反复执行阻塞队列中的任务</li>
</ol>
<h4 id="SingleThreadExecutor"><a href="#SingleThreadExecutor" class="headerlink" title="SingleThreadExecutor"></a>SingleThreadExecutor</h4><p><strong>SingleThreadExecutor是只有一个线程的线程池。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public static ExecutorService newSingleThreadExecutor() &#123;</div><div class="line">        return new FinalizableDelegatedExecutorService</div><div class="line">            (new ThreadPoolExecutor(1, 1,</div><div class="line">                                    0L, TimeUnit.MILLISECONDS,</div><div class="line">                                    new LinkedBlockingQueue&lt;Runnable&gt;()));</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><strong>特点</strong>：</p>
<ol>
<li>参数corePoolSize和maximumPoolSize大小都是1，说明线程数固定为1</li>
<li>参数keepAliveTime为0L，说明不会有空闲的线程</li>
<li>参数BlockingQueue是无界队列LinkedBlockingQueue，说明任务会一直放入，不会采用饱和策略。</li>
</ol>
<p><strong>应用场景</strong>：<strong>适用于执行的任务需要保证顺序；并且在任意时间点，不会有多个线程是活动的场景。</strong></p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/single1.png" alt="image"></p>
<p><strong>工作过程</strong>：</p>
<ol>
<li>当前线程数小于1，创建一个唯一的线程执行任务</li>
<li>当前线程数等于1，任务加入阻塞队列</li>
<li>这个唯一的线程反复执行阻塞队列中的任务</li>
</ol>
<h4 id="CachedThreadPool"><a href="#CachedThreadPool" class="headerlink" title="CachedThreadPool"></a>CachedThreadPool</h4><p><strong>CachedThreadPool是一个根据需要创建线程的线程池。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public static ExecutorService newCachedThreadPool() &#123;</div><div class="line">        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</div><div class="line">                                      60L, TimeUnit.SECONDS,</div><div class="line">                                      new SynchronousQueue&lt;Runnable&gt;());</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><strong>特点</strong>：</p>
<ol>
<li>参数corePoolSize为0，maximumPoolSize为Integer.MAX_VALUE（2147483647），说明可创建的线程数巨大，且都是可销毁的</li>
<li>参数keepAliveTime为60L，说明空闲的线程等待时间最长60s</li>
<li>参数BlockingQueue是一个没有容量的阻塞队列SynchronousQueue，说明任务会一直被线程执行。</li>
</ol>
<p><strong>应用场景</strong>：<strong>大小无界的线程池，适用于执行很多的短期异步任务的小程序，或者负载较轻的服务器。<br>注：使用时需控制并发的任务数，否则创建大量的线程可能导致严重的性能问题。</strong></p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/cached1.png" alt="image"></p>
<p><strong>工作过程</strong>：</p>
<ol>
<li>首先执行SynchronousQueue.offer()，如果有空闲的线程在执行SynchronousQueue.poll()，表示配对成功，任务交给空闲线程执行。</li>
<li>初始化时，如果没有空闲的线程，那么创建一个新的线程执行任务。</li>
<li>步骤2中的线程任务完成后，会执行SynchronousQueue.poll()等待60s，若没有任务提交，则该空闲线程销毁。</li>
</ol>
<p>SynchronousQueue队列的每个插入操作都要等待一个移除操作，因此是没有容量的队列。</p>
<hr>
<p>除上述3种常用线程池外，Executors还可以创建以下几种线程池。</p>
<p><strong>newScheduledThreadPool</strong>：可以定时或周期性执行任务的线程池（线程数目指定）</p>
<p><strong>newSingleThreadScheduledExecutor：</strong> 可以定时或周期性执行任务的线程池。只有一个线程。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、Executor框架的介绍&quot;&gt;&lt;a href=&quot;#一、Executor框架的介绍&quot; class=&quot;headerlink&quot; title=&quot;一、Executor框架的介绍&quot;&gt;&lt;/a&gt;一、Executor框架的介绍&lt;/h3&gt;&lt;p&gt;Java中的线程既是工作单元又是执行
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="Executor框架" scheme="http://yoursite.com/tags/Executor%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Java线程池的实现分析</title>
    <link href="http://yoursite.com/2017/11/18/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2017/11/18/Java线程池的实现分析/</id>
    <published>2017-11-18T12:42:18.000Z</published>
    <updated>2018-02-24T17:52:30.529Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、线程池的介绍"><a href="#一、线程池的介绍" class="headerlink" title="一、线程池的介绍"></a>一、线程池的介绍</h3><p>线程池是一种并发框架。</p>
<p>优势：</p>
<ol>
<li><strong>降低资源消耗。</strong>（重复利用线程，减少开销）</li>
<li><strong>提高响应速度。</strong>（任务到达可直接执行，不需要等待创建线程）</li>
<li><strong>提高线程的可管理性</strong>。（统一分配、监控、调优）</li>
</ol>
<p><strong>ThreadPoolExecutor是线程池的核心实现类</strong>。可以通过ThreadPoolExecutor来创建一个线程池。</p>
<h3 id="二、线程池的实现分析"><a href="#二、线程池的实现分析" class="headerlink" title="二、线程池的实现分析"></a>二、线程池的实现分析</h3><p>线程池的实现是ThreadPoolExecutor类，因此重点描述ThreadPoolExecutor类的实现。  </p>
<h4 id="ThreadPoolExecutor的结构"><a href="#ThreadPoolExecutor的结构" class="headerlink" title="ThreadPoolExecutor的结构"></a>ThreadPoolExecutor的结构</h4><p>ThreadPoolExecutor的构造方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public ThreadPoolExecutor(int corePoolSize,</div><div class="line">                              int maximumPoolSize,</div><div class="line">                              long keepAliveTime,</div><div class="line">                              TimeUnit unit,</div><div class="line">                              BlockingQueue&lt;Runnable&gt; workQueue,</div><div class="line">                              ThreadFactory threadFactory,</div><div class="line">                              RejectedExecutionHandler handler) &#123;</div><div class="line">        ...(省略部分)</div><div class="line">        this.corePoolSize = corePoolSize;</div><div class="line">        this.maximumPoolSize = maximumPoolSize;</div><div class="line">        this.workQueue = workQueue;</div><div class="line">        this.keepAliveTime = unit.toNanos(keepAliveTime);</div><div class="line">        this.threadFactory = threadFactory;</div><div class="line">        this.handler = handler;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>构造函数中省略了部分判断的代码。<br>主要有7个参数：  </p>
<p><strong>corePoolSize</strong>：核心线程池的大小  </p>
<p><strong>maximumPoolSize</strong>：线程池的大小  </p>
<p><strong>keepAliveTime</strong>：存活时间（超过核心数目的线程空闲后的存活时间）  </p>
<p><strong>TimeUnit</strong>：时间单位  </p>
<p><strong>BlockingQueue<runnable></runnable></strong>：任务队列（保存等待任务的阻塞队列）  </p>
<p><strong>ThreadFactory</strong>：创建线程的工厂类   </p>
<p><strong>RejectedExecutionHandler</strong> ：饱和策略（拒绝策略）</p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/%E7%BA%BF%E7%A8%8B%E6%B1%A0.png" alt="image"></p>
<h4 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h4><p>当提交一个新任务时，线程池的工作过程：</p>
<ol>
<li><p><strong>判断核心线程池（corePool）中的线程是否都在执行任务。如果不是，创建一个新的线程执行任务。核心线程池已满，进入2</strong>；  </p>
</li>
<li><p><strong>判断任务队列是否已满。未满，则将新的任务存入；满了，进入3；</strong></p>
</li>
<li><strong>判断线程池（maximumPoolSize）里的线程是否都在工作。如果没有，创建一个新的线程执行任务；否则，交给饱和策略4</strong>；</li>
<li><strong>根据不同的饱和策略处理这个任务</strong>。</li>
</ol>
<p><img src="http://osuskkx7k.bkt.clouddn.com/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B.png" alt="image"></p>
<p>饱和策略有4种：</p>
<ul>
<li><strong>AbortPolicy（默认）</strong>：直接抛出异常</li>
<li><strong>CallerRunsPolicy</strong>：只用调用者所在线程来处理</li>
<li><strong>DiscardOldestPolicy</strong>：丢弃任务队列中最后一个任务，执行当前任务</li>
<li><strong>DiscardPolicy</strong>：不处理丢弃掉</li>
</ul>
<p>线程池回收线程时，对所谓的“核心线程”和“非核心线程”是一视同仁的，直到线程池中线程的数量等于corePoolSize参数时，回收过程才会停止。<br>如果设置的corePoolSize参数和maximumPoolSize参数一致时，线程池在任何情况下都不会回收空闲线程。keepAliveTime和timeUnit也就失去了意义。<br>可以调用以下方法回收核心线程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">threadPoolExecutor.allowCoreThreadTimeOut(true);</div></pre></td></tr></table></figure></p>
<h4 id="线程池处理任务"><a href="#线程池处理任务" class="headerlink" title="线程池处理任务"></a>线程池处理任务</h4><p>线程池处理任务的方法主要有两种，execute()和submit()。</p>
<p><strong>execute()</strong>  </p>
<p><strong>execute()方法用于提交不需要返回值的任务</strong>，Runnable实例。所以无法判断任务是否被线程池执行成功。</p>
<p><strong>submit()</strong><br><strong>submit()方法用于提交需要返回值的任务</strong>。线程池会返回一个future类型的对象，通过这个对象可以判断任务是否执行成功。</p>
<p>future的get()方法会阻塞当前线程直到任务完成，返回结果。</p>
<p>submit()最终调用的也是execute(Runnable runable)，submit()只是将Callable或Runnable封装成一个FutureTask对象，因为FutureTask是个Runnable，所以调用的是execute()方法。</p>
<h4 id="线程池的关闭"><a href="#线程池的关闭" class="headerlink" title="线程池的关闭"></a>线程池的关闭</h4><p>线程池关闭的方法主要有两种，shutdown()和shutdownNow()。</p>
<p><strong>原理</strong>：遍历线程池中的工作线程，逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法停止。</p>
<p><strong>区别</strong>：<br><strong>shutdown()只是将线程池的状态设置成SHUTDOWN状态，然后中断没有在执行任务的线程。</strong></p>
<p><strong>shutdownNow()首先将线程池的状态设置成STOP，然后尝试停止所有正在执行或暂停任务的线程，并返回等待执行任务的列表。</strong></p>
<p>如果任务不一定要执行完，可以调用shutdownNow()方法。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、线程池的介绍&quot;&gt;&lt;a href=&quot;#一、线程池的介绍&quot; class=&quot;headerlink&quot; title=&quot;一、线程池的介绍&quot;&gt;&lt;/a&gt;一、线程池的介绍&lt;/h3&gt;&lt;p&gt;线程池是一种并发框架。&lt;/p&gt;
&lt;p&gt;优势：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;降低
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="Java线程池" scheme="http://yoursite.com/tags/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>ConcurrentHashMap在JDK1.8中的实现分析</title>
    <link href="http://yoursite.com/2017/11/10/ConcurrentHashMap%E5%9C%A8JDK1.8%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2017/11/10/ConcurrentHashMap在JDK1.8中的实现分析/</id>
    <published>2017-11-10T08:42:18.000Z</published>
    <updated>2018-02-24T17:40:51.020Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、ConcurrentHashMap的介绍"><a href="#一、ConcurrentHashMap的介绍" class="headerlink" title="一、ConcurrentHashMap的介绍"></a>一、ConcurrentHashMap的介绍</h3><p><strong>ConcurrentHashMap在JDK8中进行了巨大改动，它舍弃了锁分段的技术，大量引入了CAS操作，以此来实现并发操作。</strong>   </p>
<p>回忆JDK1.7中的ConcurrentHashmap，当hash碰撞频繁时，链表长度会拉长，而链表的增改删查操作都会消耗很长的时间，影响性能，因此和JDK1.8中的HashMap一样，当链表过长时，将其结构转化为红黑树，由此提高性能。</p>
<h3 id="二、ConcurrentHashMap的实现原理"><a href="#二、ConcurrentHashMap的实现原理" class="headerlink" title="二、ConcurrentHashMap的实现原理"></a>二、ConcurrentHashMap的实现原理</h3><p><strong>ConcurrentHashMap的结构图</strong></p>
<p>ConcurrentHashMap在JDK1.8的实现原理是“<strong>数组+链表+红黑树</strong>”。（与HashMap在1.8中的实现思想一致，但是<strong>红黑树的节点不同</strong>，HashMap是Node节点，ConcurrentHashMap是TreeBin对象）</p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/1.8hash.PNG" alt="image"></p>
<hr>
<p>下面介绍一下ConcurrentHashMap主要方法put()和get()的实现。</p>
<h4 id="put-方法"><a href="#put-方法" class="headerlink" title="put()方法"></a>put()方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line">final V putVal(K key, V value, boolean onlyIfAbsent) &#123;</div><div class="line">---第一部分</div><div class="line">        if (key == null || value == null) throw new NullPointerException();</div><div class="line">        //计算hash值</div><div class="line">        int hash = spread(key.hashCode());</div><div class="line">        int binCount = 0;</div><div class="line">        for (Node&lt;K,V&gt;[] tab = table;;) &#123;</div><div class="line">            Node&lt;K,V&gt; f; int n, i, fh;</div><div class="line">            //如果tab为null，则初始化</div><div class="line">            if (tab == null || (n = tab.length) == 0)</div><div class="line">                tab = initTable();</div><div class="line">            //判断数组索引位置的元素是否为null</div><div class="line">            else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123;</div><div class="line">                //CAS操作设置该数组索引位置为新节点Node</div><div class="line">                if (casTabAt(tab, i, null,</div><div class="line">                             new Node&lt;K,V&gt;(hash, key, value, null)))</div><div class="line">                    break;                   // no lock when adding to empty bin</div><div class="line">            &#125;</div><div class="line">            //f节点是MOVED节点，表示有其他线程在扩容，帮助一起扩容</div><div class="line">            else if ((fh = f.hash) == MOVED)</div><div class="line">                tab = helpTransfer(tab, f);</div><div class="line">                </div><div class="line">---第二部分-----</div><div class="line">            else &#123;</div><div class="line">                V oldVal = null;</div><div class="line">                synchronized (f) &#123;</div><div class="line">                    if (tabAt(tab, i) == f) &#123;</div><div class="line">                        //表示是链表，还未转化成红黑树</div><div class="line">                        if (fh &gt;= 0) &#123;</div><div class="line">                            binCount = 1;</div><div class="line">                            for (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</div><div class="line">                                K ek;</div><div class="line">                                //如果key已存在，则替换value</div><div class="line">                                if (e.hash == hash &amp;&amp;</div><div class="line">                                    ((ek = e.key) == key ||</div><div class="line">                                     (ek != null &amp;&amp; key.equals(ek)))) &#123;</div><div class="line">                                    oldVal = e.val;</div><div class="line">                                    if (!onlyIfAbsent)</div><div class="line">                                        e.val = value;</div><div class="line">                                    break;</div><div class="line">                                &#125;</div><div class="line">                                Node&lt;K,V&gt; pred = e;</div><div class="line">                                //将新的节点插入尾部</div><div class="line">                                if ((e = e.next) == null) &#123;</div><div class="line">                                    pred.next = new Node&lt;K,V&gt;(hash, key,</div><div class="line">                                                              value, null);</div><div class="line">                                    break;</div><div class="line">                                &#125;</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                        //节点f是TreeBin对象，表示链表转为了红黑树</div><div class="line">                        else if (f instanceof TreeBin) &#123;</div><div class="line">                            Node&lt;K,V&gt; p;</div><div class="line">                            binCount = 2;</div><div class="line">                            if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</div><div class="line">                                                           value)) != null) &#123;</div><div class="line">                                oldVal = p.val;</div><div class="line">                                if (!onlyIfAbsent)</div><div class="line">                                    p.val = value;</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                if (binCount != 0) &#123;</div><div class="line">                    //如果大于8，转化为红黑树</div><div class="line">                    if (binCount &gt;= TREEIFY_THRESHOLD)</div><div class="line">                        treeifyBin(tab, i);</div><div class="line">                    if (oldVal != null)</div><div class="line">                        return oldVal;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        addCount(1L, binCount);</div><div class="line">        return null;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>由于整个put()方法较长，分成两部分来分析。<br><strong>第一部分：</strong></p>
<ol>
<li>遍历数组tab，如果为null，初始化数组；</li>
<li><strong>调用tabAt()方法查找数组索引i处的节点f，如果f为null，说明该位置还没有节点，调用casTabAt()利用CAS操作插入新的节点</strong></li>
</ol>
<ul>
<li><strong>CAS成功</strong>：break跳出，直到最后的addCount(1L, binCount)方法，判断插入这一个节点后是否需要扩容; </li>
<li><strong>CAS失败</strong>：说明有其它线程提前插入了节点，自旋重新尝试在这个位置插入节点；<br>tabAt()和casTabAt()方法源码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"> private static final sun.misc.Unsafe U;</div><div class="line"> </div><div class="line">static final &lt;K,V&gt; Node&lt;K,V&gt; tabAt(Node&lt;K,V&gt;[] tab, int i) &#123;</div><div class="line">        return (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((long)i &lt;&lt; ASHIFT) + ABASE);</div><div class="line">    &#125;</div><div class="line">static final &lt;K,V&gt; boolean casTabAt(Node&lt;K,V&gt;[] tab, int i,</div><div class="line">                                        Node&lt;K,V&gt; c, Node&lt;K,V&gt; v) &#123;</div><div class="line">        return U.compareAndSwapObject(tab, ((long)i &lt;&lt; ASHIFT) + ABASE, c, v);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>可以看到，都是<strong>调用Unsafe类的方法（原子性），Unsafe.getObjectVolatile可以直接获取指定内存的数据，保证了每次拿到数据都是最新的。</strong></p>
<ol>
<li><strong>若前面的情况都不满足，判断f节点是否为MOVED节点，是则表示有其他线程在扩容，帮助一起扩容</strong>；否则进入第二部分。  </li>
</ol>
<p><strong>第二部分：</strong>  </p>
<p>第二部分表示把新的节点Node插入链表或红黑树，可以看到使用了synchronized关键字实现同步。<strong>但是注意，只在节点f上进行同步，表示只能有一个线程访问该节点。</strong> 节点插入之前，再次利用 tabAt(tab, i) == f 判断头节点是否还是f，防止被其它线程修改。</p>
<ol>
<li>如果f.hash &gt;= 0，说明f是链表结构的头结点，遍历链表，如果key已存在，则修改value，否则在链表尾部插入节点。</li>
<li>如果f是TreeBin类型节点，说明链表变成红黑树，则在树结构上遍历元素，更新或增加节点。</li>
<li>最后判断链表中的节点数binCount &gt;= 8，则转化为红黑树。</li>
</ol>
<hr>
<h4 id="get-方法"><a href="#get-方法" class="headerlink" title="get()方法"></a>get()方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public V get(Object key) &#123;</div><div class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek;</div><div class="line">        //获取key的hash值</div><div class="line">        int h = spread(key.hashCode());</div><div class="line">        if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</div><div class="line">            (e = tabAt(tab, (n - 1) &amp; h)) != null) &#123;</div><div class="line">            if ((eh = e.hash) == h) &#123;</div><div class="line">                if ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))</div><div class="line">                    return e.val;</div><div class="line">            &#125;</div><div class="line">            else if (eh &lt; 0)</div><div class="line">                return (p = e.find(h, key)) != null ? p.val : null;</div><div class="line">            //遍历    </div><div class="line">            while ((e = e.next) != null) &#123;</div><div class="line">                if (e.hash == h &amp;&amp;</div><div class="line">                    ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek))))</div><div class="line">                    return e.val;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return null;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ol>
<li>如果table为null或者遍历之后没找到对应的value，返回null；</li>
<li>根据key的hash值找到table中指定的Node节点，遍历链表或红黑树找到对应的value值。<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4></li>
</ol>
<p>最后总结一下<strong>ConcurrentHashMap从JDK1.7（1.6）到JDK1.8的变化</strong>：</p>
<ol>
<li><strong>底层结构改变</strong>，从“<strong>数组+数组+链表</strong>”到“<strong>数组+链表+红黑树</strong>”</li>
<li><strong>锁方式改变，取消了Segment重入锁，变成CAS+Synchronized实现锁</strong></li>
<li><strong>锁粒度变小</strong>，<strong>由Segment数组变成table的元素</strong>。</li>
<li>JDK1.8中size()实现更简单</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、ConcurrentHashMap的介绍&quot;&gt;&lt;a href=&quot;#一、ConcurrentHashMap的介绍&quot; class=&quot;headerlink&quot; title=&quot;一、ConcurrentHashMap的介绍&quot;&gt;&lt;/a&gt;一、ConcurrentHashMap的
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="ConcurrentHashMap" scheme="http://yoursite.com/tags/ConcurrentHashMap/"/>
    
      <category term="JDK1.8" scheme="http://yoursite.com/tags/JDK1-8/"/>
    
  </entry>
  
  <entry>
    <title>ConcurrentHashMap在JDK1.7中的实现分析</title>
    <link href="http://yoursite.com/2017/11/06/ConcurrentHashMap%E5%9C%A8JDK1.7%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2017/11/06/ConcurrentHashMap在JDK1.7中的实现分析/</id>
    <published>2017-11-06T09:48:18.000Z</published>
    <updated>2018-02-24T17:36:40.387Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、ConcurrentHashMap的介绍"><a href="#一、ConcurrentHashMap的介绍" class="headerlink" title="一、ConcurrentHashMap的介绍"></a>一、ConcurrentHashMap的介绍</h3><p>ConcurrentHashMap是线程安全且高效的HashMap，可以在多线程的环境下使用。<br><strong>ConcurrentHashMap允许多个线程并发访问，其关键在于使用了锁分段技术。</strong><br>锁分段：首先将数据分成一段一段地存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个数据段的时候，其他数据段也能被其他线程访问。</p>
<h3 id="二、ConcurrentHashMap的实现原理"><a href="#二、ConcurrentHashMap的实现原理" class="headerlink" title="二、ConcurrentHashMap的实现原理"></a>二、ConcurrentHashMap的实现原理</h3><p><strong>ConcurrentHashMap的结构图</strong>  </p>
<p>ConcurrentHashMap在JDK1.8之前的实现原理是“<strong>数组+数组+链表</strong>”。（可能描述不妥）<br><img src="http://osuskkx7k.bkt.clouddn.com/concurrentHashmap.PNG" alt="image"></p>
<p>第一个数组是Segment[ ]，每一个Segment类似于HashMap；<br>第二个数组是HashEntry[ ]，每个元素可能是一个链表；<br>链表是HashEntry形成的链表，HashEntry是一个节点。</p>
<hr>
<h4 id="HashEntry类"><a href="#HashEntry类" class="headerlink" title="HashEntry类"></a>HashEntry类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">static final class HashEntry&lt;K,V&gt; &#123;</div><div class="line">        final int hash;</div><div class="line">        final K key;</div><div class="line">        volatile V value;</div><div class="line">        volatile HashEntry&lt;K,V&gt; next;</div><div class="line">        ....</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>HashEntry类相当于HashMap中的Entry类（节点类），储存了key和value，并拥有指向下一个元素的引用next。<br>注：<strong>value采用volatile修饰，保证了线程之间的可见性</strong>。</p>
<h4 id="Segment类"><a href="#Segment类" class="headerlink" title="Segment类"></a>Segment类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">static final class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable &#123;</div><div class="line"></div><div class="line">        transient volatile HashEntry&lt;K,V&gt;[] table;</div><div class="line">        transient int count;</div><div class="line">        transient int modCount;</div><div class="line">        transient int threshold;</div><div class="line">        final float loadFactor; </div><div class="line">        ....</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>每个Segment都拥有一个HashEntry[]数组，还有threshold和loadFactor分别表示极限容量和负载因子，count表示元素个数，modCount表示修改的记录。如此看来，<strong>每个Segment就好比是一个缩小版的HashMap</strong>，从上面ConcurrentHashMap结构图也可以看出来。</p>
<p><strong>Segment继承自ReentrantLock重入锁，因此它支持一个线程重进入同一个Segment，访问其中的数据。</strong></p>
<hr>
<p>下面介绍一下ConcurrentHashMap主要的几个方法的实现:put()方法、get()方法、size()方法</p>
<h4 id="put-方法"><a href="#put-方法" class="headerlink" title="put()方法"></a>put()方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public V put(K key, V value) &#123;</div><div class="line">        Segment&lt;K,V&gt; s;</div><div class="line">        if (value == null)</div><div class="line">            throw new NullPointerException();</div><div class="line">        int hash = hash(key);</div><div class="line">        int j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</div><div class="line">        if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject</div><div class="line">             (segments, (j &lt;&lt; SSHIFT) + SBASE)) == null) </div><div class="line">            // 扩容 </div><div class="line">            s = ensureSegment(j);</div><div class="line">        return s.put(key, hash, value, false);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>首先定位到相应的Segment。<br>如果需要扩容则进入ensureSegment(j)方法，<strong>注意ConcurrentHashMap不会对整个容器扩容，而只对当前的Segment进行扩容。</strong>  扩容为原来的2倍。<br>如果不需要扩容，调用Segment中的put()方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">final V put(K key, int hash, V value, boolean onlyIfAbsent) &#123;</div><div class="line">            HashEntry&lt;K,V&gt; node = tryLock() ? null :</div><div class="line">                scanAndLockForPut(key, hash, value);</div><div class="line">            V oldValue;</div><div class="line">            try &#123;</div><div class="line">                HashEntry&lt;K,V&gt;[] tab = table;</div><div class="line">                int index = (tab.length - 1) &amp; hash;</div><div class="line">                //取出头节点</div><div class="line">                HashEntry&lt;K,V&gt; first = entryAt(tab, index);</div><div class="line">                //遍历链表</div><div class="line">                for (HashEntry&lt;K,V&gt; e = first;;) &#123;</div><div class="line">                    if (e != null) &#123;</div><div class="line">                        K k;</div><div class="line">                        //key已存在，替换value</div><div class="line">                        if ((k = e.key) == key ||</div><div class="line">                            (e.hash == hash &amp;&amp; key.equals(k))) &#123;</div><div class="line">                            oldValue = e.value;</div><div class="line">                            if (!onlyIfAbsent) &#123;</div><div class="line">                                e.value = value;</div><div class="line">                                ++modCount;</div><div class="line">                            &#125;</div><div class="line">                            break;</div><div class="line">                        &#125;</div><div class="line">                        e = e.next;</div><div class="line">                    &#125;</div><div class="line">                    else &#123;</div><div class="line">                        //scanAndLockForPut()方法中已经返回了node，设置为first节点</div><div class="line">                        if (node != null)</div><div class="line">                            node.setNext(first);</div><div class="line">                        else</div><div class="line">                            //新建HashEntry节点作为头节点first</div><div class="line">                            node = new HashEntry&lt;K,V&gt;(hash, key, value, first);</div><div class="line">                        int c = count + 1;</div><div class="line">                        //判断是否扩容</div><div class="line">                        if (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</div><div class="line">                            rehash(node);</div><div class="line">                        else</div><div class="line">                            setEntryAt(tab, index, node);</div><div class="line">                        ++modCount; //记录修改次数</div><div class="line">                        count = c;  //修改count值</div><div class="line">                        oldValue = null;</div><div class="line">                        break;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125; finally &#123;</div><div class="line">                unlock();</div><div class="line">            &#125;</div><div class="line">            return oldValue;</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p>
<p>过程分析：  </p>
<ol>
<li>首先调用tryLock()方法尝试获取锁，如果获取失败，则进入scanAndLockForPut()方法，该方法实际上是先自旋一定的次数等待其他线程释放锁。若自旋过程中，其他线程释放了锁，导致本线程直接获得了锁，就避免了本线程进入等待锁的场景，提高了效率。若自旋一定次数后，仍未获取锁，则调用lock方法进入等待锁的场景。（这是JDK1.7的实现，如果是1.6则没有自旋，直接获取锁）</li>
<li>获取锁成功，找到对应的链表作相应的操作。具体见代码注释。</li>
</ol>
<h4 id="get-方法"><a href="#get-方法" class="headerlink" title="get()方法"></a>get()方法</h4><p>get()方法不需要锁。<strong>因为value字段是volatile修饰，保证了线程之间的可见性，可以被多线程同时读，但只能被单线程写。一句话，get操作只需要读共享变量value，所以不用加锁。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public V get(Object key) &#123;</div><div class="line">        Segment&lt;K,V&gt; s; // manually integrate access methods to reduce overhead</div><div class="line">        HashEntry&lt;K,V&gt;[] tab;</div><div class="line">        int h = hash(key); //第一次散列</div><div class="line">        //第二次散列</div><div class="line">        long u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</div><div class="line">        if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != null &amp;&amp;</div><div class="line">            (tab = s.table) != null) &#123;</div><div class="line">            //第三次散列（for循环中）</div><div class="line">            //遍历链表</div><div class="line">            for (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile</div><div class="line">                     (tab, ((long)(((tab.length - 1) &amp; h)) &lt;&lt; TSHIFT) + TBASE);</div><div class="line">                 e != null; e = e.next) &#123;</div><div class="line">                K k;</div><div class="line">                if ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))</div><div class="line">                    return e.value;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return null;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>（get()方法中用到了许多UNSAFE类的方法，这是在JDK1.6中没有的，主要是利用Native方法来快速的定位元素。）  </p>
<p>get()的过程经过了三次散列：  </p>
<p><strong>第一次：对key进行散列得到h<br>第二次：对h进行散列定位到哪个Segment<br>第三次：对h进行散列定位到哪个HashEntry</strong> </p>
<p>定位到HashEntry之后就对该链表遍历，查找key对应的value，若没有找到则返回null。  </p>
<h4 id="size-方法"><a href="#size-方法" class="headerlink" title="size()方法"></a>size()方法</h4><p><strong>size()方法需要跨Segment操作，因为要统计每个Segment中的count值。而count值是volatile变量，一般来说将所有的count变量相加就可以得到整个ConcurrentHashMap的大小。</strong> 但可能在累加前使用的count发生了变化，那么结果就不正确。那么该如何统计呢？</p>
<ol>
<li>第一种方法，将所有Segment的put、remove、clean方法都锁住，然后统计count值。做法可行，但是低效。</li>
<li><strong>第二种方法，先尝试连续2次不通过锁住Segment的方式计算各个count值的和：</strong></li>
</ol>
<ul>
<li>若没有发生变化，则作为size的大小。</li>
<li>若发生变化说明有线程在操作元素，则锁住Segment统计所有的count值。</li>
</ul>
<p><strong>如何判断容器大小没有发生变化？</strong>   </p>
<p><strong>modCount变量。这个变量记录了每个Segment中put、remove、clean等操作的次数，因此在连续两次统计count的值时，比较modCount是否变化，就可得知容器大小是否变化。</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、ConcurrentHashMap的介绍&quot;&gt;&lt;a href=&quot;#一、ConcurrentHashMap的介绍&quot; class=&quot;headerlink&quot; title=&quot;一、ConcurrentHashMap的介绍&quot;&gt;&lt;/a&gt;一、ConcurrentHashMap的
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="ConcurrentHashMap" scheme="http://yoursite.com/tags/ConcurrentHashMap/"/>
    
      <category term="JDK1.7" scheme="http://yoursite.com/tags/JDK1-7/"/>
    
  </entry>
  
  <entry>
    <title>HashMap引发的线程安全问题</title>
    <link href="http://yoursite.com/2017/11/03/HashMap%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2017/11/03/HashMap引发的线程安全问题/</id>
    <published>2017-11-03T09:48:18.000Z</published>
    <updated>2018-02-24T17:48:06.945Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、线程安全性"><a href="#一、线程安全性" class="headerlink" title="一、线程安全性"></a>一、线程安全性</h3><p>我们知道，HashMap是非线程安全的，只能在单线程的情况下使用。那么为什么不能在并发的情况下使用呢？<strong>因为在并发时，HashMap的扩容会产生错误而形成环形链表，导致读取数据时发生死循环</strong>。</p>
<p>回忆前面描述的扩容过程，调用了transfer()方法将旧链表转化为新链表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">void transfer(Entry[] newTable) &#123;  </div><div class="line">    Entry[] src = table;  </div><div class="line">    int newCapacity = newTable.length;  </div><div class="line">    for (int j = 0; j &lt; src.length; j++) &#123;  </div><div class="line">        Entry&lt;K,V&gt; e = src[j];  </div><div class="line">        if (e != null) &#123;  </div><div class="line">            src[j] = null;  </div><div class="line">            do &#123;  </div><div class="line">                Entry&lt;K,V&gt; next = e.next;  </div><div class="line">                int i = indexFor(e.hash, newCapacity);  </div><div class="line">                e.next = newTable[i];  </div><div class="line">                newTable[i] = e;  </div><div class="line">                e = next;  </div><div class="line">            &#125; while (e != null);  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>关键代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">do &#123;  </div><div class="line">Entry&lt;K,V&gt; next = e.next;  </div><div class="line">int i = indexFor(e.hash, newCapacity);  </div><div class="line">e.next = newTable[i];  </div><div class="line">newTable[i] = e;  </div><div class="line">e = next;  </div><div class="line">&#125; while (e != null);</div></pre></td></tr></table></figure>
<p>循环操作将旧链表中的节点放入新链表，直到下一个节点next为null。<br>分别在单线程和多线程的环境下描述扩容过程。</p>
<h4 id="单线程扩容"><a href="#单线程扩容" class="headerlink" title="单线程扩容"></a>单线程扩容</h4><p>假设hash数组的大小为2，负载因子为1，即超过1×2=2个元素时扩容，添加3个元素5、7、3，数组大小扩大为4，扩容过程如下：</p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/h1.png?imageView2/2/w/900/h/450" alt="image"></p>
<p>原链表中3个元素，循环3次，具体如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">第一次循环</div><div class="line">e = 3,next = 7</div><div class="line">3.next = tab[i] = null  (此时数组tab[i]为空)</div><div class="line">tab[i] = 3</div><div class="line">e = 7 </div><div class="line"></div><div class="line">第二次循环</div><div class="line">e = 7,next = 5</div><div class="line">7.next = tab[i] = 3</div><div class="line">tab[i] = 7</div><div class="line">e = 5</div><div class="line"></div><div class="line">第三次循环</div><div class="line">e = 5,next = null</div><div class="line">5.next = tab[i2] = null  (此时数组tab[i2]为空)</div><div class="line">tab[i2] = 5</div><div class="line">e = null </div><div class="line"></div><div class="line">(停止循环)</div></pre></td></tr></table></figure></p>
<h4 id="多线程扩容"><a href="#多线程扩容" class="headerlink" title="多线程扩容"></a>多线程扩容</h4><p>为什么多线程环境下扩容会形成环形链表呢？<br>还是刚刚的例子，两个线程并发执行，线程1在进入do循环的第一行挂起，线程2继续执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">do &#123;  </div><div class="line">    Entry&lt;K,V&gt; next = e.next;  //线程1在此处挂起</div><div class="line">    int i = indexFor(e.hash, newCapacity);  </div><div class="line">    e.next = newTable[i];  </div><div class="line">    newTable[i] = e;  </div><div class="line">    e = next;  </div><div class="line">    &#125; while (e != null);</div></pre></td></tr></table></figure>
<p>由前面单线程的情况可知，线程2此时成功扩容，结果如下：</p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/h2.png" alt="image"></p>
<p>线程1恢复执行，已知线程1的 e 指向了key(3)，而next指向了key(7)，扩容过程如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">第一次循环</div><div class="line">e = 3,next = 7</div><div class="line">3.next = tab[i] = null  (此时数组tab[i]为空)</div><div class="line">tab[i] = 3</div><div class="line">e = 7 </div><div class="line"></div><div class="line">第二次循环</div><div class="line">e = 7,next = 3</div><div class="line">7.next = tab[i] = 3</div><div class="line">tab[i] = 7</div><div class="line">e = 3</div><div class="line"></div><div class="line">第三次循环</div><div class="line">e = 3,next = null</div><div class="line">3.next = tab[i] = 7</div><div class="line">tab[i] = 3</div><div class="line">e = null</div><div class="line"></div><div class="line">(停止循环)</div></pre></td></tr></table></figure>
<p>第一次循环图：  </p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/h3.png" alt="image">  </p>
<p>第二次循环图：</p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/h22.png" alt="image"></p>
<p>第三次循环图：</p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/h4.png" alt="image"></p>
<p>在停止循环后，问题就出现了，如图所示，key(3)和key(7)构成了环形链表。<br><strong>于是，当我们调用HashMap的get方法时，由于查找链表节点时无法退出，就会产生无限循环。</strong></p>
<h3 id="二、解决方法"><a href="#二、解决方法" class="headerlink" title="二、解决方法"></a>二、解决方法</h3><p>解决方法就是采用同步的数据结构，主要有以下三种：</p>
<ol>
<li><strong>Hashtable</strong></li>
<li><strong>Collections.synchronizedMap()</strong></li>
<li><strong>ConcurrentHashMap</strong></li>
</ol>
<h4 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h4><p>Hashtable是线程安全的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public synchronized V put(K key, V value) &#123;...&#125;</div><div class="line"></div><div class="line">public synchronized V get(Object key) &#123;...&#125;</div></pre></td></tr></table></figure>
<p>可以看到，<strong>Hashtable是通过在方法上加上synchronized关键字来实现同步功能的</strong>。当一个线程访问时，其他线程都被阻塞住，这种方式效率很低，目前几乎不被使用。</p>
<h4 id="Collections-synchronizedMap"><a href="#Collections-synchronizedMap" class="headerlink" title="Collections.synchronizedMap()"></a>Collections.synchronizedMap()</h4><p>调用Collections的synchronizedMap()方法，传入一个Map，可以得到一个线程安全的SynchronizedMap。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">private static class SynchronizedMap&lt;K,V&gt;</div><div class="line">        implements Map&lt;K,V&gt;, Serializable &#123;</div><div class="line">        private final Map&lt;K,V&gt; m;     </div><div class="line">        final Object      mutex;        // Object on which to synchronize</div><div class="line"></div><div class="line">        SynchronizedMap(Map&lt;K,V&gt; m) &#123;</div><div class="line">            this.m = Objects.requireNonNull(m);</div><div class="line">            mutex = this;</div><div class="line">        &#125;</div><div class="line">        ....</div><div class="line">        public V get(Object key) &#123;</div><div class="line">            synchronized (mutex) &#123;return m.get(key);&#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public V put(K key, V value) &#123;</div><div class="line">            synchronized (mutex) &#123;return m.put(key, value);&#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>可以看到，<strong>它同步的原理同样也是使用了Synchronized关键字，不同的是Synchronized修饰代码块，并且将自身（this）作为了锁对象（mutex）。</strong></p>
<h4 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><p>ConcurrentHashMap是JDK1.5之后引入的，是为了替代上面提到的二者。<br>ConcurrentHashMap是线程安全且高效的HashMap，它使用了多个锁来控制对hash数组不同部分的修改。  </p>
<p>关于它的实现原理可以查看<a href="https://youngforzy.github.io/2017/11/10/ConcurrentHashMap在JDK1.8中的实现分析/" target="_blank" rel="external">ConcurrentHashMap</a>这篇文章中的分析。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、线程安全性&quot;&gt;&lt;a href=&quot;#一、线程安全性&quot; class=&quot;headerlink&quot; title=&quot;一、线程安全性&quot;&gt;&lt;/a&gt;一、线程安全性&lt;/h3&gt;&lt;p&gt;我们知道，HashMap是非线程安全的，只能在单线程的情况下使用。那么为什么不能在并发的情况下使用呢
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="HashMap" scheme="http://yoursite.com/tags/HashMap/"/>
    
      <category term="线程安全" scheme="http://yoursite.com/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>HashMap 在JDK1.8中的实现（与JDK1.7对比）</title>
    <link href="http://yoursite.com/2017/11/01/HashMap%20%E5%9C%A8JDK1.8%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%B8%8EJDK1.7%E5%AF%B9%E6%AF%94%EF%BC%89/"/>
    <id>http://yoursite.com/2017/11/01/HashMap 在JDK1.8中的实现（与JDK1.7对比）/</id>
    <published>2017-11-01T09:48:18.000Z</published>
    <updated>2018-02-24T17:30:16.587Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HashMap的实现分析"><a href="#HashMap的实现分析" class="headerlink" title="HashMap的实现分析"></a>HashMap的实现分析</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>通过前面JDK1.7的分析，我们知道，当负载因子和Hash算法设计的很好时，可以降低hash碰撞的概率，但在数据量过大时也避免不了会出现链表变长的情况，一旦出现链表过长，查找元素变慢，则会严重影响HashMap的性能。<br>于是，在JDK1.8中，对数据结构做了进一步的优化，引入了红黑树。<strong>而当链表长度太长（默认超过8）时，链表就转换为红黑树</strong>，利用红黑树快速增删改查的特点提高HashMap的性能，其中会用到红黑树的插入、删除、查找等算法。</p>
<h4 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h4><p>HashMap的底层实现是<strong>数组+链表+红黑树</strong>。</p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/1.8hash.PNG" alt="image"></p>
<h4 id="数组索引位置"><a href="#数组索引位置" class="headerlink" title="数组索引位置"></a>数组索引位置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//第一步</div><div class="line">static final int hash(Object key) &#123;</div><div class="line">        int h;</div><div class="line">        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">//第二步，代码中：    </div><div class="line">    tab[i = (n - 1) &amp; hash]</div></pre></td></tr></table></figure>
<p>确定数组索引的位置同样是两步法：<br>第一步计算hash，与JDK1.7中的计算方法不同；<br>计算过程如下：  </p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/hash.png" alt="image">  </p>
<p>第二步确定索引，与JDK1.7中的相同，只是不作为一个独立的方法；</p>
<h4 id="put-、get-方法"><a href="#put-、get-方法" class="headerlink" title="put()、get()方法"></a>put()、get()方法</h4><p><strong>put()方法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public V put(K key, V value) &#123;</div><div class="line">        return putVal(hash(key), key, value, false, true);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>调用了putVal()方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</div><div class="line">                   boolean evict) &#123;</div><div class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</div><div class="line">        //如果tab为空或长度为0，则分配内存resize()</div><div class="line">        if ((tab = table) == null || (n = tab.length) == 0)</div><div class="line">            n = (tab = resize()).length;</div><div class="line">        //数组索引位置为null，直接put</div><div class="line">        //同时这一步p赋值为tab[i]</div><div class="line">        if ((p = tab[i = (n - 1) &amp; hash]) == null)</div><div class="line">            tab[i] = newNode(hash, key, value, null);</div><div class="line">        else &#123;</div><div class="line">            Node&lt;K,V&gt; e; K k;</div><div class="line">            //判断hash值和key是否都相同，都相同则后面替换value值</div><div class="line">            if (p.hash == hash &amp;&amp;</div><div class="line">                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</div><div class="line">                e = p;</div><div class="line">            //红黑书处理冲突    </div><div class="line">            else if (p instanceof TreeNode)</div><div class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</div><div class="line">            //链表处理冲突</div><div class="line">            else &#123;</div><div class="line">                for (int binCount = 0; ; ++binCount) &#123;</div><div class="line">                    // 在链表尾部插入新结点</div><div class="line">                    if ((e = p.next) == null) &#123;</div><div class="line">                        p.next = newNode(hash, key, value, null);</div><div class="line">                        //节点数 &gt;= 7，转化为红黑树</div><div class="line">                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) </div><div class="line">                            treeifyBin(tab, hash);</div><div class="line">                        break;</div><div class="line">                    &#125;</div><div class="line">                    //已经存在key，退出循环，后面替换value值</div><div class="line">                    if (e.hash == hash &amp;&amp;</div><div class="line">                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</div><div class="line">                        break;</div><div class="line">                    //与e = p.next组合，遍历链表</div><div class="line">                    p = e;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            //已经存在key，替换value值</div><div class="line">            if (e != null) &#123; // existing mapping for key</div><div class="line">                V oldValue = e.value;</div><div class="line">                if (!onlyIfAbsent || oldValue == null)</div><div class="line">                    e.value = value;</div><div class="line">                afterNodeAccess(e);</div><div class="line">                return oldValue;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        ++modCount;</div><div class="line">        //扩容</div><div class="line">        if (++size &gt; threshold)</div><div class="line">            resize();</div><div class="line">        afterNodeInsertion(evict);</div><div class="line">        return null;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>put过程分析：</p>
<ol>
<li>如果数组索引位置tab[i]为null，直接put；否则进入2；</li>
<li>与第一个节点hash值相同且key值也相同，则直接到后面替换value值，否则进入3；</li>
<li>判断链表是否形成红黑树，并根据结果进入不同的处理。</li>
</ol>
<hr>
<p><strong>get()方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public V get(Object key) &#123;</div><div class="line">        Node&lt;K,V&gt; e;</div><div class="line">        return (e = getNode(hash(key), key)) == null ? null : e.value;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>调用getNode()方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;</div><div class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;</div><div class="line">        if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</div><div class="line">            (first = tab[(n - 1) &amp; hash]) != null) &#123;</div><div class="line">            //判断目标是不是first，是直接返回first</div><div class="line">            if (first.hash == hash &amp;&amp; // always check first node</div><div class="line">                ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))</div><div class="line">                return first;</div><div class="line">            //已经形成链表</div><div class="line">            if ((e = first.next) != null) &#123;</div><div class="line">                //第一个节点是TreeNode，说明形成了红黑树</div><div class="line">                if (first instanceof TreeNode)</div><div class="line">                    return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</div><div class="line">                // 还未形成红黑树，按链表处理   </div><div class="line">                do &#123;</div><div class="line">                    if (e.hash == hash &amp;&amp;</div><div class="line">                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</div><div class="line">                        return e;</div><div class="line">                &#125; while ((e = e.next) != null);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return null;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>方法分析：</p>
<ol>
<li>首先判断第一个节点first是不是要寻找的节点，如果是直接返回；不是进入2；</li>
<li>判断第一个节点first是不是树节点，如果是说明形成红黑树，调用红黑树的查找方法；不是则进入3；</li>
<li>说明还是链表，未形成红黑树，调用链表查找方法。</li>
</ol>
<h4 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h4><p>我们知道，当往HashMap中不断地添加元素时，它就会扩大数组的长度，把小的数组用大的数组来代替。<br><strong>回忆JDK1.7中的扩容，对于链表中的每个元素都需要重新计算hash值，而在JDK1.8中，只需要看看原来的hash值新增的那个bit是1还是0就好了</strong>，是0的话索引没变，是1的话索引变成“原索引+oldCap（原容量）”，工作过程如下图：</p>
<p>数组由16扩大到32的过程中，索引位置为15的元素变化：<br><img src="http://osuskkx7k.bkt.clouddn.com/1.8hahs%E6%89%A9%E5%AE%B9.png" alt="image"></p>
<p><strong>注：JDK1.7中旧链表的元素如果刚好又在新链表中，那么元素的顺序是倒置的，而JDK1.8不会倒置。</strong></p>
<h4 id="JDK1-8和JDK1-7的区别（HashMap）"><a href="#JDK1-8和JDK1-7的区别（HashMap）" class="headerlink" title="JDK1.8和JDK1.7的区别（HashMap）"></a>JDK1.8和JDK1.7的区别（HashMap）</h4><p><strong>相同点</strong></p>
<ol>
<li><strong>默认初始容量都是16，默认负载因子都是0.75。数组的长度length都是2的次幂，扩容时都是2倍</strong></li>
<li><strong>通过hash计算索引的方法相同（hash &amp; length-1）</strong></li>
<li><strong>key为null的键值对都会放入table[0]中</strong></li>
<li><strong>都是懒加载，初始时表为空，在插入第一个键值对时初始</strong>化</li>
</ol>
<p><strong>不同点</strong></p>
<ol>
<li><strong>结构不同，JDK1.8增加了红黑树优化结构</strong></li>
<li><strong>put方法的区别，JDK1.7中put时，添加到头节点；JDK1.8中添加到尾节点</strong></li>
<li><strong>计算hash的方法不同，JDK1.8更优化</strong></li>
<li><strong>JDK1.7新链表的顺序倒置，JDK1.8新链表顺序不倒置</strong></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;HashMap的实现分析&quot;&gt;&lt;a href=&quot;#HashMap的实现分析&quot; class=&quot;headerlink&quot; title=&quot;HashMap的实现分析&quot;&gt;&lt;/a&gt;HashMap的实现分析&lt;/h3&gt;&lt;h4 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="JDK1.8" scheme="http://yoursite.com/tags/JDK1-8/"/>
    
      <category term="HashMap" scheme="http://yoursite.com/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>HashMap 在JDK1.7中的实现原理分析</title>
    <link href="http://yoursite.com/2017/10/30/HashMap%20%E5%9C%A8JDK1.7%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2017/10/30/HashMap 在JDK1.7中的实现原理分析/</id>
    <published>2017-10-30T10:48:18.000Z</published>
    <updated>2018-02-24T17:26:41.879Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、HashMap的介绍"><a href="#一、HashMap的介绍" class="headerlink" title="一、HashMap的介绍"></a>一、HashMap的介绍</h3><p>HashMap是存储键值对（key，value）的一种数据结构。<br>每一个元素都是一个key-value。<br>HashMap最多只允许一个key为null，允许多个key的value值为null。<br>HashMap是非线程安全的，只适用于单线程环境。<br>HashMap实现了Serializable、Cloneable接口，因此它支持序列化和克隆。</p>
<h3 id="二、HashMap的实现原理"><a href="#二、HashMap的实现原理" class="headerlink" title="二、HashMap的实现原理"></a>二、HashMap的实现原理</h3><p>从<strong>底层结构、put和get方法、hash数组索引、扩容机制</strong>等几个方面来分析HashMap的实现原理：</p>
<h4 id="1-底层结构"><a href="#1-底层结构" class="headerlink" title="1.底层结构"></a>1.底层结构</h4><p>HashMap的底层结构是由<strong>数组+链表</strong>构成的。  </p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/hash2.PNG" alt="image"></p>
<p>数组（紫色）：hash数组（桶），数组元素是每个链表的头节点<br>链表（绿色）：解决hash冲突，不同的key映射到了数组的同一索引处，则形成链表。</p>
<p><strong>构成链表的节点类Node：</strong> （jdk 1.7 中的源码）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</div><div class="line">        final K key;</div><div class="line">        V value;</div><div class="line">        Entry&lt;K,V&gt; next;</div><div class="line">        int hash;</div><div class="line">        ....</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到，key和value都储存于节点之中，next表示下一个节点。</p>
<h4 id="2-put、get方法"><a href="#2-put、get方法" class="headerlink" title="2.put、get方法"></a>2.put、get方法</h4><p><strong>put()方法：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public V put(K key, V value) &#123;  </div><div class="line">    // 若key为null，则将该键值对添加到table[0]中。  </div><div class="line">    if (key == null)  </div><div class="line">        return putForNullKey(value);  </div><div class="line">    // 若key不为null，则计算该key的hash值，然后将其添加到该哈希值对应的数组索引处的链表中。</div><div class="line">    int hash = hash(key.hashCode());  </div><div class="line">    int i = indexFor(hash, table.length);  </div><div class="line">    //遍历该数组索引位置处的链表</div><div class="line">    for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123;  </div><div class="line">        Object k;  </div><div class="line">        // 若该key对应的键值对已经存在，则用新的value替换旧的value，退出  </div><div class="line">        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;  </div><div class="line">            V oldValue = e.value;  </div><div class="line">            e.value = value;  </div><div class="line">            e.recordAccess(this);  </div><div class="line">            return oldValue;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    modCount++;</div><div class="line">    // 若数组索引位置处table[i]没有链表，即没有元素</div><div class="line">    // 则将key-value添加到数组索引table[i]处，成为头节点</div><div class="line">    addEntry(hash, key, value, i);  </div><div class="line">    return null;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>put()方法大概过程如下：</p>
<ol>
<li><strong>如果添加的key值为null，那么将该键值对添加到数组索引为0的链表中，不一定是链表的首节点。</strong></li>
<li><strong>如果添加的key不为null，则根据key计算数组索引的位置</strong>：  </li>
</ol>
<ul>
<li><strong>数组索引处存在链表</strong>，则遍历该链表，如果发现key已经存在，那么将新的value值替换旧的value值</li>
<li><strong>数组索引处不存在链表</strong>，将该key-value添加到此处，成为头节点</li>
</ul>
<p><strong>addEntry()方法如下：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">void addEntry(int hash, K key, V value, int bucketIndex) &#123;  </div><div class="line">    // bucketIndex是数组位置索引，保存“bucketIndex”位置的值到“e”中  </div><div class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];  </div><div class="line">    // 设置“bucketIndex”位置的元素为“新Entry”，设置“e”为“新Entry的下一个节点”  </div><div class="line">    table[bucketIndex] = new Entry&lt;K,V&gt;(hash, key, value, e);  </div><div class="line">    // size超过阈值，则调整HashMap的大小  </div><div class="line">    if (size++ &gt;= threshold)  </div><div class="line">        resize(2 * table.length);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>将新的节点（假设为节点n）添加到数组索引位置处，将原来的节点e作为n的next节点，即下一个节点。</strong></p>
<p>由此可知：<strong>每一次添加的新节点总是作为头节点。</strong></p>
<hr>
<p><strong>get()方法：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public V get(Object key) &#123;  </div><div class="line">    if (key == null)  </div><div class="line">        return getForNullKey();  </div><div class="line">    // 获取key的hash值  </div><div class="line">    int hash = hash(key.hashCode());  </div><div class="line">    // 在“该hash值对应的链表”上查找“键值等于key”的元素  </div><div class="line">    for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];  </div><div class="line">         e != null;  </div><div class="line">         e = e.next) &#123;  </div><div class="line">        Object k;  </div><div class="line">        //判断key是否相同</div><div class="line">        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))  </div><div class="line">            return e.value;  </div><div class="line">    &#125;</div><div class="line">    //没找到则返回null</div><div class="line">    return null;  </div><div class="line">&#125;  </div><div class="line"> </div><div class="line">// 获取“key为null”的元素的值  </div><div class="line">// HashMap将“key为null”的元素存储在table[0]位置，但不一定是该链表的第一个位置！  </div><div class="line">private V getForNullKey() &#123;  </div><div class="line">    for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) &#123;  </div><div class="line">        if (e.key == null)  </div><div class="line">            return e.value;  </div><div class="line">    &#125;  </div><div class="line">    return null;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>get()方法的大概过程：</p>
<ol>
<li>如果key为null，那么在数组索引table[0]处的链表中遍历查找key为null的value</li>
<li>如果key不为null，根据key找到数组索引位置处的链表，遍历查找key的value，找到返回value，若没找到则返回null</li>
</ol>
<h4 id="3-hash数组索引位置"><a href="#3-hash数组索引位置" class="headerlink" title="3.hash数组索引位置"></a>3.hash数组索引位置</h4><p>前面多次提到了数组索引位置，那么这个位置该如何确定呢？<br>两步：</p>
<ol>
<li>确定key的hash值</li>
<li>根据hash计算索引</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">static int hash(int h) &#123;</div><div class="line">        h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);</div><div class="line">        return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">static int indexFor(int h, int length) &#123;</div><div class="line">        return h &amp; (length-1);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>第一步：采用位操作计算hash值，这么做的<strong>目的是为了下一步的索引值分布均匀，减少碰撞，提高效率。</strong><br>第二步：根据hash值计算索引的值，把hash值和数组长度-1做一个”与”操作，保留的值作为索引。</p>
<p><strong>为什么是length-1？</strong><br><strong>这也是HashMap的数组长度要取2的整次幂的原因之一。  因为length为2的整数次幂时，（length-1）正好相当于一个“低位掩码”**</strong>。“与”操作的结果就可以保留低位作为数组索引。**<br>例如：length = 16和某个hash值进行 &amp; 操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">某个hash           10110110 11100010 01000101</div><div class="line">length-1=15    &amp;   00000000 00000000 00001111</div><div class="line">           ---------------------------------</div><div class="line">                   00000000 00000000 00000101   //只保留末四位，索引值=5</div></pre></td></tr></table></figure>
<p><strong>另一个原因</strong>：HashMap的数组长度length为2的整次幂时，length-1为奇数（偶数-1），此时进行 &amp; 操作时可保证最后一位可能是 0 或 1 ，保证了数组索引的均匀性；而如果length-1为偶数，那么 &amp; 操作时最后一位只能是 0，也就是数组索引只能是偶数索引位置，这样就浪费了一半的空间，所以length为2的整次幂。<br><strong>综上，数组长度取2的整次幂，是为了减少hash碰撞的概率，使元素散列更加均匀。</strong></p>
<h4 id="4-扩容机制"><a href="#4-扩容机制" class="headerlink" title="4.扩容机制"></a>4.扩容机制</h4><p>先看一个例子，创建一个HashMap，初始容量默认为16，负载因子默认为0.75，那么什么时候它会扩容呢？<br>来看以下公式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">实际容量 = 初始容量 × 负载因子</div></pre></td></tr></table></figure></p>
<p>计算可知，16×0.75=12，也就是当实际容量超过12时，这个HashMap就会扩容。</p>
<p><strong>初始容量</strong>  </p>
<p>当构造一个hashmap时，初始容量设为不小于指定容量的2的次方的一个数（new HashMap(5)， 指定容量为5，那么实际初始容量为8，2^3=8&gt;5），且最大值不能超过2的30次方。  </p>
<p><strong>负载因子</strong>  </p>
<p><strong>负载因子是哈希数组在其容量自动增加之前可以达到多满的一种尺度。（时间与空间的折衷）</strong> 当哈希数组中的条目数超出了加载因子与初始容量的乘积时，则要对该哈希数组进行扩容操作（即resize）。<br><strong>特点：</strong></p>
<ul>
<li><strong>负载因子越小，容易扩容，浪费空间，但查找效率高</strong></li>
<li><strong>负载因子越大，不易扩容，对空间的利用更加充分，查找效率低（链表拉长）</strong></li>
</ul>
<p><strong>扩容过程</strong>  </p>
<p> HashMap在扩容时，<strong>新数组的容量将是原来的2倍</strong>，由于容量发生变化，原有的每个元素需要重新计算数组索引Index，再存放到新数组中去，这就是所谓的rehash。</p>
<p>扩容代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">void resize(int newCapacity) &#123;  </div><div class="line">    Entry[] oldTable = table;  </div><div class="line">    int oldCapacity = oldTable.length;  </div><div class="line">    if (oldCapacity == MAXIMUM_CAPACITY) &#123;  </div><div class="line">        threshold = Integer.MAX_VALUE;  </div><div class="line">        return;  </div><div class="line">    &#125;  </div><div class="line">    // 新建一个HashMap，将“旧HashMap”的全部元素添加到“新HashMap”中</div><div class="line">    // 然后，将“新HashMap”赋值给“旧HashMap”。  </div><div class="line">    Entry[] newTable = new Entry[newCapacity];  </div><div class="line">    transfer(newTable);  </div><div class="line">    table = newTable;  </div><div class="line">    threshold = (int)(newCapacity * loadFactor);  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>调用transfer()方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">void transfer(Entry[] newTable) &#123;  </div><div class="line">    Entry[] src = table;  </div><div class="line">    int newCapacity = newTable.length;  </div><div class="line">    for (int j = 0; j &lt; src.length; j++) &#123;  </div><div class="line">        Entry&lt;K,V&gt; e = src[j];  </div><div class="line">        if (e != null) &#123;  </div><div class="line">            src[j] = null;  </div><div class="line">            do &#123;  </div><div class="line">                Entry&lt;K,V&gt; next = e.next;  </div><div class="line">                int i = indexFor(e.hash, newCapacity);  </div><div class="line">                e.next = newTable[i];  </div><div class="line">                newTable[i] = e;  </div><div class="line">                e = next;  </div><div class="line">            &#125; while (e != null);  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>第一步for循环遍历每一个数组元素（桶）；<br>第二步遍历每一个数组元素中的链表，将链表中的节点存入新数组指定的位置构成链表，注意此时新链表顺序反转。（原链表的头节点将变成新链表的尾节点）<br><strong>注：原链表中的节点可能存到不同的新链表中，因为rehash重新计算了索引位置。</strong></p>
<p>由此可知，<strong>扩容操作是一个耗时耗性能的操作，因为它需要重新计算元素的位置，并进行复制操作。因此，在使用时提前预估HashMap的大小有助于提高性能。</strong></p>
<p>HashMap未初始容量和初始容量的对比：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">long start1 = System.currentTimeMillis();</div><div class="line">		HashMap map = new HashMap&lt;&gt;(); //未初始容量</div><div class="line">		for(int i=0;i&lt;20000;i++)&#123;</div><div class="line">			map.put(i, &quot;I am zy&quot;);</div><div class="line">		&#125;</div><div class="line">		long end1 = System.currentTimeMillis();</div><div class="line">		System.out.println(&quot;不初始化时耗时：&quot;+(end1-start1)+ &quot;ms&quot;);</div><div class="line">		</div><div class="line">		long start2 = System.currentTimeMillis();</div><div class="line">		HashMap map2 = new HashMap&lt;&gt;(32768); //初始容量</div><div class="line">		for(int i=0;i&lt;20000;i++)&#123;</div><div class="line">			map2.put(i, &quot;I am zy&quot;);</div><div class="line">		&#125;</div><div class="line">		long end2 = System.currentTimeMillis();</div><div class="line">		System.out.println(&quot;初始化时耗时：&quot;+(end2-start2)+ &quot;ms&quot;);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">不初始化时耗时：5ms</div><div class="line">初始化时耗时：1ms</div></pre></td></tr></table></figure>
<p>可见初始化容量有助于提高性能，对于数据量大则越明显。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、HashMap的介绍&quot;&gt;&lt;a href=&quot;#一、HashMap的介绍&quot; class=&quot;headerlink&quot; title=&quot;一、HashMap的介绍&quot;&gt;&lt;/a&gt;一、HashMap的介绍&lt;/h3&gt;&lt;p&gt;HashMap是存储键值对（key，value）的一种数据结
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="JDK1.7" scheme="http://yoursite.com/tags/JDK1-7/"/>
    
      <category term="HashMap" scheme="http://yoursite.com/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>ReentrantReadWriteLock可重入读写锁</title>
    <link href="http://yoursite.com/2017/10/28/ReentrantReadWriteLock%E5%8F%AF%E9%87%8D%E5%85%A5%E8%AF%BB%E5%86%99%E9%94%81/"/>
    <id>http://yoursite.com/2017/10/28/ReentrantReadWriteLock可重入读写锁/</id>
    <published>2017-10-28T09:48:18.000Z</published>
    <updated>2018-02-24T07:44:19.001Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、ReentrantReadWriteLock的概念"><a href="#一、ReentrantReadWriteLock的概念" class="headerlink" title="一、ReentrantReadWriteLock的概念"></a>一、ReentrantReadWriteLock的概念</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>前面提到的锁（独占锁、ReentrantLock）等都是排他锁，这些锁在同一时刻只允许一个线程访问。<br>而<strong>读写锁在同一时刻可以允许多个读线程访问，但在写线程访问时，所有读线程和其他写线程都阻塞。</strong></p>
<p>ReadWriteLock并不是继承自Lock接口，而是一个单独的接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public interface ReadWriteLock &#123;</div><div class="line">    Lock readLock();</div><div class="line">    Lock writeLock();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ReentrantReadWriteLock则是这个接口的实现。通过readLock()和writeLock()方法可分别获得一个ReadLock实例和一个WriteLock实例，这两个实例实现了Lock接口。<br>因此，我们可以调用Lock接口的相关方法来完成锁的语义。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ReentrantReadWriteLock rw = new ReentrantReadWriteLock();</div><div class="line">Lock r = rw.readLock();</div><div class="line">Lock w = rw.writeLock();</div><div class="line">...</div></pre></td></tr></table></figure>
<h4 id="特性："><a href="#特性：" class="headerlink" title="特性："></a>特性：</h4><ol>
<li><p><strong>公平性：同样有公平锁和非公平锁；</strong>  </p>
</li>
<li><p><strong>重入性：读锁和写锁都支持重入（最大65535）；</strong></p>
</li>
<li><strong>锁降级：获取写锁之后，获取读锁，释放写锁，保留读锁；（按顺序）</strong></li>
</ol>
<h3 id="二、ReentrantReadWriteLock的实现原理"><a href="#二、ReentrantReadWriteLock的实现原理" class="headerlink" title="二、ReentrantReadWriteLock的实现原理"></a>二、ReentrantReadWriteLock的实现原理</h3><p>ReentrantReadWriteLock与ReentrantLock一样，锁的语义的实现依旧是依靠Sync（继承自AQS），它的读锁、写锁的实现原理如下：</p>
<ul>
<li><strong>读锁：AQS共享锁</strong></li>
<li><strong>写锁：AQS独占锁</strong></li>
</ul>
<h4 id="读写状态"><a href="#读写状态" class="headerlink" title="读写状态"></a>读写状态</h4><p>读写锁的实现同样是依赖AQS来实现同步功能。<br>那么它的读写状态如何表示呢？<br>同样是<strong>使用一个int型的变量</strong>表示，将这个变量“按位切割”成两部分，<strong>高16位表示读，低16位表示写</strong>。这样我们就能通过位运算确定它的读写状态。（如下图）  </p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/duxiesuo.jpg" alt="（图）">  </p>
<p>如果已知整体同步状态为S，那么：</p>
<ul>
<li><strong>写状态：S &amp; 0x0000FFFF</strong>（将高16位变0，抹去）</li>
<li><strong>读状态：S&gt;&gt;&gt;16</strong> （无符号补0右移16位）  </li>
</ul>
<p><strong>注：当写状态为0，S不为0时，表示读状态不为0，读锁被获取。</strong></p>
<h4 id="写锁的获取和释放"><a href="#写锁的获取和释放" class="headerlink" title="写锁的获取和释放"></a>写锁的获取和释放</h4><p>写锁是独占锁，获取时调用Sync中的tryAcquire()方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">protected final boolean tryAcquire(int acquires) &#123;</div><div class="line">            Thread current = Thread.currentThread();</div><div class="line">            //获取状态</div><div class="line">            int c = getState();</div><div class="line">            //获取写状态</div><div class="line">            int w = exclusiveCount(c);</div><div class="line">            if (c != 0) &#123;</div><div class="line">                //写状态为0表示存在读线程，获取失败</div><div class="line">                //或当前线程不是获取写锁的线程，获取失败</div><div class="line">                if (w == 0 || current != getExclusiveOwnerThread())</div><div class="line">                    return false;</div><div class="line">                //超过写锁总数量</div><div class="line">                if (w + exclusiveCount(acquires) &gt; MAX_COUNT)</div><div class="line">                    throw new Error(&quot;Maximum lock count exceeded&quot;);</div><div class="line">                //当前线程是获取写锁的线程，重进入，获取成功</div><div class="line">                setState(c + acquires);</div><div class="line">                return true;</div><div class="line">            &#125;</div><div class="line">            //是否需要阻塞</div><div class="line">            if (writerShouldBlock() ||</div><div class="line">                !compareAndSetState(c, c + acquires))</div><div class="line">                return false;</div><div class="line">            setExclusiveOwnerThread(current);</div><div class="line">            return true;</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p>
<p>写锁的获取过程如代码中注释所示。<br>只有在以下情况才能获取写锁：</p>
<ul>
<li><strong>不存在读锁或当前线程是已经获取写锁的线程（可重入）</strong></li>
</ul>
<hr>
<p>写锁的释放调用的是Sync的tryRelease()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">protected final boolean tryRelease(int releases) &#123;</div><div class="line">            if (!isHeldExclusively())</div><div class="line">                throw new IllegalMonitorStateException();</div><div class="line">            int nextc = getState() - releases;</div><div class="line">            boolean free = exclusiveCount(nextc) == 0;</div><div class="line">            if (free)</div><div class="line">                setExclusiveOwnerThread(null);</div><div class="line">            setState(nextc);</div><div class="line">            return free;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>写锁的释放与重入锁的释放过程类似，每次释放时将写状态减少，直到写锁状态为0时，表示写锁释放。</p>
<hr>
<h4 id="读锁的获取和释放"><a href="#读锁的获取和释放" class="headerlink" title="读锁的获取和释放"></a>读锁的获取和释放</h4><p>读锁是共享锁，调用的是Sync的tryAcquireShared()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">protected final int tryAcquireShared(int unused) &#123;</div><div class="line">            Thread current = Thread.currentThread();</div><div class="line">            int c = getState(); //获取状态</div><div class="line">            //写锁不为0  &amp;&amp; 且获取写锁的线程不是当前线程</div><div class="line">            //直接失败</div><div class="line">            if (exclusiveCount(c) != 0 &amp;&amp;</div><div class="line">                getExclusiveOwnerThread() != current) </div><div class="line">                return -1;</div><div class="line">            //获取读锁</div><div class="line">            int r = sharedCount(c);</div><div class="line">            //readerShouldBlock()：读锁是否要等待（公平or非公平）</div><div class="line">            // r &lt; MAX_COUNT：读锁小于最大值（65535）</div><div class="line">            //compareAndSetState(c, c + SHARED_UNIT))：CAS操作成功</div><div class="line">            if (!readerShouldBlock() &amp;&amp;</div><div class="line">                r &lt; MAX_COUNT &amp;&amp;</div><div class="line">                compareAndSetState(c, c + SHARED_UNIT)) &#123;</div><div class="line">                //r == 0：只有一个读锁（A），计数+1</div><div class="line">                if (r == 0) &#123;</div><div class="line">                    firstReader = current;</div><div class="line">                    firstReaderHoldCount = 1;</div><div class="line">                //持有读锁的线程（A）重进入，计数++</div><div class="line">                &#125; else if (firstReader == current) &#123;</div><div class="line">                    firstReaderHoldCount++;</div><div class="line">                &#125; else &#123;</div><div class="line">                //另一个线程（B）进入，此时找到缓存的rh，将计数++；</div><div class="line">                    HoldCounter rh = cachedHoldCounter;</div><div class="line">                    if (rh == null || rh.tid != getThreadId(current))</div><div class="line">                        cachedHoldCounter = rh = readHolds.get();</div><div class="line">                    else if (rh.count == 0)</div><div class="line">                        readHolds.set(rh);</div><div class="line">                    rh.count++;</div><div class="line">                &#125;</div><div class="line">                return 1;</div><div class="line">            &#125;</div><div class="line">            //循环尝试</div><div class="line">            return fullTryAcquireShared(current);</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>获取锁的过程如注释所示。<br>如果不满足第二个if语句中的判断，比如读锁需要阻塞，则会进入fullTryAcquireShared（current）方法，<strong>该方法循环不断尝试修改状态直到成功或被写入锁占有。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">final int fullTryAcquireShared(Thread current) &#123;</div><div class="line">            HoldCounter rh = null;</div><div class="line">            for (;;) &#123;</div><div class="line">                int c = getState();</div><div class="line">                //写锁存在但不是当前线程，直接失败</div><div class="line">                if (exclusiveCount(c) != 0) &#123;</div><div class="line">                    if (getExclusiveOwnerThread() != current)</div><div class="line">                        return -1;</div><div class="line">                //读锁是否要阻塞（公平 or 非公平）</div><div class="line">                &#125; else if (readerShouldBlock()) &#123;</div><div class="line">                    if (firstReader == current) &#123;</div><div class="line">                    &#125; else &#123;</div><div class="line">                        if (rh == null) &#123;</div><div class="line">                            rh = cachedHoldCounter;</div><div class="line">                            if (rh == null || rh.tid != getThreadId(current)) &#123;</div><div class="line">                                rh = readHolds.get();</div><div class="line">                                if (rh.count == 0)</div><div class="line">                                    readHolds.remove();</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                        if (rh.count == 0)</div><div class="line">                            return -1;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                //读锁达到最大值，不能再获取</div><div class="line">                if (sharedCount(c) == MAX_COUNT)</div><div class="line">                    throw new Error(&quot;Maximum lock count exceeded&quot;);</div><div class="line">                //CAS操作</div><div class="line">                if (compareAndSetState(c, c + SHARED_UNIT)) &#123;</div><div class="line">                    if (sharedCount(c) == 0) &#123;</div><div class="line">                        firstReader = current;</div><div class="line">                        firstReaderHoldCount = 1;</div><div class="line">                    &#125; else if (firstReader == current) &#123;</div><div class="line">                        firstReaderHoldCount++;</div><div class="line">                    &#125; else &#123;</div><div class="line">                        if (rh == null)</div><div class="line">                            rh = cachedHoldCounter;</div><div class="line">                        if (rh == null || rh.tid != getThreadId(current))</div><div class="line">                            rh = readHolds.get();</div><div class="line">                        else if (rh.count == 0)</div><div class="line">                            readHolds.set(rh);</div><div class="line">                        rh.count++;</div><div class="line">                        cachedHoldCounter = rh; </div><div class="line">                    &#125;</div><div class="line">                    return 1;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>以上的代码中多次出现了一个rh变量（HoldCounter），我们知道重入锁的原理就是计数器，同理这个rh变量也相当于一个计数器，记录线程获取读锁的次数。来看它的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//HoldCounter类</div><div class="line">static final class HoldCounter &#123;</div><div class="line">            int count = 0;</div><div class="line">            final long tid = getThreadId(Thread.currentThread());</div><div class="line">        &#125;</div><div class="line">//继承ThreadLocal类        </div><div class="line">static final class ThreadLocalHoldCounter</div><div class="line">            extends ThreadLocal&lt;HoldCounter&gt; &#123;</div><div class="line">            public HoldCounter initialValue() &#123;</div><div class="line">                return new HoldCounter();</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>HoldCounter的定义只包含一个计数器和当前线程的Id，它的作用就是记录该线程获取读锁的次数，那么它是如何与线程绑定的呢？我们知道ThreadLocal类是线程维护的私有变量，利用它就可以和线程绑定。  </p>
<p>注：（需要说明的是这样<strong>HoldCounter绑定线程id而不绑定线程对象的原因是**</strong>避免HoldCounter和ThreadLocal互相绑定而GC难以释放它们**，所以其实这样做只是为了帮助GC快速回收对象而已。）</p>
<hr>
<p>当读锁释放时，调用的是Sync的tryReleaseShared()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">protected final boolean tryReleaseShared(int unused) &#123;</div><div class="line">            Thread current = Thread.currentThread();</div><div class="line">            if (firstReader == current) &#123;</div><div class="line">                if (firstReaderHoldCount == 1)</div><div class="line">                    firstReader = null;</div><div class="line">                else</div><div class="line">                    firstReaderHoldCount--;</div><div class="line">            &#125; else &#123;</div><div class="line">                HoldCounter rh = cachedHoldCounter;</div><div class="line">                if (rh == null || rh.tid != getThreadId(current))</div><div class="line">                    rh = readHolds.get();</div><div class="line">                int count = rh.count;</div><div class="line">                if (count &lt;= 1) &#123;</div><div class="line">                    readHolds.remove();</div><div class="line">                    if (count &lt;= 0)</div><div class="line">                        throw unmatchedUnlockException();</div><div class="line">                &#125;</div><div class="line">                --rh.count;</div><div class="line">            &#125;</div><div class="line">            for (;;) &#123;</div><div class="line">                int c = getState();</div><div class="line">                int nextc = c - SHARED_UNIT;</div><div class="line">                if (compareAndSetState(c, nextc))</div><div class="line">                    return nextc == 0;</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>循环CAS操作直到读锁的状态为0。</p>
<h4 id="锁降级"><a href="#锁降级" class="headerlink" title="锁降级"></a>锁降级</h4><p>前面提到，读写锁有个特性是锁降级。<br>锁降级指的是：<strong>写锁降级为读锁</strong>。</p>
<p>具体过程：<strong>获取写锁的线程把持住写锁，然后获取读锁，再释放写锁。</strong>  </p>
<p><strong>目的：保证写锁修改的数据可以被其他线程看见，保证了数据的可见性。</strong> </p>
<p>锁降级中读锁的获取是否为必要？肯定是必要的。试想，假如当前线程A不获取读锁而是直接释放了写锁，这个时候另外一个线程B获取了写锁，那么这个线程B对数据的修改是不会对当前线程A可见的。   如果获取了读锁，则线程B在获取写锁过程中判断如果有读锁还没有释放则会被阻塞，只有当前线程A释放读锁后，线程B才会获取写锁成功。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、ReentrantReadWriteLock的概念&quot;&gt;&lt;a href=&quot;#一、ReentrantReadWriteLock的概念&quot; class=&quot;headerlink&quot; title=&quot;一、ReentrantReadWriteLock的概念&quot;&gt;&lt;/a&gt;一、Ree
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="ReentrantReadWriteLock" scheme="http://yoursite.com/tags/ReentrantReadWriteLock/"/>
    
      <category term="可重入读写锁" scheme="http://yoursite.com/tags/%E5%8F%AF%E9%87%8D%E5%85%A5%E8%AF%BB%E5%86%99%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>JVM之对象创建过程</title>
    <link href="http://yoursite.com/2017/10/26/JVM%E4%B9%8B%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2017/10/26/JVM之对象创建过程/</id>
    <published>2017-10-26T10:48:19.000Z</published>
    <updated>2018-02-24T07:33:25.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、Java对象的创建过程"><a href="#一、Java对象的创建过程" class="headerlink" title="一、Java对象的创建过程"></a>一、Java对象的创建过程</h3><p>在Java程序中，通常都是通过 new 关键字来创建对象，那么在虚拟机中对象是如何创建的？<br>（普通Java对象，不包含数组和Class对象）</p>
<p>虚拟机创建对象主要经历5个步骤：<strong>类加载检查、为对象分配内存、内存空间初始化、对象设置、执行对象<init>方法。</init></strong></p>
<h4 id="1-类加载检查"><a href="#1-类加载检查" class="headerlink" title="1 类加载检查"></a>1 类加载检查</h4><p>当虚拟机遇到 new 指令时，首先会去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且<strong>检查这个符号引用代表的类是否已被加载、解析和初始化过</strong>。如果没有，先执行类加载过程。</p>
<h4 id="2-为对象分配内存"><a href="#2-为对象分配内存" class="headerlink" title="2 为对象分配内存"></a>2 为对象分配内存</h4><p>对象所需的内存大小在类加载完成时已经确定，因此<strong>为对象分配内存等同于在Java堆中划分一块大小确定的内存空间</strong>。  </p>
<h5 id="两种分配方式："><a href="#两种分配方式：" class="headerlink" title="两种分配方式："></a>两种分配方式：</h5><ul>
<li><strong>指针碰撞</strong>：Java堆中的内存是完整的，将指针往空闲空间挪动一段与对象大小相等的距离</li>
<li><strong>空闲列表</strong>：Java堆中的内存不是完整的，JVM维护了一个记录可用内存的列表，分配时将列表中足够大的空间划分给对象，并更新列表</li>
</ul>
<p>因此选择何种分配方式由Java堆是否完整决定，而这又由垃圾收集器是否带有压缩整理功能决定。如：</p>
<ul>
<li><strong>Serial、ParNew等采用指针碰撞</strong></li>
<li><strong>CMS基于“标记-清除”采用空闲列表</strong></li>
</ul>
<h5 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h5><p>当处于并发情况下时，还要考虑线程安全问题。<br>两种解决方案：</p>
<ul>
<li><strong>对分配内存的动作进行同步处理</strong>。JVM采用CAS加失败重试的方式保证原子性</li>
<li><strong>把内存分配的动作按照线程划分在不同的空间进行</strong>。每个线程在Java堆中预先分配一小块内存（本地线程分配缓冲TLAB），只有TLAB用完重新分配时才同步锁定。<h4 id="3-内存空间初始化"><a href="#3-内存空间初始化" class="headerlink" title="3 内存空间初始化"></a>3 内存空间初始化</h4>JVM将分配到的内存空间都初始化为零值（不包括对象头）；若使用TLAB，则提前至TLAB分配时执行。</li>
</ul>
<p>这一步<strong>保证了对象实例字段在Java代码中可以不赋初值就直接使用</strong>，程序能访问到这些字段的数据类型所对应的零值。</p>
<h4 id="4-对象设置"><a href="#4-对象设置" class="headerlink" title="4 对象设置"></a>4 对象设置</h4><p>JVM设置对象头信息，如类元数据信息、对象的哈希码、对象的GC分代年龄信息等。还有是否启用偏向锁。</p>
<h4 id="5-执行对象方法"><a href="#5-执行对象方法" class="headerlink" title="5 执行对象方法"></a>5 执行对象<init>方法</init></h4><p>此时，对于JVM来说，对象已经产生；<br>对于Java程序来说，才刚刚开始，执行<init>方法进行初始化，一个对象才算真正创建完成。</init></p>
<h3 id="二、Java对象的初始化"><a href="#二、Java对象的初始化" class="headerlink" title="二、Java对象的初始化"></a>二、Java对象的初始化</h3><p>在Java对象初始化过程中，主要涉及三种执行对象初始化的结构，分别是 <strong>实例变量初始化、实例代码块初始化</strong> 以及 <strong>构造函数初始化</strong>。 </p>
<h4 id="实例变量初始化与实例代码块初始化"><a href="#实例变量初始化与实例代码块初始化" class="headerlink" title="实例变量初始化与实例代码块初始化"></a>实例变量初始化与实例代码块初始化</h4><p>在定义（声明）实例变量的同时，还可以直接对实例变量进行赋值或者使用实例代码块对其进行赋值。<br>如果我们<strong>以这两种方式为实例变量进行初始化，那么它们将在构造函数执行之前完成这些初始化操作。</strong> 实际上，如果我们对实例变量直接赋值或者使用实例代码块赋值，那么编译器会将其中的代码放到类的构造函数中去，并且这些代码会被放在对超类构造函数的调用语句之后(Super())，构造函数本身的代码之前。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public class Tdemo2 &#123;</div><div class="line">	//成员变量</div><div class="line">	private int i = 1;</div><div class="line">	private int j = 1;</div><div class="line">	public  Tdemo2(int c)&#123;</div><div class="line">		System.out.println(i);</div><div class="line">		System.out.println(j);</div><div class="line">		this.i = c;</div><div class="line">		System.out.println(i);</div><div class="line">	&#125;</div><div class="line">	//代码块</div><div class="line">	&#123;</div><div class="line">		j = j+1;</div><div class="line">	&#125;</div><div class="line">	//静态代码块</div><div class="line">	static&#123;</div><div class="line">		int a = 5;</div><div class="line">		System.out.println(a);</div><div class="line">	&#125;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		new Tdemo2(3);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">5</div><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td></tr></table></figure></p>
<p>可见执行顺序是static代码块、成员变量赋值、代码块、构造函数。</p>
<h4 id="构造函数初始化"><a href="#构造函数初始化" class="headerlink" title="构造函数初始化"></a>构造函数初始化</h4><p><strong>Java要求在实例化类之前，必须先实例化其超类，以保证所创建实例的完整性。</strong><br>Java强制要求Object对象(Object是Java的顶层对象，没有超类)之外的所有对象构造函数的第一条语句必须是超类构造函数的调用语句或者是类中定义的其他的构造函数，如果我们既没有调用其他的构造函数，也没有显式调用超类的构造函数，那么编译器会为我们自动生成一个对超类构造函数的调用。</p>
<p>实际上，实例化一个类的对象的过程是一个典型的递归过程。</p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/%E5%AE%9E%E4%BE%8B%E5%8C%96%E9%80%92%E5%BD%92%E8%BF%87%E7%A8%8B.png" alt="image"></p>
<p>在准备实例化一个类的对象前，首先准备实例化该类的父类，如果该类的父类还有父类，那么准备实例化该类的父类的父类，依次递归直到递归到Object类。</p>
<p><strong>注意：实例初始化不一定要在类初始化结束之后才开始初始化。</strong></p>
<p>回忆一下Java中赋值顺序： </p>
<ol>
<li>父类的静态变量赋值 </li>
<li>自身的静态变量赋值 </li>
<li>父类成员变量赋值和父类代码块赋值 </li>
<li>父类构造函数赋值 </li>
<li>自身成员变量赋值和自身块代码赋值 </li>
<li>自身构造函数赋值</li>
</ol>
<h3 id="三、Java对象的创建方式"><a href="#三、Java对象的创建方式" class="headerlink" title="三、Java对象的创建方式"></a>三、Java对象的创建方式</h3><p>Java对象的创建方式有 5 种：</p>
<ol>
<li><p>new 关键字</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Person p = new Person();</div></pre></td></tr></table></figure>
</li>
<li><p>Class类的newInstance()（反射）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Person p2 = Person.class.newInstance();</div></pre></td></tr></table></figure>
</li>
<li><p>Constructor类的newInstance方法（反射）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Constructor c = Person.class.getConstructor();</div><div class="line">Person p3 = (Person) c.newInstance();</div></pre></td></tr></table></figure>
</li>
<li><p>clone方法（实现Cloneable接口）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Person p4 = (Person) p3.clone();</div></pre></td></tr></table></figure>
</li>
<li><p>反序列化（实现Serializable接口）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//写对象</div><div class="line">ObjectOutputStream output = new ObjectOutputStream(new FileOutputStream(&quot;person.txt&quot;));</div><div class="line">output.writeObject(p);</div><div class="line">output.close();</div><div class="line"></div><div class="line">//读对象</div><div class="line">ObjectInputStream input = new ObjectInputStream(new FileInputStream(&quot;person.txt&quot;));</div><div class="line">Person p5 = (Person) input.readObject();</div></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、Java对象的创建过程&quot;&gt;&lt;a href=&quot;#一、Java对象的创建过程&quot; class=&quot;headerlink&quot; title=&quot;一、Java对象的创建过程&quot;&gt;&lt;/a&gt;一、Java对象的创建过程&lt;/h3&gt;&lt;p&gt;在Java程序中，通常都是通过 new 关键字来创建
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
      <category term="对象创建过程" scheme="http://yoursite.com/tags/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>JVM之类加载机制</title>
    <link href="http://yoursite.com/2017/10/24/JVM%E4%B9%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2017/10/24/JVM之类加载机制/</id>
    <published>2017-10-24T11:34:18.000Z</published>
    <updated>2018-02-24T07:28:54.050Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、类加载机制"><a href="#一、类加载机制" class="headerlink" title="一、类加载机制"></a>一、类加载机制</h3><p>虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被JVM直接使用的Java类型，这就是虚拟机的<strong>类加载机制</strong>。</p>
<h4 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h4><p>那么类到底什么时候会加载呢？（初始化）<br><strong>当对一个类进行主动引用的时候</strong>。</p>
<h5 id="主动引用"><a href="#主动引用" class="headerlink" title="主动引用"></a>主动引用</h5><p>主动引用有5种情况：</p>
<ol>
<li>new实例化对象、读取或设置一个类的静态字段时、调用一个类的静态方法时</li>
<li>使用java.lang.reflect包的方法对类进行反射调用时</li>
<li>初始化一个类时，父类还没初始化，则先触发父类的初始化</li>
<li>虚拟机启动时，初始化包含main()方法的主类</li>
<li>使用JDK1.7的动态语言支持的时候，如java.lang.invoke.MethodHandle实例</li>
</ol>
<h5 id="被动引用"><a href="#被动引用" class="headerlink" title="被动引用"></a>被动引用</h5><p>被动引用有以下几种情况：</p>
<ol>
<li>子类调用父类的静态变量，子类不会被初始化，只有父类会被初始化。（只有定义静态字段的类才会被初始化）</li>
<li>通过数组来定义引用类，不会初始化</li>
<li>访问类的final常量(编译期静态常量)，不会初始化</li>
<li>通过类名获取Class对象，不会触发类的初始化(其余两种getClass()和Class.forName()会)<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//类名.class获取Class对象</div><div class="line">Class clazz = A.class;</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="二、类加载过程"><a href="#二、类加载过程" class="headerlink" title="二、类加载过程"></a>二、类加载过程</h3><h4 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h4><p><img src="http://osuskkx7k.bkt.clouddn.com/%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F2.jpg.png" alt="image"></p>
<p><strong>类的生命周期包括：加载、验证、准备、解析、初始化、使用和卸载7个阶段。</strong> 验证、准备、解析这三个阶段称为连接。<br>解析阶段的顺序不是确定的，可以在初始化之后开始。</p>
<p><strong>类加载过程</strong>包括<strong>加载、验证、准备、解析、初始化</strong>。</p>
<h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p>JVM完成以下3件事：</p>
<ol>
<li>通过一个类的全限定名来获取定义此类的二进制字节流（不一定是Class文件）。</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</li>
</ol>
<p>注：</p>
<ul>
<li>数组类本身不通过类加载器创建，由虚拟机直接创建</li>
<li>内存中实例化的Class对象并不是在堆中，存放于方法区（HotSpot虚拟机）<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4>验证的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求。<br>主要完成以下4个检验动作：</li>
</ul>
<ol>
<li>文件格式验证：如魔数、版本号、常量类型….</li>
<li>元数据验证：这个类是否有父类？是不是抽象类？是否继承了不允许被继承的类？</li>
<li>字节码验证：对类的方法体进行校验分析，确定程序语义是合法、符合逻辑的。</li>
<li>符号引用验证：（发生在解析阶段）符号引用中通过字符串描述的全限定名是否能找到对应的类？…</li>
</ol>
<p>验证阶段是一个很重要但不一定是必要的阶段。</p>
<h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p><strong>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。</strong>（这里的类变量仅为Static修饰的变量，不包括实例变量，实例变量是在对象实例化时随着对象分配在堆中）</p>
<p>假设一个类变量定义为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public static int value = 666;</div></pre></td></tr></table></figure></p>
<p>那么在准备阶段过后，初始值为0，而不是666，因为把value赋值为666的动作在初始化阶段才会执行。</p>
<p>但是下面这种情况除外：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public static final int value = 666;</div></pre></td></tr></table></figure>
<p>当用final修饰时，会在准备阶段赋值为666。</p>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p><strong>解析阶段是虚拟机将常量池中的符号引用替换为直接引用的过程。</strong>  </p>
<p><strong>符号引用</strong>：定义在Java虚拟机规范的Class文件格式中（与虚拟机内存布局无关）<br><strong>直接引用</strong>：直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。（与虚拟机内存布局相关）</p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>类初始化阶段是类加载过程的最后一步。<strong>初始化阶段才真正开始执行类中定义的Java程序代码。</strong></p>
<p>在准备阶段，类变量被赋了初始值，在初始化阶段才会真正赋值。或者说，初始化阶段是执行类构造器<clinit>()方法的过程。</clinit></p>
<h5 id="方法"><a href="#方法" class="headerlink" title="()方法"></a><clinit>()方法</clinit></h5><ul>
<li><clinit>()方法是编译器自动收集类中的所有变量的赋值动作和静态语句块（static{}）中的语句合并产生的，顺序由源文件顺序决定。</clinit></li>
<li><clinit>()方法与类的构造函数不同（实例构造器<init>()），它不需要显示地调用父类构造器，虚拟机保证子类<clinit>()方法执行之前，父类<clinit>()方法已经执行完毕。因此，JVM中第一个执行的<clinit>()方法的类是java.lang.Object。</clinit></clinit></clinit></init></clinit></li>
<li><clinit>()方法对于类或接口来说不是必须的，一个类没有静态语句块或者没有对变量的赋值操作，可以没有<clinit>()方法</clinit></clinit></li>
<li>接口中有变量初始化赋值的操作时，会生成<clinit>()方法。但接口不需要执行父接口的<clinit>()方法。接口的实现类在初始化时也不要=会执行接口的<clinit>()方法。</clinit></clinit></clinit></li>
<li>虚拟机保证一个类的<clinit>()方法会在多线程情况下加锁、同步。只有一个线程会执行<clinit>()方法成功。</clinit></clinit></li>
</ul>
<h3 id="三、类加载器"><a href="#三、类加载器" class="headerlink" title="三、类加载器"></a>三、类加载器</h3><p>在加载阶段中，<strong>“通过一个类的全限定名来获取定义此类的二进制字节流”这个动作的实现是由类加载器来完成的。</strong><br>这个动作在JVM外部实现，以便让应用程序自己决定如何去获取所需要的类。</p>
<p><strong>简而言之，类加载器用于实现类的加载动作。</strong></p>
<p>只有由同一个类加载器加载的两个类才相等。若同一个Class文件由不同的类加载器加载，则不相等。</p>
<h4 id="3种类加载器"><a href="#3种类加载器" class="headerlink" title="3种类加载器"></a>3种类加载器</h4><p><img src="http://osuskkx7k.bkt.clouddn.com/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8.png" alt="image"></p>
<ul>
<li><strong>启动类加载器（Bootstrap ClassLoader）</strong>：负责加载<java_home>\lib目录中，或者被-Xbootclasspath参数所指定的路径中，并且被虚拟机识别的如rt.jar等类库</java_home></li>
<li><strong>扩展类加载器（Extension ClassLoader）</strong>：加载<java_home>\lib\ext目录中的，或通过java.ext.dirs系统变量指定路径中的类库</java_home></li>
<li><strong>应用程序类加载器（Application ClassLoader</strong>）：加载用户类路径（ClassPath）上指定的类库，也叫系统类加载器，程序默认的类加载器</li>
</ul>
<h4 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h4><p>工作过程：<strong>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此。因此所有的加载请求最终都会传送到顶层的启动类加载器中，只有当父加载器无法完成这个加载请求时，子加载器才会自己去加载。</strong></p>
<p>双亲委派模型有什么好处？  </p>
<p>保证了Java程序的稳定运行。<br>例如，java.lang.Object存放在rt.jar中，无论哪一个类加载器加载这个类，最终都会委派给启动类加载器进行加载，<strong>因此Object类在程序的各种类加载器环境中都是同一个类。</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、类加载机制&quot;&gt;&lt;a href=&quot;#一、类加载机制&quot; class=&quot;headerlink&quot; title=&quot;一、类加载机制&quot;&gt;&lt;/a&gt;一、类加载机制&lt;/h3&gt;&lt;p&gt;虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被J
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
      <category term="类加载机制" scheme="http://yoursite.com/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>JVM之垃圾收集器</title>
    <link href="http://yoursite.com/2017/10/23/JVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
    <id>http://yoursite.com/2017/10/23/JVM之垃圾收集器/</id>
    <published>2017-10-23T11:28:13.000Z</published>
    <updated>2018-02-24T06:43:07.465Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、垃圾收集器概述"><a href="#一、垃圾收集器概述" class="headerlink" title="一、垃圾收集器概述"></a>一、垃圾收集器概述</h3><p><strong>垃圾收集器是内存垃圾回收算法的具体实现。</strong><br>Java虚拟机规范中对垃圾收集器应该如何实现并没有任何规定，因此出现了7种收集器：Serial、ParNew、Parallel Scavenge、Serial Old、Parallel Old、CMS、G1。<br>它们以组合的形式配合工作来完成不同分代的垃圾收集工作。</p>
<p><strong>常用组合</strong>：</p>
<ol>
<li>Serial/Serial Old</li>
<li>ParNew/Serial Old</li>
<li>ParNew/CMS</li>
<li>Parallel Scavenge/Parallel Old</li>
<li>G1</li>
</ol>
<p><img src="http://osuskkx7k.bkt.clouddn.com/JVMtool2.png" alt="image"></p>
<h4 id="Minor-GC和Full-GC"><a href="#Minor-GC和Full-GC" class="headerlink" title="Minor GC和Full GC"></a>Minor GC和Full GC</h4><p>Minor GC（新生代GC）：发生在新生代的GC动作，频率高，回收速度块。</p>
<p>Full GC（老年代GC）：发生在老年代的GC动作，老年代满了后才进行，一般伴随至少一次Minor GC，频率低，回收速度慢。</p>
<h4 id="垃圾收集器种类"><a href="#垃圾收集器种类" class="headerlink" title="垃圾收集器种类"></a>垃圾收集器种类</h4><p>目前的收集器主要有以下三种：  </p>
<p><strong>串行收集器：</strong> 只有一条垃圾收集线程工作  </p>
<p><strong>并行收集器：</strong> 多条垃圾收集线程并行工作，用户线程等待</p>
<p><strong>并发收集器：</strong> 垃圾收集线程与用户线程同时执行（不一定并行，可能交替执行）</p>
<h3 id="二、垃圾收集器详述"><a href="#二、垃圾收集器详述" class="headerlink" title="二、垃圾收集器详述"></a>二、垃圾收集器详述</h3><h4 id="新生代收集器（3种）"><a href="#新生代收集器（3种）" class="headerlink" title="新生代收集器（3种）"></a>新生代收集器（3种）</h4><h5 id="Serial-收集器（串行）"><a href="#Serial-收集器（串行）" class="headerlink" title="Serial 收集器（串行）"></a>Serial 收集器（串行）</h5><p>Serial收集器是一个单线程的收集器。<br>“单线程”：不仅只是有一条收集线程，而且必须暂停用户工作线程。 </p>
<p>工作过程：  </p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/seria.png" alt="image"></p>
<p><strong>特点：</strong> 单线程，无线程切换，简单高效，（管理内存小，停顿可以接受）<br><strong>缺点：</strong>  暂停工作线程<br><strong>应用场景：</strong> 适用于运行在Client模式下的虚拟机</p>
<h5 id="ParNew-收集器（并行）"><a href="#ParNew-收集器（并行）" class="headerlink" title="ParNew 收集器（并行）"></a>ParNew 收集器（并行）</h5><p>ParNew收集器是Serial收集器的多线程版本。</p>
<p>工作过程：  </p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/ParNew.png" alt="image"></p>
<p><strong>特点：</strong> 多线程，除Serial外唯一能和CMS收集器配合<br><strong>缺点：</strong>  暂停工作线程，单线程下不如Serial<br><strong>应用场景：</strong> 适用于运行在Server模式下的虚拟机</p>
<h5 id="Parallel-Scavenge-收集器（并行）"><a href="#Parallel-Scavenge-收集器（并行）" class="headerlink" title="Parallel Scavenge 收集器（并行）"></a>Parallel Scavenge 收集器（并行）</h5><p>Parallel Scavenge收集器被称为“吞吐量优先”收集器。</p>
<p>工作过程：  </p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/parallel%20scavenge.png" alt="image"></p>
<p><strong>特点：</strong> </p>
<ul>
<li><strong>可控制吞吐量。</strong><br>吞吐量 = 用户代码时间/（用户代码时间+垃圾收集时间）<br>吞吐量越高，表示越高效地利用CPU，适合后台运算任务。  </li>
<li><strong>GC 自适应调节策略</strong><br>JVM可以根据当前系统的运行情况自适应调节参数，以提供最合适的停顿时间和最大的吞吐量。</li>
</ul>
<p><strong>缺点：</strong> 相比停顿时间更注重吞吐量<br><strong>应用场景：</strong> 主要用于后台计算，不需要与用户进行太多交互，对暂停时间没有特别高的要求等场景，如批量处理；</p>
<h4 id="老年代收集器（3种）"><a href="#老年代收集器（3种）" class="headerlink" title="老年代收集器（3种）"></a>老年代收集器（3种）</h4><h5 id="Serial-Old-收集器（串行）"><a href="#Serial-Old-收集器（串行）" class="headerlink" title="Serial Old 收集器（串行）"></a>Serial Old 收集器（串行）</h5><p>Serial Old是Serial的老年代版本，同样是一个单线程收集器。  </p>
<p>工作过程：  </p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/seria.png" alt="image"></p>
<p><strong>特点：</strong> 单线程，“标记-整理”算法<br><strong>缺点：</strong>  暂停工作线程<br><strong>应用场景：</strong> 适用于运行在Client模式下的虚拟机</p>
<h5 id="Parallel-Old-收集器（并行）"><a href="#Parallel-Old-收集器（并行）" class="headerlink" title="Parallel Old 收集器（并行）"></a>Parallel Old 收集器（并行）</h5><p>Parallel Old是Parallel Scavenge收集器的老年代版本，多线程收集器。（JDK1.6之后出现）</p>
<p>工作过程：  </p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/parallel%20old.png" alt="image"></p>
<p><strong>特点：</strong> 多线程，“标记-整理”算法，唯一能和Parallel Scavenge收集器配合<br><strong>缺点：</strong>  暂停工作线程<br><strong>应用场景：</strong> 适用于注重吞吐量及CPU资源敏感的场合</p>
<h5 id="CMS-收集器（并发）"><a href="#CMS-收集器（并发）" class="headerlink" title="CMS 收集器（并发）"></a>CMS 收集器（并发）</h5><p><strong>CMS（Concurrent Mark Sweep）是一种以获取最短回收停顿时间为目标的收集器。<br>第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。</strong>  </p>
<p>工作过程分为<strong>4个步骤</strong>：  </p>
<ol>
<li><strong>初始标记</strong>：标记“GC-Roots”关联的对象（Stop the World）</li>
<li><strong>并发标记</strong>： 进行GC-Roots Tracing的过程，在刚才产生的集合中标记出存活对象；</li>
<li><strong>重新标记</strong>：修正并发标记期间因用户程序继续运作而导致标记变动的那一部分对象的标记记录（Stop the World）</li>
<li><strong>并发清除</strong>：回收所有垃圾对象</li>
</ol>
<p>所以，<strong>在初始标记和重新标记阶段，还是只有垃圾收集线程工作；并发标记和并发清除阶段是和用户线程并发执行的</strong>。</p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/CMS.png" alt="image"></p>
<p><strong>特点：</strong> 多线程并发执行，停顿时间短<br><strong>缺点：</strong>  </p>
<ul>
<li>对CPU资源十分敏感</li>
<li>无法处理浮动垃圾</li>
<li>产生大量空间碎片（由于是“标记-清除”算法）  </li>
</ul>
<p><strong>应用场景：</strong> 适用于大型网站或B/S的服务端，注重响应速度和用户体验。</p>
<h4 id="通用收集器"><a href="#通用收集器" class="headerlink" title="通用收集器"></a>通用收集器</h4><h5 id="G1-收集器（并发）"><a href="#G1-收集器（并发）" class="headerlink" title="G1 收集器（并发）"></a>G1 收集器（并发）</h5><p>G1是目前最前沿的收集器，可处理整个GC堆，JDK1.7之后出现。  </p>
<p><strong>G1是如何处理整个堆</strong>？<br>G1将整个堆划分为多个大小相等的独立区域Region（不再是新生代老年代），然后跟踪各个Region获得其垃圾收集价值大小，并在后台维护一个优先列表，根据允许的收集时间，优先回收价值最大的Region（名称Garbage-First的由来）。这个过程保证了在有限的时间内可以回收更多的垃圾。</p>
<p>工作过程分为<strong>4个步骤</strong>： </p>
<ol>
<li><strong>初始标记</strong>：标记“GC-Roots”关联的对象，并修改TAMS的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象</li>
<li><strong>并发标记</strong>：根据GC-Roots进行可达性分析，找出存活对象</li>
<li><strong>最终标记</strong>：为了修正并发标记期间由于用户程序继续运作而导致标记产生变动的那一部分对象的标示记录</li>
<li><strong>筛选回收</strong>：根据各个Region的价值回收</li>
</ol>
<p><img src="http://osuskkx7k.bkt.clouddn.com/G1.png" alt="image"></p>
<p><strong>特点：</strong> </p>
<ul>
<li>并行且并发  </li>
<li>独立处理整个GC堆，不需要配合其他收集器</li>
<li>可预测停顿时间</li>
<li>不产生空间碎片</li>
</ul>
<p><strong>应用场景：</strong> 面向服务器，适用于多CPU及大容量内存的机器。</p>
<h3 id="三、常见的参数配置"><a href="#三、常见的参数配置" class="headerlink" title="三、常见的参数配置"></a>三、常见的参数配置</h3><ul>
<li><strong>Xms</strong>：堆的最小值（初始）</li>
<li><strong>Xmx</strong>：堆的最大值<br>（Xms、Xmx二者一样时，可避免自动扩展）</li>
<li><strong>Xmn</strong>：堆中新生代的大小</li>
<li><strong>Xss</strong>：每个线程的堆栈大小</li>
<li><strong>XX:PermSize</strong>：永久代的大小（初始）</li>
<li><strong>XX:MaxPermSize</strong>：永久代的最大值</li>
<li><p><strong>XX:NewRatio</strong>：年轻代（包括Eden和两个Survivor区）与年老代的比值，设置为3，则年轻代与年老代所占比值为1：3，年轻代占整个堆栈的1/4</p>
</li>
<li><p><strong>XX:SurvivorRatio</strong>：年轻代中Eden区与Survivor区的大小比值。设置为4，则两个Survivor区与一个Eden区的比值为2:4，一个Survivor区占整个年轻代的1/6</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、垃圾收集器概述&quot;&gt;&lt;a href=&quot;#一、垃圾收集器概述&quot; class=&quot;headerlink&quot; title=&quot;一、垃圾收集器概述&quot;&gt;&lt;/a&gt;一、垃圾收集器概述&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;垃圾收集器是内存垃圾回收算法的具体实现。&lt;/strong&gt;&lt;br&gt;J
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
      <category term="垃圾收集器" scheme="http://yoursite.com/tags/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>JVM之垃圾收集算法</title>
    <link href="http://yoursite.com/2017/10/21/JVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2017/10/21/JVM之垃圾收集算法/</id>
    <published>2017-10-21T11:48:18.000Z</published>
    <updated>2017-10-23T13:58:22.016Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、对象的死亡判定"><a href="#一、对象的死亡判定" class="headerlink" title="一、对象的死亡判定"></a>一、对象的死亡判定</h3><p><strong>JVM垃圾回收针对哪些区域？回收的是什么？</strong><br><strong>答：</strong><br><strong>1. 主要针对Java堆。</strong><br><strong>2. 回收“死亡”的对象，即没有引用的对象。</strong></p>
<p>那么如何判断对象是否“死亡”呢？<br>两种方法，引用计数法和可达性分析算法。</p>
<h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p><strong>原理：给每个对象添加一个引用计数器。</strong></p>
<ul>
<li>每当有一个地方引用它，引用计数器+1；</li>
<li>每当一个引用失效，引用计数器-1；</li>
<li>当引用计数器为0时，表示该对象无引用，即可回收。</li>
</ul>
<p>缺点：无法解决对象之间循环引用的问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">GCobject A = new GCobject();</div><div class="line">GCobject B = new GCobject();</div><div class="line">A.instance = B;</div><div class="line">B.instance = A;</div><div class="line">...</div><div class="line">A = null;</div><div class="line">B = null;</div></pre></td></tr></table></figure>
<p>可以看到，A、B对象都为null，已经不可能再访问，但由于A、B都有字段引用着对方，引用计数器不为0，因此不会被回收。</p>
<h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p><strong>原理：通过一系列称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为“引用链”，当一个对象到 GC Roots没有任何引用链相连时, 则说明此对象是不可用的。</strong>  </p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/gc1.jpg.png" alt="image"></p>
<p>如图，Object5、Object6、Object7这三个对象就是不可用的。</p>
<p><strong>“GC Roots”对象：</strong></p>
<ul>
<li>虚拟机栈(栈帧中的本地变量表)中引用的对象；</li>
<li>方法区中类静态引用的对象；</li>
<li>方法区中常量引用的对象；</li>
<li>本地方法栈中JNI（Native方法）引用的对象；</li>
</ul>
<hr>
<p>然而，在可达性分析算法中不可达的对象，也并不是“非死不可”。<strong>一个对象真正死亡，至少要经历两次标记过程：</strong></p>
<ol>
<li><strong>第一次标记：</strong> 对象无GC Roots的引用链，筛选是否执行finalize()方法：  </li>
</ol>
<ul>
<li>对象没有覆盖finalize()或finalize()被JVM调用过，则不需要执行；</li>
<li>若执行finalize()，则将对象放入F-Queue队列中，会由JVM自动建立的线程执行该方法；</li>
</ul>
<ol>
<li><strong>第二次标记</strong>：对F-Queue队列中的对象进行小规模的标记：</li>
</ol>
<ul>
<li>对象在finalize()中拯救自己（重新与引用链相连），则不会回收；</li>
<li>对象没有在finalize()中逃脱；</li>
</ul>
<p><strong>注：任何一个对象的finalize()方法只能被调用一次。</strong></p>
<h3 id="二、垃圾收集算法"><a href="#二、垃圾收集算法" class="headerlink" title="二、垃圾收集算法"></a>二、垃圾收集算法</h3><p>主要有4种垃圾收集算法。<br><strong>Java堆从GC的角度可以细分为: 新生代(Eden区、From Survivor区和To Survivor区)和老年代。</strong></p>
<h4 id="标记-清除算法（老年代）"><a href="#标记-清除算法（老年代）" class="headerlink" title="标记-清除算法（老年代）"></a>标记-清除算法（老年代）</h4><p>它是最基础的收集算法，<strong>算法分为标记和清除两个阶段：</strong></p>
<ol>
<li>首先标记出所有可回收的对象</li>
<li>统一回收被标记对象</li>
</ol>
<p><img src="http://osuskkx7k.bkt.clouddn.com/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4.jpg" alt="image">  </p>
<p>不足：</p>
<ol>
<li>效率问题，标记和清除的效率不高；</li>
<li>空间问题，标记清除后容易产生不连续的空间碎片（不利于大对象的内存分配）</li>
</ol>
<h4 id="复制算法（新生代）"><a href="#复制算法（新生代）" class="headerlink" title="复制算法（新生代）"></a>复制算法（新生代）</h4><p><strong>算法的核心是将可用内存按容量划分为大小相等的两块，每次只用其中一块，当这一块的内存用完，就将还存活的对象复制到另外一块上面，然后把已使用过的内存空间一次清理掉。</strong>（如图）</p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.jpg" alt="image"></p>
<p>优点：无内存碎片；<br>不足：可用内存减小；  </p>
<p>针对以上不足，就有了<strong>现代复制算法</strong>：<br>不需完全按照1∶1的比例划分新生代空间，<br>将<strong>新生代划分为一块较大的Eden区和两块较小的Survivor区(from和to)</strong>(HotSpot默认Eden和Survivor的大小为8∶1)，每次只用Eden和其中一块Survivor（from）。</p>
<ul>
<li>当发生MinorGC时, 将Eden和Survivor(from)中还存活着的对象一次性地拷贝到另外一块Survivor(to)上，最后清理掉Eden和刚才用过的Survivor(from)空间。</li>
<li>当Survivor(to)空间不够用(不足以保存尚存活的对象)时, 需要依赖老年代进行空间分配担保机制，这部分内存直接进入老年代。</li>
</ul>
<p><strong>注：现代的商业虚拟机都是采用这种收集算法回收新生代。</strong></p>
<h4 id="标记-整理算法（老年代）"><a href="#标记-整理算法（老年代）" class="headerlink" title="标记-整理算法（老年代）"></a>标记-整理算法（老年代）</h4><p>标记-清除算法会产生内存碎片问题，而复制算法需要有额外的内存担保空间，于是针对老年代的特点，又有了标记整理算法。<br><strong>标记整理算法：标记过程与标记-清除算法相同， 但后续步骤不再对可回收对象直接清理， 而是让所有存活的对象都向一端移动，然后清理掉端边界以外的内存。</strong> （如图）  </p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86.jpg" alt="image"></p>
<h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><p>当前主流JVM垃圾收集都采用”分代收集”(Generational Collection)算法。 这种算法会根据对象存活周期的不同将内存划分为几块， 如JVM中的<strong>新生代、老年代、永久代</strong>。 这样就可以根据各年代特点分别采用最适当的GC算法：</p>
<ul>
<li><strong>新生代</strong>：每次垃圾收集都能发现大批对象已死， 只有少量存活。因此选用<strong>复制算法</strong>，只需要付出少量存活对象的复制成本就可以完成收集。</li>
<li><strong>老年代</strong>：因为对象存活率高、没有额外空间对它进行分配担保，就必须采用“<strong>标记—清理”或“标记—整理</strong>”算法来进行回收，不必进行内存复制，且直接腾出空闲内存。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、对象的死亡判定&quot;&gt;&lt;a href=&quot;#一、对象的死亡判定&quot; class=&quot;headerlink&quot; title=&quot;一、对象的死亡判定&quot;&gt;&lt;/a&gt;一、对象的死亡判定&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;JVM垃圾回收针对哪些区域？回收的是什么？&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
      <category term="垃圾收集算法" scheme="http://yoursite.com/tags/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>ReentrantLock重入锁</title>
    <link href="http://yoursite.com/2017/10/20/ReentrantLock%E9%87%8D%E5%85%A5%E9%94%81/"/>
    <id>http://yoursite.com/2017/10/20/ReentrantLock重入锁/</id>
    <published>2017-10-20T11:48:18.000Z</published>
    <updated>2017-10-23T13:58:54.746Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、ReentrantLock概念"><a href="#一、ReentrantLock概念" class="headerlink" title="一、ReentrantLock概念"></a>一、ReentrantLock概念</h3><h4 id="重入锁概念"><a href="#重入锁概念" class="headerlink" title="重入锁概念"></a>重入锁概念</h4><p>什么是重入锁？   顾名思义，就是支持重复进入的锁。<br><strong>定义：支持一个线程对资源的重复加锁。（注意是一个线程）</strong></p>
<p>回忆前面有关AQS实现的文章，关于独占锁，当一个线程获取锁后，如果该线程再次调用lock()方法，那么该线程会被自己阻塞。<br>原因是在实现tryAcquire()时没有考虑占有锁的线程再次获取锁的场景。因此这个锁是不支持重入的锁。  </p>
<p>回顾synchronized的实现原理，我们知道它也是支持重进入的锁，即可以多次获取锁。</p>
<p>那么Lock能不能实现这个功能呢？当然是可以的。<br>ReentrantLock就是一个支持重进入的锁：<strong>在调用lock()方法时，已经获取到锁的线程，可以再次调用lock()方法获取锁而不被阻塞。</strong></p>
<h4 id="公平与非公平"><a href="#公平与非公平" class="headerlink" title="公平与非公平"></a>公平与非公平</h4><p>关于锁的获取，还有一个公平性的问题，于是就有了公平锁与非公平锁：  </p>
<ul>
<li><strong>公平锁：获取锁是顺序的。先对锁请求的线程先获取；</strong>  </li>
<li><strong>非公平锁：获取锁是无序的。任意线程都可以获取，无关请求先后；</strong></li>
</ul>
<p>来看看ReentrantLock的构造函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public ReentrantLock() &#123;</div><div class="line">        sync = new NonfairSync();</div><div class="line">    &#125;</div><div class="line">public ReentrantLock(boolean fair) &#123;</div><div class="line">        sync = fair ? new FairSync() : new NonfairSync();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>可以看到，ReentrantLock默认构造函数是非公平锁，另一个构造函数：  </p>
<ul>
<li>传入true：公平锁  </li>
<li>传入false：非公平锁</li>
</ul>
<h3 id="二、ReentrantLock的实现原理"><a href="#二、ReentrantLock的实现原理" class="headerlink" title="二、ReentrantLock的实现原理"></a>二、ReentrantLock的实现原理</h3><h4 id="重进入"><a href="#重进入" class="headerlink" title="重进入"></a>重进入</h4><p><strong>重进入的实现原理是定义了一个获取锁的计数器</strong>。 涉及到以下两个问题：  </p>
<ol>
<li><strong>线程再次获取锁。</strong><br>锁需要识别获取锁的线程是否为当前占据锁的线程，如果是，则再次获取锁成功，计数器+1。</li>
<li><strong>锁的最终释放。</strong><br>线程重复n次获取了锁，在第n次释放锁后，其他线程能够获取到锁。释放锁时，计数器-1，计数器为0时表示锁释放成功。</li>
</ol>
<hr>
<p><strong>ReentrantLock</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class ReentrantLock implements Lock, java.io.Serializable &#123;</div><div class="line">private final Sync sync;</div><div class="line">//AQS</div><div class="line">abstract static class Sync extends AbstractQueuedSynchronizer &#123;...&#125;;</div><div class="line">//非公平锁</div><div class="line">static final class NonfairSync extends Sync &#123;...&#125;;</div><div class="line">//公平锁</div><div class="line">static final class FairSync extends Sync &#123;...&#125;;</div><div class="line"></div><div class="line">....(省略)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从源码可以看到，<strong>ReentrantLock的实现依旧是依靠队列同步器AQS（Sync继承自AQS），不同的是这里有两个AQS的实现类，NonfairSync和FairSync，分别实现非公平锁和公平锁的功能。</strong></p>
<h4 id="非公平锁的实现"><a href="#非公平锁的实现" class="headerlink" title="非公平锁的实现"></a>非公平锁的实现</h4><p>非公平锁获取锁的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">final boolean nonfairTryAcquire(int acquires) &#123;</div><div class="line">            final Thread current = Thread.currentThread();</div><div class="line">            int c = getState();</div><div class="line">            if (c == 0) &#123;</div><div class="line">                if (compareAndSetState(0, acquires)) &#123;</div><div class="line">                    setExclusiveOwnerThread(current);</div><div class="line">                    return true;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            else if (current == getExclusiveOwnerThread()) &#123;  //判断</div><div class="line">                int nextc = c + acquires;</div><div class="line">                if (nextc &lt; 0) // overflow</div><div class="line">                    throw new Error(&quot;Maximum lock count exceeded&quot;);</div><div class="line">                setState(nextc);</div><div class="line">                return true;</div><div class="line">            &#125;</div><div class="line">            return false;</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p>
<p>该方法是Sync中的方法，NonfairSync通过重写tryAcquire()调用。<br>可以看到，该方法增加了一个判断：如果当前线程是已经获取锁的线程，那么将同步状态值State增加 <strong>（这里不需要CAS操作，因为该线程已经获取了锁，没有竞争——相当于偏向锁）</strong>，并返回true，表示同步状态获取成功。</p>
<p>非公平锁释放锁的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">protected final boolean tryRelease(int releases) &#123;</div><div class="line">            int c = getState() - releases;</div><div class="line">            if (Thread.currentThread() != getExclusiveOwnerThread())</div><div class="line">                throw new IllegalMonitorStateException();</div><div class="line">            boolean free = false;</div><div class="line">            if (c == 0) &#123;</div><div class="line">                free = true;</div><div class="line">                setExclusiveOwnerThread(null);</div><div class="line">            &#125;</div><div class="line">            setState(c);</div><div class="line">            return free;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>该方法也是由Sync实现。</p>
<p>既然获取锁的时候增加了同步状态值，那么释放时自然要减少。<br>可以看到，只有当State值减为0的时候，才返回true，表示释放锁成功，并将占有线程设置为null。</p>
<h4 id="公平锁的实现"><a href="#公平锁的实现" class="headerlink" title="公平锁的实现"></a>公平锁的实现</h4><p>公平锁获取锁的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">protected final boolean tryAcquire(int acquires) &#123;</div><div class="line">            final Thread current = Thread.currentThread();</div><div class="line">            int c = getState();</div><div class="line">            if (c == 0) &#123;</div><div class="line">                if (!hasQueuedPredecessors() &amp;&amp;</div><div class="line">                    compareAndSetState(0, acquires)) &#123;</div><div class="line">                    setExclusiveOwnerThread(current);</div><div class="line">                    return true;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            else if (current == getExclusiveOwnerThread()) &#123;</div><div class="line">                int nextc = c + acquires;</div><div class="line">                if (nextc &lt; 0)</div><div class="line">                    throw new Error(&quot;Maximum lock count exceeded&quot;);</div><div class="line">                setState(nextc);</div><div class="line">                return true;</div><div class="line">            &#125;</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>该方法是FairSync重写的tryAcquire()方法。<br>对比非公平锁的获取，<strong>唯一不同的是该方法在判断时增加了一个条件——hasQueuedPredecessors()方法，该方法判断同步队列中当前节点是否有前驱节点，如果有，表示有线程比当前线程更早请求，则需要等待前面的线程获取释放锁之后才能获取锁。</strong></p>
<p>公平锁释放锁的方法：  </p>
<p>同样也是调用Sync中的tryRelease()方法，这里不再赘述。</p>
<h4 id="公平锁与非公平锁的对比"><a href="#公平锁与非公平锁的对比" class="headerlink" title="公平锁与非公平锁的对比"></a>公平锁与非公平锁的对比</h4><p><strong>公平锁：</strong></p>
<ul>
<li>保证了锁的获取顺序，FIFO原则</li>
<li>不足是需要进行大量的线程切换</li>
</ul>
<p><strong>非公平锁</strong>：  </p>
<ul>
<li>保证了更大的吞吐量（极少的线程切换）</li>
<li>不足是可能造成线程“饥饿”（等待很久）</li>
</ul>
<p><strong>频繁的线程切换对性能有很大的影响，因此ReentrantLock的默认实现是非公平锁。</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、ReentrantLock概念&quot;&gt;&lt;a href=&quot;#一、ReentrantLock概念&quot; class=&quot;headerlink&quot; title=&quot;一、ReentrantLock概念&quot;&gt;&lt;/a&gt;一、ReentrantLock概念&lt;/h3&gt;&lt;h4 id=&quot;重入锁概念
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="ReentrantLock" scheme="http://yoursite.com/tags/ReentrantLock/"/>
    
      <category term="重入锁" scheme="http://yoursite.com/tags/%E9%87%8D%E5%85%A5%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>AQS共享锁的实现原理</title>
    <link href="http://yoursite.com/2017/10/19/AQS%E5%85%B1%E4%BA%AB%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2017/10/19/AQS共享锁的实现原理/</id>
    <published>2017-10-19T11:48:18.000Z</published>
    <updated>2017-10-23T13:55:46.632Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、AQS共享锁的实现原理"><a href="#一、AQS共享锁的实现原理" class="headerlink" title="一、AQS共享锁的实现原理"></a>一、AQS共享锁的实现原理</h3><p>前面的文章Lock的实现中分析了AQS独占锁的实现原理，那么接下来就分析下AQS是如何实现共享锁的。</p>
<h4 id="共享锁的介绍"><a href="#共享锁的介绍" class="headerlink" title="共享锁的介绍"></a>共享锁的介绍</h4><p><strong>共享锁：同一时刻有多个线程能够获取到同步状态。</strong></p>
<p>那么它是如何做到让多个线程获取到同步状态呢？<br>来看一下获取共享锁的过程：</p>
<ol>
<li>线程调用AQS的acquireShared()申请获取锁（可有多个线程获取到，根据重写的tryAcquireShared()方法决定），如果成功则进入临界区。</li>
<li>如果失败，创建一个共享型的节点进入FIFO等待队列，阻塞然后等待唤醒。</li>
<li>等待队列中的线程被唤醒重新尝试获取锁，<strong>获取成功后根据state变量值决定是否继续唤醒后续节点（如果state值为0，表示没有可用的锁，不唤醒后继节点；如果state的值&gt;0，表示有可用的锁，唤醒后继节点）</strong>，获取失败则继续等待，直到成功。</li>
</ol>
<p>释放共享锁的过程：</p>
<ol>
<li>线程调用releaseShared()进行锁资源释放，如果释放成功则唤醒队列中等待的节点（如果有）。</li>
</ol>
<h4 id="共享式获取锁"><a href="#共享式获取锁" class="headerlink" title="共享式获取锁"></a>共享式获取锁</h4><p>线程调用acquireShared()方法获取锁：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public final void acquireShared(int arg) &#123;</div><div class="line">        if (tryAcquireShared(arg) &lt; 0)</div><div class="line">            doAcquireShared(arg); //获取失败进入该方法</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>分析如下：</p>
<ul>
<li>当tryAcquireShared(arg)返回值&gt;=0时（可以在重写该方法时自定义锁的数量），表示获取锁成功，不会进入doAcquireShared。</li>
<li>当tryAcquireShared(arg)返回值&lt;0时,进入doAcquireShared(arg)方法，可以猜想这里应该是构造节点放入等待队列，看如下代码：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">private void doAcquireShared(int arg) &#123;</div><div class="line">        final Node node = addWaiter(Node.SHARED);  //构造等待队列，和独占锁类似</div><div class="line">        boolean failed = true;</div><div class="line">        try &#123;</div><div class="line">            boolean interrupted = false;</div><div class="line">            for (;;) &#123;       //自旋</div><div class="line">                final Node p = node.predecessor(); //获取前驱节点</div><div class="line">                if (p == head) &#123;</div><div class="line">                    int r = tryAcquireShared(arg); //再次尝试获取</div><div class="line">                    if (r &gt;= 0) &#123;</div><div class="line">                        setHeadAndPropagate(node, r);</div><div class="line">                        p.next = null; // help GC</div><div class="line">                        if (interrupted)</div><div class="line">                            selfInterrupt();</div><div class="line">                        failed = false;</div><div class="line">                        return;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div class="line">                    parkAndCheckInterrupt())</div><div class="line">                    interrupted = true;</div><div class="line">            &#125;</div><div class="line">        &#125; finally &#123;</div><div class="line">            if (failed)</div><div class="line">                cancelAcquire(node);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>可以看到，当前驱节点是头节点head时，线程尝试获取锁，此时注意返回值r，有以下三种可能：</p>
<ul>
<li>r<0，表示获取锁失败，继续自旋直到r>=0；</0，表示获取锁失败，继续自旋直到r></li>
<li>r=0，表示获取锁成功，但刚好是最后一把锁，不会唤醒后继节点，在setHeadAndPropagate(node, r)方法中可以体现出来，后面会分析到；</li>
<li>r&gt;0，表示获取锁成功，而且还有锁资源，会唤醒后继节点，同样在setHeadAndPropagate(node, r)方法中可以体现。  </li>
</ul>
<p>那么就来看一下setHeadAndPropagate(node, r)这个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">private void setHeadAndPropagate(Node node, int propagate) &#123;</div><div class="line">        Node h = head; // 记录原来的头节点</div><div class="line">        setHead(node);  // 将当前节点设置为头节点</div><div class="line">        if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 ||</div><div class="line">        (h = head) == null || h.waitStatus &lt; 0) &#123;</div><div class="line">            Node s = node.next;</div><div class="line">            if (s == null || s.isShared())</div><div class="line">                doReleaseShared();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>注意这里propagate的值就是上一个方法中的r，首先将当前节点设置为头节点，然后if中的判断表示以下两种情况需要执行唤醒操作：</p>
<ol>
<li>根据r的值判断，r&gt;0时，表示可以唤醒后继节点，执行doReleaseShared()方法；而当r=0时，不会直接执行doReleaseShared()方法，而是进入第二种情况继续判断；</li>
<li>头节点后面的节点需要被唤醒（waitStatus&lt;0），不论是老的头结点还是新的头结点</li>
</ol>
<p>接下来看看doReleaseShared()这个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">private void doReleaseShared() &#123;</div><div class="line">        for (;;) &#123; //自旋</div><div class="line">            Node h = head;</div><div class="line">            if (h != null &amp;&amp; h != tail) &#123;</div><div class="line">                int ws = h.waitStatus;</div><div class="line">                if (ws == Node.SIGNAL) &#123; //表示后继节点需要被唤醒</div><div class="line">                    if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))</div><div class="line">                        continue;            // loop to recheck cases</div><div class="line">                    unparkSuccessor(h); //唤醒</div><div class="line">                &#125;</div><div class="line">                else if (ws == 0 &amp;&amp;</div><div class="line">                         !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))</div><div class="line">                    continue;    //如果后继节点暂时不需要唤醒，则把当前节点状态设置为PROPAGATE确保以后可以传递下去</div><div class="line">            &#125;</div><div class="line">            if (h == head)                   // loop if head changed</div><div class="line">                break;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这里有两个入口可以进入该方法，一个是直接释放锁releaseShared()一个是上述setHeadAndPropagate()方法，因此在释放锁的过程中需要使用CAS操作保证线程安全。</p>
<ol>
<li>进入第一个if语句，表示后继节点需要被唤醒，采用CAS循环操作直到成功；</li>
<li>进入else if语句，表示暂时不需要唤醒，将状态传递；</li>
<li>最后判断头节点是否变化，没有变化则退出循环；如果头结点发生变化，比如说其他线程获取到了锁，为了使自己的唤醒动作可以传递，必须进行重试</li>
</ol>
<p>以上就是获取共享锁的大致过程。</p>
<h4 id="共享式释放锁"><a href="#共享式释放锁" class="headerlink" title="共享式释放锁"></a>共享式释放锁</h4><p>调用releaseShared()方法主动释放锁：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public final boolean releaseShared(int arg) &#123;</div><div class="line">        if (tryReleaseShared(arg)) &#123;</div><div class="line">            doReleaseShared();</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line">        return false;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>可以看到，当重写的tryReleaseShared(arg)方法返回true,成功释放锁资源，进入doReleaseShared()唤醒等待的线程，这个方法上面已经分析过，这里不再赘述。</p>
<h3 id="二、AQS共享锁与独占锁的对比"><a href="#二、AQS共享锁与独占锁的对比" class="headerlink" title="二、AQS共享锁与独占锁的对比"></a>二、AQS共享锁与独占锁的对比</h3><p>共享锁的实现稍比独占锁复杂，但大同小异。二者对比如下：</p>
<ul>
<li><strong>独占锁：</strong>  </li>
</ul>
<ol>
<li><p>独占锁是只有头节点获取锁，其余节点的线程继续等待，等待锁被释放后，才会唤醒下一个节点的线程；</p>
</li>
<li><p>同步状态state值在0和1之间切换，保证同一时间只能有一个线程是处于活动的，其他线程都被阻塞，参考ReentranLock。</p>
</li>
<li>独占锁是一种悲观锁。 </li>
</ol>
<ul>
<li><strong>共享锁：</strong>  </li>
</ul>
<ol>
<li>共享锁是只要头节点获取锁成功，就在唤醒自身节点对应的线程的同时，继续唤醒AQS队列中的下一个节点的线程，每个节点在唤醒自身的同时还会唤醒下一个节点对应的线程，以实现共享状态的“向后传播”，从而实现共享功能。</li>
<li>同步状态state值在整数区间内（自定义实现），如果state值&lt;0则阻塞，否则不阻塞。参考ReadWriteLock、Semphore、CountDownLautch等。</li>
<li>共享锁是一种乐观锁，允许多个线程同时访问共享资源。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、AQS共享锁的实现原理&quot;&gt;&lt;a href=&quot;#一、AQS共享锁的实现原理&quot; class=&quot;headerlink&quot; title=&quot;一、AQS共享锁的实现原理&quot;&gt;&lt;/a&gt;一、AQS共享锁的实现原理&lt;/h3&gt;&lt;p&gt;前面的文章Lock的实现中分析了AQS独占锁的实现原
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="AQS" scheme="http://yoursite.com/tags/AQS/"/>
    
      <category term="共享锁" scheme="http://yoursite.com/tags/%E5%85%B1%E4%BA%AB%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>Lock实现之AQS——AbstractQueuedSynchronizer</title>
    <link href="http://yoursite.com/2017/10/18/Lock%E5%AE%9E%E7%8E%B0%E4%B9%8BAQS%E2%80%94%E2%80%94AbstractQueuedSynchronizer/"/>
    <id>http://yoursite.com/2017/10/18/Lock实现之AQS——AbstractQueuedSynchronizer/</id>
    <published>2017-10-18T09:48:18.000Z</published>
    <updated>2017-10-18T11:30:17.136Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、AQS的介绍"><a href="#一、AQS的介绍" class="headerlink" title="一、AQS的介绍"></a>一、AQS的介绍</h3><p><strong>队列同步器AbstractQueuedSynchronizer（AQS）是构建锁或者其他同步组件的基础框架，是实现Lock的基础。它使用了一个volatile修饰的int变量来表示同步状态，并维护了一个FIFO队列来完成资源获取线程的排队。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public abstract class AbstractQueuedSynchronizer extends AbstractOwnableSynchronizer </div><div class="line">implements java.io.Serializable &#123;</div><div class="line"> </div><div class="line"> private transient volatile Node head;//头节点</div><div class="line"> private transient volatile Node tail;//尾节点</div><div class="line"> private volatile int state;          //同步状态</div><div class="line"> protected final int getState() &#123;</div><div class="line">      return state;</div><div class="line"> &#125;</div><div class="line">protected final void setState(int newState) &#123;</div><div class="line">    state = newState;</div><div class="line">&#125;</div><div class="line">protected final boolean compareAndSetState(int expect, int update) &#123;</div><div class="line">   return unsafe.compareAndSwapInt(this, stateOffset, expect, update);</div><div class="line">&#125;</div><div class="line">...</div></pre></td></tr></table></figure>
<p>从上面AQS的部分代码可以看到，AQS是一个类，它包含了表示同步状态的state变量（volatile修饰）；维护队列的两个引用头节点head和尾节点tail（volatile修饰）；以及提供了三个主要方法，用来保证同步状态的改变是线程安全的；省略了其他方法。</p>
<p>那么AQS是如何实现锁的呢？<br><strong>当我们需要实现锁的时候，首先继承AQS并重写指定的方法，然后将AQS子类组合在自定义组件（锁）的实现中，并调用AQS的模板方法，而这些模板方法将会调用我们重写的方法（模板方法模式）</strong>，这就可以达到我们想要的效果。<br><strong>注：重写指定的方法时需要用到AQS中的三个主要方法来对同步状态进行访问或修改。</strong></p>
<p>AQS中可重写的方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">protected boolean tryAcquire(int arg) &#123;&#125; //独占式获取</div><div class="line">protected boolean tryRelease(int arg) &#123;&#125; //独占式释放</div><div class="line">protected int tryAcquireShared(int arg) &#123;&#125; //共享式获取</div><div class="line">protected boolean tryReleaseShared(int arg) &#123;&#125; //共享式释放</div><div class="line">protected boolean isHeldExclusively() &#123;&#125; //判断AQS是否被该线程独占</div></pre></td></tr></table></figure></p>
<p>来看一个独占锁的示例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">class Mutex implements Lock, java.io.Serializable &#123;</div><div class="line">   // 内部类，自定义同步器，继承AQS</div><div class="line">   private static class Sync extends AbstractQueuedSynchronizer &#123;</div><div class="line">     // 重写方法——是否处于占用状态</div><div class="line">     protected boolean isHeldExclusively() &#123;</div><div class="line">       return getState() == 1;</div><div class="line">     &#125;</div><div class="line">     // 重写方法——当状态为0的时候获取锁</div><div class="line">     public boolean tryAcquire(int acquires) &#123;</div><div class="line">       assert acquires == 1; // Otherwise unused</div><div class="line">       if (compareAndSetState(0, 1)) &#123;</div><div class="line">         setExclusiveOwnerThread(Thread.currentThread());</div><div class="line">         return true;</div><div class="line">       &#125;</div><div class="line">       return false;</div><div class="line">     &#125;</div><div class="line">     // 重写方法——释放锁，将状态设置为0</div><div class="line">     protected boolean tryRelease(int releases) &#123;</div><div class="line">       assert releases == 1; // Otherwise unused</div><div class="line">       if (getState() == 0) throw new IllegalMonitorStateException();</div><div class="line">       setExclusiveOwnerThread(null);</div><div class="line">       setState(0);</div><div class="line">       return true;</div><div class="line">     &#125;</div><div class="line">     // 返回一个Condition，每个condition都包含了一个condition队列</div><div class="line">     Condition newCondition() &#123; return new ConditionObject(); &#125;</div><div class="line">   &#125;</div><div class="line">   // 仅需要将操作代理到Sync上即可</div><div class="line">   private final Sync sync = new Sync();</div><div class="line">   public void lock()                &#123; sync.acquire(1); &#125;</div><div class="line">   public boolean tryLock()          &#123; return sync.tryAcquire(1); &#125;</div><div class="line">   public void unlock()              &#123; sync.release(1); &#125;</div><div class="line">   public Condition newCondition()   &#123; return sync.newCondition(); &#125;</div><div class="line">   public boolean isLocked()         &#123; return sync.isHeldExclusively(); &#125;</div><div class="line">   public boolean hasQueuedThreads() &#123; return sync.hasQueuedThreads(); &#125;</div><div class="line">   public void lockInterruptibly() throws InterruptedException &#123;</div><div class="line">     sync.acquireInterruptibly(1);</div><div class="line">   &#125;</div><div class="line">   public boolean tryLock(long timeout, TimeUnit unit)</div><div class="line">       throws InterruptedException &#123;</div><div class="line">     return sync.tryAcquireNanos(1, unit.toNanos(timeout));</div><div class="line">   &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>以上就是利用AQS来实现一个独占锁的示例。<br>Mutex是一个自定义的Lock，它在同一时刻只允许一个线程占有锁。<strong>它定义了一个静态内部类继承自AQS，并重写了相应的方法，实现了独占式的获取释放锁。</strong><br>在重写的tryAcquire方法中，<strong>调用CAS方法改变同步状态，因为是原子操作只有一个线程能完成</strong>；在重写的tryRelease方法中将同步状态设为0。<br>在使用这个Lock时，我们只要调用Mutex的方法，有关同步的细节都由同步器完成。大大降低了自定义并发组件的门槛。</p>
<h3 id="二、AQS的实现原理分析"><a href="#二、AQS的实现原理分析" class="headerlink" title="二、AQS的实现原理分析"></a>二、AQS的实现原理分析</h3><p>知道了AQS的用法，那么就来分析下它的实现原理。<br><strong>同步器可分为独占式和共享式。</strong> 一般只实现其中一种。这里主要分析独占锁的实现。</p>
<h4 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h4><p>AQS是依靠内部的同步队列来完成同步状态的管理，当前线程获取同步状态失败时，会将当前线程以及等待状态等信息构造成一个节点（node）加入同步队列，并阻塞当前线程。当同步状态释放时，会把首节点中的线程唤醒，使其尝试获取同步状态。</p>
<h5 id="Node类"><a href="#Node类" class="headerlink" title="Node类"></a>Node类</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">static final class Node &#123;</div><div class="line">        static final Node SHARED = new Node();</div><div class="line">        static final Node EXCLUSIVE = null;</div><div class="line">        static final int CANCELLED =  1;</div><div class="line">        static final int SIGNAL    = -1;</div><div class="line">        static final int CONDITION = -2;</div><div class="line">        static final int PROPAGATE = -3;</div><div class="line">        volatile int waitStatus; //线程的等待状态（上述）</div><div class="line">        volatile Node prev; //前驱节点</div><div class="line">        volatile Node next; //后继节点</div><div class="line">        volatile Thread thread; //线程引用</div><div class="line">        Node nextWaiter; //等待队列中的后继节点</div><div class="line">        ...</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>Node是AQS维护的静态内部类。用来保存线程引用（失败）、等待状态和前后节点。<br>节点是构成同步队列的基础，同步器拥有首节点（head）和尾节点（tail），获取同步状态失败的线程会成为节点加入队列的尾部。同步器结构如下：<br><img src="http://osuskkx7k.bkt.clouddn.com/AQS2.png?imageView2/2/w/500/h/300" alt="image"></p>
<p><strong>注：构造节点的过程必须保证线程安全，因为会有多个线程失败。那么它是如何做到的？AQS提供了一个基于CAS的构造尾节点的方法compareAndSetTail，它可以保证节点被正确地加入到队列中。</strong></p>
<h4 id="独占式获取锁"><a href="#独占式获取锁" class="headerlink" title="独占式获取锁"></a>独占式获取锁</h4><p>来看一看获取锁的流程。<br>调用AQS的acquire（int args）方法获取同步状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public final void acquire(int arg) &#123;</div><div class="line">    if (!tryAcquire(arg) &amp;&amp;acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</div><div class="line">            selfInterrupt();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><strong>&amp;&amp;：</strong> 短路与，当第一个为false时不再判断后面条件；第一个为true时还会判断第二个条件；<br><strong>&amp;:</strong>     当第一个为false时，还会判断后面的条件；</p>
<ul>
<li>当成功获取锁，即tryAcquire(arg)为true时，!tryAcquire(arg) 为false，跳出if，此时执行selfInterrupt()；</li>
<li>当没有成功获取锁，即tryAcquire(arg)为false时，!tryAcquire(arg) 为true时，接着判断第二个条件，两个步骤： </li>
</ul>
<p>步骤一：  addWaiter(Node.EXCLUSIVE)：将该节点加入同步队列的尾部,返回该节点；<br>步骤二： acquireQueued(Node node, arg))：使该节点以”死循环”的方式获取同步状态；若获取不到则阻塞节点中的线程，被阻塞的线程的唤醒主要依靠前驱节点的出队或阻塞线程被中断来实现。</p>
<p><strong>分析步骤一：addWaiter方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">private Node addWaiter(Node mode) &#123;</div><div class="line">        Node node = new Node(Thread.currentThread(), mode);</div><div class="line">        Node pred = tail;</div><div class="line">        if (pred != null) &#123; //如果有尾节点，快速尝试在尾部添加，减少开销</div><div class="line">            node.prev = pred;</div><div class="line">            if (compareAndSetTail(pred, node)) &#123;</div><div class="line">                pred.next = node;</div><div class="line">                return node;                  //如果已经有尾节点，利用CAS将自己添加为尾节点之后返回</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        enq(node);          //如果没有尾节点，那么进入enq方法</div><div class="line">        return node;</div><div class="line">    &#125;</div><div class="line">private Node enq(final Node node) &#123;</div><div class="line">        for (;;) &#123;</div><div class="line">            Node t = tail;</div><div class="line">            if (t == null) &#123;        </div><div class="line">                if (compareAndSetHead(new Node()))    //初始化头节点</div><div class="line">                    tail = head;</div><div class="line">            &#125; else &#123;</div><div class="line">                node.prev = t;</div><div class="line">                if (compareAndSetTail(t, node)) &#123;   //CAS添加node为尾节点</div><div class="line">                    t.next = node;</div><div class="line">                    return t;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>可以看到，若队列还未生成即没有尾节点，则进入enq方法中，先创造一个头节点，然后通过死循环<strong>for(;;)</strong> 来保证节点的正确添加，再通过<strong>compareAndSetTail（CAS）</strong> 这个方法确保节点能够被线程安全地添加（可以想象多个线程获取同步失败后，如果不保证线程安全添加，将导致顺序混乱，可能丢失线程），只有从CAS返回后，线程才能返回，否则将不断尝试。<br>这个enq方法将并发的添加节点的请求通过CAS变得串行化了。</p>
<p><strong>分析步骤二：acquireQueued方法</strong><br>节点进入同步队列后，就进入了一个自旋的过程，每个节点（或线程）都在自省的观察，当获取到同步状态就可以从自旋中退出，否则依旧自旋。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">final boolean acquireQueued(final Node node, int arg) &#123;</div><div class="line">        boolean failed = true;</div><div class="line">        try &#123;</div><div class="line">            boolean interrupted = false;</div><div class="line">            for (;;) &#123;</div><div class="line">                final Node p = node.predecessor();     //获得前驱节点</div><div class="line">                if (p == head &amp;&amp; tryAcquire(arg)) &#123;  //只有前驱节点是头节点才尝试获取锁，false直接跳出if</div><div class="line">                    setHead(node);        //获取成功，将自己设置为头节点</div><div class="line">                    p.next = null;           // help GC</div><div class="line">                    failed = false;</div><div class="line">                    return interrupted;       //返回false，回到acquire方法中，不执行selfInterrupt();</div><div class="line">                &#125;</div><div class="line">                if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div class="line">                    parkAndCheckInterrupt())</div><div class="line">                    interrupted = true;</div><div class="line">            &#125;</div><div class="line">        &#125; finally &#123;</div><div class="line">            if (failed)</div><div class="line">                cancelAcquire(node);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">private void setHead(Node node) &#123;</div><div class="line">        head = node;</div><div class="line">        node.thread = null;</div><div class="line">        node.prev = null;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这段代码主要做了2件事：</p>
<ol>
<li><p>判断当前节点的前驱节点是否为头节点并尝试tryAcquire，只有当前驱节点是head的节点才会尝试tryAcquire，如果节点尝试tryAcquire成功，执行setHead方法将当前节点作为head、将当前节点中的thread设置为null、将当前节点的prev设置为null，这保证了链表中头结点永远是一个不带Thread的空节点；</p>
</li>
<li><p>如果当前节点的前驱节点不是头节点或者tryAcquire失败，那么执行第13行~第15行的代码，做了两步操作，首先判断在acquie失败后是否应该park（阻塞），其次park并检查中断状态；  </p>
</li>
</ol>
<p>分析下第2件事：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123;</div><div class="line">        int ws = pred.waitStatus;</div><div class="line">        if (ws == Node.SIGNAL)     //ws=SIGNAL= -1</div><div class="line">            return true;</div><div class="line">        if (ws &gt; 0) &#123;             //ws=CANCELLED= 1</div><div class="line">            do &#123;</div><div class="line">                node.prev = pred = pred.prev;</div><div class="line">            &#125; while (pred.waitStatus &gt; 0);</div><div class="line">            pred.next = node;</div><div class="line">        &#125; else &#123;                 //ws=CONDITION= -2 or PROPAGATE= -3</div><div class="line">            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</div><div class="line">        &#125;</div><div class="line">        return false;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>­这个方法做了以下工作，<br>­每个节点判断它前驱节点的状态：  </p>
<ol>
<li>它的前驱节点是SIGNAL状态的，返回true，表示当前节点应当park(阻塞)，执行parkAndCheckInterrupt()，­该方法利用LockSupport的park方法让当前线程阻塞，如下。 </li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">private final boolean parkAndCheckInterrupt() &#123;</div><div class="line">        LockSupport.park(this);</div><div class="line">        return Thread.interrupted();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ol>
<li>它的前驱节点的waitStatus&gt;0，即CANCELLED，那么CANCELLED的节点作废，当前节点不断向前找并重新连接为双向队列，直到找到一个前驱节点的waitStats不是CANCELLED的为止。</li>
<li>它的前驱节点不是SIGNAL状态且waitStatus&lt;=0，即CONDITION或PROPAGATE，此时执行第11行代码，利用CAS机制，将前驱节点的状态更新为SIGNAL状态。</li>
</ol>
<hr>
<h4 id="独占式释放锁"><a href="#独占式释放锁" class="headerlink" title="独占式释放锁"></a>独占式释放锁</h4><p>调用AQS的release方法可以释放同步状态，唤醒后继节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public final boolean release(int arg) &#123;</div><div class="line">        if (tryRelease(arg)) &#123;       </div><div class="line">            Node h = head;</div><div class="line">            if (h != null &amp;&amp; h.waitStatus != 0)</div><div class="line">                unparkSuccessor(h);  //调用LockSupport来唤醒处于等待状态的线程</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line">        return false;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>tryRelease释放成功，获取到head节点，如果head节点的waitStatus不为0的话，执行unparkSuccessor方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">private void unparkSuccessor(Node node) &#123;</div><div class="line">        int ws = node.waitStatus;</div><div class="line">        if (ws &lt; 0)</div><div class="line">            compareAndSetWaitStatus(node, ws, 0);</div><div class="line">        Node s = node.next;</div><div class="line">        if (s == null || s.waitStatus &gt; 0) &#123;</div><div class="line">            s = null;</div><div class="line">            for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)</div><div class="line">                if (t.waitStatus &lt;= 0)</div><div class="line">                    s = t;</div><div class="line">        &#125;</div><div class="line">        if (s != null)</div><div class="line">            LockSupport.unpark(s.thread);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这个方法做了以下工作：  </p>
<ol>
<li>头节点的waitStatus&lt;0，将头节点的waitStatus设置为0；</li>
<li>拿到头节点的下一个节点s，如果s==null或者s的waitStatus&gt;0（被取消了），那么从队列尾巴开始向前寻找一个waitStatus&lt;=0的节点作为后继要唤醒的节点；</li>
<li>如果拿到了一个不等于null的节点s，就利用LockSupport的unpark方法让它取消阻塞。<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4>获取同步状态时，AQS维护一个同步队列，获取状态失败的线程都会加入到队列中并在队列中进行自旋；移出队列的条件是前驱节点为头节点且获取同步状态成功。<br>释放同步状态时，头节点唤醒它的后继节点。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、AQS的介绍&quot;&gt;&lt;a href=&quot;#一、AQS的介绍&quot; class=&quot;headerlink&quot; title=&quot;一、AQS的介绍&quot;&gt;&lt;/a&gt;一、AQS的介绍&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;队列同步器AbstractQueuedSynchronizer（AQS）是构
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="AQS" scheme="http://yoursite.com/tags/AQS/"/>
    
      <category term="Lock" scheme="http://yoursite.com/tags/Lock/"/>
    
  </entry>
  
  <entry>
    <title>Lock接口的介绍及使用</title>
    <link href="http://yoursite.com/2017/10/17/Lock%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%8F%8A%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2017/10/17/Lock接口的介绍及使用/</id>
    <published>2017-10-17T13:40:19.000Z</published>
    <updated>2017-10-18T11:30:07.979Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、Lock的介绍"><a href="#一、Lock的介绍" class="headerlink" title="一、Lock的介绍"></a>一、Lock的介绍</h3><p>我们知道，在Java中锁的实现可以由synchronized关键字来完成，但在Java5之后，出现了一种新的方式来实现——Lock接口。</p>
<p>那么为什么提出这种新的方式呢？<br>在多线程的情况下，当一段代码被synchronized修饰之后，同一时刻只能被一个线程访问，其他线程都必须等到该线程释放锁之后才能有机会获取锁访问这段代码，占用锁的线程只有在两种情况下才能释放锁：  </p>
<ol>
<li>线程执行完了这段代码，释放锁；</li>
<li>线程执行发生异常，释放锁；  </li>
</ol>
<p>考虑一下，如果该线程由于IO操作或者其他原因（调用Sleep方法）被阻塞了，那么其他线程就会一直无期限地等待下去，后果可想而知。<br>那么能否用一种方式来防止等待的线程无限等待呢？（等待一段时间或者响应中断）通过Lock就可以实现。</p>
<p>再如：当用多线程对文件进行读写时，读与写是互斥的，写与写是互斥的，但读与读却不是互斥的。如果用synchronized来实现同步，就会有这样的问题：多个线程都只需要读操作，但只能有一个线程进行读操作，其他线程只能等待。<br>那么能不能让线程不用等待，多线程都能进行读操作呢？通过Lock就可以实现。</p>
<h3 id="二、Lock的用法"><a href="#二、Lock的用法" class="headerlink" title="二、Lock的用法"></a>二、Lock的用法</h3><p>Lock是一个接口，包含以下方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public interface Lock &#123;</div><div class="line">void lock();      //获取锁</div><div class="line">void lockInterruptibly() throws InterruptedException; //可中断的获取锁</div><div class="line">boolean tryLock(); //尝试非阻塞的获取锁</div><div class="line">boolean tryLock(long time, TimeUnit unit) throws InterruptedException; //超时获取锁</div><div class="line">void unlock(); //释放锁</div><div class="line">Condition newCondition(); //获取等待通知组件，和当前的锁绑定</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到当使用Lock时，获取锁和释放锁都是主动调用执行的，而synchronized则是系统自动释放锁的。<br>前四个方法都是用来获取锁的，但各有区别：  </p>
<ul>
<li><strong>lock()</strong>：是最常用的获取锁的方法，若锁被其他线程获取，则等待（阻塞）。</li>
<li><strong>tryLock()</strong>：尝试非阻塞地获取锁，立即返回。获取成功返回true；获取失败返回false，但不会阻塞。</li>
<li><strong>tryLock(long time, TimeUnit unit)</strong>：与tryLock()相似，但是会超时等待一段时间，如果未获取到返回false。</li>
<li><strong>lockInterruptibly()</strong>：可中断地获取锁，该方法会响应中断，在锁的获取过程中可以中断当前线程。  </li>
</ul>
<p><strong>注：当使用synchronized关键字时，一个线程在等待获取锁的过程中是无法中断的。而使用lockInterruptibly()方法获取某个锁时，如果不能获取到，在进行等待的情况下是可以响应中断的。</strong></p>
<p>Lock的使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Lock lock = new ReentrantLock(); //可重入锁（Lock的一种实现）</div><div class="line">lock.lock();</div><div class="line">try&#123;</div><div class="line">    dosomething();</div><div class="line">&#125;finally&#123;</div><div class="line">    lock.unlock();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>在finally块中释放锁的目的是保证获取锁之后，最终能被释放。</strong><br>不要将获取锁——lock()放在try中，如果在获取锁时发生了异常，异常抛出的同时，也会导致锁的无故释放（需要主动释放）。</p>
<h3 id="三、与synchronized的区别"><a href="#三、与synchronized的区别" class="headerlink" title="三、与synchronized的区别"></a>三、与synchronized的区别</h3><p>Lock与synchronized的区别：  </p>
<ol>
<li>Lock是一个接口，是代码层面的实现；synchronized是关键字，是内置的语言实现（JVM层面）。</li>
<li>Lock是显示地获取释放锁，扩展性更强；synchronized是隐式地获取释放锁，更简捷。</li>
<li>Lock在发生异常时，如果没有主动通过unlock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生。</li>
<li>Lock可以让等待锁的线程响应中断；而使用synchronized时等待锁的线程会一直等待下去，不能响应中断；</li>
<li>Lock可以尝试非阻塞、可中断、超时地获取锁；synchronized不可以。</li>
<li>Lock可以知道是否成功获取锁；synchronized无法知道。  </li>
</ol>
<p>总结：在资源竞争不是很激烈的情况下，Synchronized的性能要优于Lock；但是在资源竞争很激烈的情况下，Synchronized的性能会下降几十倍，Lock的性能更优；</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、Lock的介绍&quot;&gt;&lt;a href=&quot;#一、Lock的介绍&quot; class=&quot;headerlink&quot; title=&quot;一、Lock的介绍&quot;&gt;&lt;/a&gt;一、Lock的介绍&lt;/h3&gt;&lt;p&gt;我们知道，在Java中锁的实现可以由synchronized关键字来完成，但在Jav
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="Lock" scheme="http://yoursite.com/tags/Lock/"/>
    
  </entry>
  
  <entry>
    <title>深入理解synchronized关键字</title>
    <link href="http://yoursite.com/2017/10/14/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3synchronized/"/>
    <id>http://yoursite.com/2017/10/14/深入理解synchronized/</id>
    <published>2017-10-14T09:30:15.000Z</published>
    <updated>2017-10-14T09:54:51.785Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、synchronized的基本介绍"><a href="#一、synchronized的基本介绍" class="headerlink" title="一、synchronized的基本介绍"></a>一、synchronized的基本介绍</h2><p>谈到synchronized关键字，想必大家都不陌生，对它的初次印象如果用两个字来概括，无非就是 <strong>“同步”</strong> 。小小的一个词，蕴含了大道理，那么就让我们来探索一下。  </p>
<h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><p><strong>synchronized实现同步的基础是：java中的任何一个对象都可以作为锁。</strong>  </p>
<p>它有三种用法：  </p>
<p> <strong>1. 修饰普通同步方法，锁是当前实例对象</strong>  </p>
<p><strong>2. 修饰静态同步方法，锁是当前类的class对象（唯一）</strong></p>
<p><strong>3. 修饰同步代码块，锁是括号中的对象</strong>  </p>
<h3 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h3><p>来看以下几段代码<br>（1）不使用synchronized<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">public class SynTest &#123;</div><div class="line">	</div><div class="line">	public void method1()&#123;</div><div class="line">		System.out.println(&quot;method 1 start&quot;);</div><div class="line">		try &#123;</div><div class="line">			System.out.println(&quot;method 1 execute&quot;);</div><div class="line">			Thread.sleep(2000);</div><div class="line">		&#125; catch (InterruptedException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		System.out.println(&quot;method 1 end&quot;);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public void method2()&#123;</div><div class="line">		System.out.println(&quot;method 2 start&quot;);</div><div class="line">		try &#123;</div><div class="line">			System.out.println(&quot;method 2 execute&quot;);</div><div class="line">			Thread.sleep(1000);</div><div class="line">		&#125; catch (InterruptedException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		System.out.println(&quot;method 2 end&quot;);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		SynTest test = new SynTest();</div><div class="line">		//线程1---method1</div><div class="line">		new Thread(new Runnable() &#123;</div><div class="line">			@Override</div><div class="line">			public void run() &#123;</div><div class="line">				test.method1();</div><div class="line">			&#125;</div><div class="line">		&#125;).start();</div><div class="line">		//线程2---method2</div><div class="line">		new Thread(new Runnable() &#123;</div><div class="line">			@Override</div><div class="line">			public void run() &#123;</div><div class="line">				test.method2();</div><div class="line">			&#125;</div><div class="line">		&#125;).start();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">method 1 start</div><div class="line">method 2 start</div><div class="line">method 2 execute</div><div class="line">method 1 execute</div><div class="line">method 2 end</div><div class="line">method 1 end</div></pre></td></tr></table></figure>
<p>可以看出，在不加synchronized修饰时，两个线程同时执行，互不冲突，线程2比线程1执行的快，因此先执行完毕。<br>（2）synchronized修饰普通方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">public class SynTest &#123;</div><div class="line">	</div><div class="line">	public synchronized void  method1()&#123;</div><div class="line">		System.out.println(&quot;method 1 start&quot;);</div><div class="line">		</div><div class="line">		try &#123;</div><div class="line">			System.out.println(&quot;method 1 execute&quot;);</div><div class="line">			Thread.sleep(2000);</div><div class="line">		&#125; catch (InterruptedException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		System.out.println(&quot;method 1 end&quot;);</div><div class="line">	&#125;</div><div class="line">	public synchronized void method2()&#123;</div><div class="line">		System.out.println(&quot;method 2 start&quot;);</div><div class="line">		</div><div class="line">		try &#123;</div><div class="line">			System.out.println(&quot;method 2 execute&quot;);</div><div class="line">			Thread.sleep(1000);</div><div class="line">		&#125; catch (InterruptedException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		System.out.println(&quot;method 2 end&quot;);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		SynTest test = new SynTest();</div><div class="line">		//线程1---method1</div><div class="line">		new Thread(new Runnable() &#123;</div><div class="line">			@Override</div><div class="line">			public void run() &#123;</div><div class="line">				test.method1();</div><div class="line">			&#125;</div><div class="line">		&#125;).start();</div><div class="line">		//线程2---method2</div><div class="line">		new Thread(new Runnable() &#123;</div><div class="line">			@Override</div><div class="line">			public void run() &#123;</div><div class="line">				test.method2();</div><div class="line">			&#125;</div><div class="line">		&#125;).start();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">method 1 start</div><div class="line">method 1 execute</div><div class="line">method 1 end</div><div class="line">method 2 start</div><div class="line">method 2 execute</div><div class="line">method 2 end</div></pre></td></tr></table></figure>
<p>可以看出，线程2在线程1执行完成后才开始执行，达到了同步的效果。<strong>这是因为两个线程需要获取同一把锁（即test对象）</strong>，线程1先拿到锁，线程2只能等待直到线程1释放锁，才能执行。<br>（3）synchronized修饰静态方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">public class SynTest &#123;</div><div class="line">	</div><div class="line">	public static synchronized void  method1()&#123;</div><div class="line">		System.out.println(&quot;method 1 start&quot;);</div><div class="line">		</div><div class="line">		try &#123;</div><div class="line">			System.out.println(&quot;method 1 execute&quot;);</div><div class="line">			Thread.sleep(2000);</div><div class="line">		&#125; catch (InterruptedException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		System.out.println(&quot;method 1 end&quot;);</div><div class="line">	&#125;</div><div class="line">	public static synchronized void method2()&#123;</div><div class="line">		System.out.println(&quot;method 2 start&quot;);</div><div class="line">		</div><div class="line">		try &#123;</div><div class="line">			System.out.println(&quot;method 2 execute&quot;);</div><div class="line">			Thread.sleep(1000);</div><div class="line">		&#125; catch (InterruptedException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		System.out.println(&quot;method 2 end&quot;);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		SynTest test = new SynTest();</div><div class="line">		SynTest test2 = new SynTest();</div><div class="line">		//线程1---method1</div><div class="line">		new Thread(new Runnable() &#123;</div><div class="line">			@Override</div><div class="line">			public void run() &#123;</div><div class="line">				test.method1();</div><div class="line">			&#125;</div><div class="line">		&#125;).start();</div><div class="line">		//线程2---method2</div><div class="line">		new Thread(new Runnable() &#123;</div><div class="line">			@Override</div><div class="line">			public void run() &#123;</div><div class="line">				test2.method2();</div><div class="line">			&#125;</div><div class="line">		&#125;).start();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">method 1 start</div><div class="line">method 1 execute</div><div class="line">method 1 end</div><div class="line">method 2 start</div><div class="line">method 2 execute</div><div class="line">method 2 end</div></pre></td></tr></table></figure>
<p>可以看出，两个线程同样获得了同步的效果。但是明明是两个不同的对象（test、test2）所调用的，这是为什么？<br><strong>在这里synchronized修饰的是静态方法，而静态方法本质上是类的方法，因此这里的同步本质上是对类（Class对象）的同步</strong>，test、test2都是属于类的实例对象，所以也会同步执行，不能并发执行。<br><strong>注：每个类只有一个Class对象。</strong><br>（4）synchronized修饰同步块</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">public class SynTest &#123;</div><div class="line">	</div><div class="line">	public  void  method1()&#123;</div><div class="line">		synchronized(this)&#123;</div><div class="line">		System.out.println(&quot;method 1 start&quot;);</div><div class="line">		try &#123;</div><div class="line">			System.out.println(&quot;method 1 execute&quot;);</div><div class="line">			Thread.sleep(2000);</div><div class="line">		&#125; catch (InterruptedException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		System.out.println(&quot;method 1 end&quot;);&#125;</div><div class="line">	&#125;</div><div class="line">	public void method2()&#123;</div><div class="line">		synchronized(this)&#123;</div><div class="line">		System.out.println(&quot;method 2 start&quot;);</div><div class="line">		</div><div class="line">		try &#123;</div><div class="line">			System.out.println(&quot;method 2 execute&quot;);</div><div class="line">			Thread.sleep(1000);</div><div class="line">		&#125; catch (InterruptedException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		System.out.println(&quot;method 2 end&quot;);&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		SynTest test = new SynTest();</div><div class="line">		//线程1---method1</div><div class="line">		new Thread(new Runnable() &#123;</div><div class="line">			@Override</div><div class="line">			public void run() &#123;</div><div class="line">				test.method1();</div><div class="line">			&#125;</div><div class="line">		&#125;).start();</div><div class="line">		//线程2---method2</div><div class="line">		new Thread(new Runnable() &#123;</div><div class="line">			@Override</div><div class="line">			public void run() &#123;</div><div class="line">				test.method2();</div><div class="line">			&#125;</div><div class="line">		&#125;).start();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">method 1 start</div><div class="line">method 1 execute</div><div class="line">method 1 end</div><div class="line">method 2 start</div><div class="line">method 2 execute</div><div class="line">method 2 end</div></pre></td></tr></table></figure>
<p>可以看到，两个线程获得了同步的效果。<strong>两个线程的锁都是synchronized同步块括号中的this对象，即当前对象（test）</strong>。</p>
<h2 id="二、synchronized的实现原理"><a href="#二、synchronized的实现原理" class="headerlink" title="二、synchronized的实现原理"></a>二、synchronized的实现原理</h2><h3 id="2-1-实现原理"><a href="#2-1-实现原理" class="headerlink" title="2.1 实现原理"></a>2.1 实现原理</h3><p><strong>JVM基于进入和退出Monitor对象来实现方法同步和代码块同步。</strong> 但两者的实现细节不一样。</p>
<h4 id="1-代码块同步"><a href="#1-代码块同步" class="headerlink" title="1. 代码块同步"></a>1. 代码块同步</h4><p><strong>代码块同步是使用monitorenter和monitorexit指令（字节码指令）来完成。</strong><br>monitorenter指令是在编译后插入到同步代码块的开始位置，monitorexit指令插入到方法结束处和异常处，JVM保证每一个monitorenter都有一个monitorexit与之相对应。任何对象都有一个monitor与之相关联，当且一个monitor被持有之后，它将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor所有权，即尝试获取对象的锁； </p>
<h4 id="2-方法同步"><a href="#2-方法同步" class="headerlink" title="2. 方法同步"></a>2. 方法同步</h4><p><strong>方法同步是根据方法上的ACC_SYNCHRONIZED标识符（不是字节码指令）来实现的。</strong> 它没有通过指令monitorenter和monitorexit来完成（也可以通过它完成）。<br>反编译可以发现，相比普通方法，常量池中多了ACC_SYNCHRONIZED标示符。JVM就是根据该标示符来实现方法的同步的：当方法调用时，调用指令将会检查方法的ACC_SYNCHRONIZED访问标志是否被设置，如果设置了，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完后再释放monitor。在方法执行期间，其他任何线程都无法再获得同一个monitor对象。</p>
<p><strong>总结：</strong> 二者其实本质上没有区别，只是方法的同步是一种隐式的方式来实现，无需通过字节码指令来完成。</p>
<h3 id="2-2-对象头"><a href="#2-2-对象头" class="headerlink" title="2.2 对象头"></a>2.2 对象头</h3><p>synchronized用的锁是存在java对象头里的。<br>要了解对象头，先看看对象在内存中（<strong>java堆</strong>）的分布。分为三部分：对象头，实例数据，和对齐填充。（如下图）<br><img src="http://osuskkx7k.bkt.clouddn.com/%E5%AF%B9%E8%B1%A1%E5%A4%B421.PNG?imageView2/2/w/500/h/600" alt="image"></p>
<p>从图上可以看到，对象头由2个字存储（若是数组对象则为3个字，多一个存储数组长度）。<br>对象头主要包括以下两部分数据（还有一个Fields）：<br><img src="http://osuskkx7k.bkt.clouddn.com/%E5%AF%B9%E8%B1%A1%E5%A4%B422.PNG?imageView2/2/w/400/h/500" alt="image"><br><strong>Mark Word（标记字段）：</strong> 用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等等。<br><strong>Klass Pointer（类型指针）：</strong> 指向对象的类元数据，虚拟机通过这个指针来确定这个对象是哪个类的实例。<br>当对象头处于无锁状态时，它的Mark Word存储结构如下：</p>
<table>
<thead>
<tr>
<th>锁状态</th>
<th>25bit</th>
<th>4bit</th>
<th>1bit是否是偏向锁</th>
<th>2bit锁标志位</th>
</tr>
</thead>
<tbody>
<tr>
<td>&#160;无锁状态</td>
<td>对象的hashCode</td>
<td>对象分代年龄</td>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160;0</td>
<td>&#160;&#160;&#160;01</td>
</tr>
</tbody>
</table>
<p><strong>注：在运行期间，Mark Word里的存储数据会随着锁标志位的变化而变化。</strong></p>
<h2 id="三、锁的优化和对比"><a href="#三、锁的优化和对比" class="headerlink" title="三、锁的优化和对比"></a>三、锁的优化和对比</h2><p>jdk1.6之后对synchronized的实现进行了优化，来减少锁操作的开销。<br>因此锁出现了以下四种状态 <strong>：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态。</strong><br>它们并不是一成不变的状态，而是会通过互相竞争而升级，但是为了提高获得锁和释放锁的效率，它们只能升级不能降级。  升级顺序如下：<br>无锁 –&gt; 偏向锁 –&gt; 轻量级 –&gt; 重量级</p>
<h3 id="3-1-偏向锁"><a href="#3-1-偏向锁" class="headerlink" title="3.1 偏向锁"></a>3.1 偏向锁</h3><p>背景：大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让获取锁的代价降低而引入了偏向锁。<strong>偏向锁主要为了解决在没有竞争情况下锁的性能问题。</strong></p>
<h4 id="1-偏向锁的加锁"><a href="#1-偏向锁的加锁" class="headerlink" title="1. 偏向锁的加锁"></a>1. 偏向锁的加锁</h4><p>主要步骤如下：<br>（1）检测对象头Mark Word中的状态是否为偏向锁状态：<br>若是偏向锁状态（偏向锁标志为1，锁标志位01）执行步骤（2）；<br>若是无锁状态（偏向锁标志关闭，锁标志位01），那么线程在执行同步块之前，JVM会现在当前线程的栈帧中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，并存储锁偏向的线程ID（当前线程）；<br>（2）是偏向锁状态，则测试线程ID是否为当前线程ID，如果是则执行步骤（5），否则执行步骤（3）；<br>（3）线程ID不为当前线程ID，则通过CAS操作竞争锁，竞争成功，则将Mark Word的线程ID替换为当前线程ID，否则执行步骤（4）；<br>（4）通过CAS操作竞争锁失败，证明当前存在多线程竞争的情况，当到达全局安全点，获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码块；<br>（5）执行同步代码块</p>
<h4 id="2-偏向锁的解锁"><a href="#2-偏向锁的解锁" class="headerlink" title="2. 偏向锁的解锁"></a>2. 偏向锁的解锁</h4><p>偏向锁的释放采用了一种只有竞争才会释放锁的机制，线程是不会主动去释放偏向锁，需要等待其他线程来竞争。偏向锁的撤销需要等待全局安全点，此时没有正在执行的字节码。步骤如下：<br>（1）首先暂停持有偏向锁的线程，然后检查该线程是否活着：<br>没有活着：将对象头设置成无锁状态；<br>（2）活着：要么重新偏向于其他线程；要么恢复到无锁或升级为轻量锁；<br>（3）最后唤醒暂停的线程</p>
<h4 id="3-偏向锁的关闭"><a href="#3-偏向锁的关闭" class="headerlink" title="3. 偏向锁的关闭"></a>3. 偏向锁的关闭</h4><p>偏向锁默认开启，JVM参数关闭延迟：-XX：BiasedLockingStartupDelay=0。<br>如果确定应用程序里所有的锁通常都处于竞争状态下，通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，那么程序会默认进入轻量级锁状态。</p>
<h3 id="3-2-轻量级锁"><a href="#3-2-轻量级锁" class="headerlink" title="3.2 轻量级锁"></a>3.2 轻量级锁</h3><p>背景：<strong>“对于绝大部分的锁，在整个同步周期内都是不存在竞争的”</strong>，这是一个经验数据，也是轻量级锁能提升程序同步性能的依据。<strong>轻量级锁所适应的场景是线程交替执行同步块的情况。</strong></p>
<h4 id="1-轻量级锁的加锁"><a href="#1-轻量级锁的加锁" class="headerlink" title="1. 轻量级锁的加锁"></a>1. 轻量级锁的加锁</h4><p>当关闭偏向锁功能或偏向锁升级为轻量级锁时，会尝试去获取轻量级锁。主要步骤如下：<br>（1）检测对象头Mark Word中的状态是否为无锁状态：若是无锁状态（偏向锁标志关闭，锁标志位01）执行步骤（2）；否则步骤（4）<br>（2）若是无锁状态，将对象头中的Mark Word复制到锁记录中（在执行同步块之前，JVM会先在当前线程的栈帧中创建用于存储锁记录的空间）；<br>（3）通过CAS将Mark Word替换为指向锁记录的指针：如果成功表示竞争到锁，执行同步代码；如果失败执行步骤（4）；<br>（4）判断当前对象的Mark Word是否指向当前线程的栈帧，如果是则表示当前线程已经持有当前对象的锁，则直接执行同步代码块；否则只能说明该锁对象已经被其他线程抢占了，这时轻量级锁需要膨胀为重量级锁，锁标志位变成10，后面等待的线程将会进入阻塞状态；</p>
<h4 id="2-轻量级锁的解锁"><a href="#2-轻量级锁的解锁" class="headerlink" title="2. 轻量级锁的解锁"></a>2. 轻量级锁的解锁</h4><p>轻量级锁的释放也是通过CAS操作来进行的，主要步骤如下： </p>
<p>（1）取出获取轻量级锁时保存在Displaced Mark Word中的数据；<br>（2）用CAS操作将取出的数据替换当前对象的Mark<br>Word中，如果成功，则说明释放锁成功，否则执行（3）；<br>（3） 如果CAS操作替换失败，说明有其他线程尝试获取该锁，存在锁竞争，锁会膨胀成重量级锁。</p>
<h3 id="3-3-重量级锁"><a href="#3-3-重量级锁" class="headerlink" title="3.3 重量级锁"></a>3.3 重量级锁</h3><p><strong>重量级锁通过对象内部的监视器（monitor）实现，其中monitor的本质是依赖于底层操作系统的Mutex Lock实现</strong>，由于使用Mutex Lock需要将当前线程挂起并从用户态切换到内核态来执行，这种切换的代价非常昂贵。</p>
<h3 id="3-4-锁的对比"><a href="#3-4-锁的对比" class="headerlink" title="3.4 锁的对比"></a>3.4 锁的对比</h3><table>
<thead>
<tr>
<th>锁</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>偏向锁</td>
<td>加锁和解锁不需要额外的消耗,和执行非同步方法相比仅存在纳米级的差距</td>
<td>如果线程间存在锁竞争，有额外的锁撤销的消耗</td>
<td>适用于只有一个线程访问同步块的场景</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>竞争的线程不会阻塞，提高了程序的响应速度</td>
<td>如果始终得不到锁竞争的线程，使用自旋会消耗CPU</td>
<td>追求响应时间，同步块执行速度非常快</td>
</tr>
<tr>
<td>重量级锁</td>
<td>线程竞争不使用自旋，不会消耗CPU</td>
<td>线程阻塞，响应时间缓慢</td>
<td>追求吞吐量，同步块执行速度较长</td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、synchronized的基本介绍&quot;&gt;&lt;a href=&quot;#一、synchronized的基本介绍&quot; class=&quot;headerlink&quot; title=&quot;一、synchronized的基本介绍&quot;&gt;&lt;/a&gt;一、synchronized的基本介绍&lt;/h2&gt;&lt;p&gt;谈到
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="synchronized" scheme="http://yoursite.com/tags/synchronized/"/>
    
  </entry>
  
  <entry>
    <title>深入理解volatile关键字</title>
    <link href="http://yoursite.com/2017/10/12/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3volatile%E5%85%B3%E9%94%AE%E5%AD%97(1)/"/>
    <id>http://yoursite.com/2017/10/12/深入理解volatile关键字(1)/</id>
    <published>2017-10-12T07:12:12.000Z</published>
    <updated>2017-10-12T07:40:18.054Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、volatile的特性"><a href="#一、volatile的特性" class="headerlink" title="一、volatile的特性"></a>一、volatile的特性</h2><h3 id="1-volatile的可见性"><a href="#1-volatile的可见性" class="headerlink" title="1. volatile的可见性"></a>1. volatile的可见性</h3><p> 可见性的意思是：当一个线程修改一个共享变量时，另一个线程能读到这个修改的值。<br> volatile在多线程的开发中，保证了共享变量的可见性（立即）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//全局变量</div><div class="line">boolean open=true;</div><div class="line"></div><div class="line">//线程A</div><div class="line">resource.close();</div><div class="line">open = false;</div><div class="line"></div><div class="line">//线程B</div><div class="line">while(open) &#123;</div><div class="line">doSomething(resource);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>open是一个全局变量，用来描述一个资源的打开关闭状态，当线程A把资源关闭后，open置为false，而这个改动对线程B<strong>不是立即可见</strong>的，因此线程B还会运行，从而造成错误。<br>当添加volatile关键字修饰之后，线程B就可以<strong>立即</strong>将改动后的open变量（主内存）同步到自己的工作内存中，从而正确的停止运行。</p>
<h3 id="2-volatile的有序性（禁止指令重排序）"><a href="#2-volatile的有序性（禁止指令重排序）" class="headerlink" title="2. volatile的有序性（禁止指令重排序）"></a>2. volatile的有序性（禁止指令重排序）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//线程A</div><div class="line">context = loadContext();//初始化</div><div class="line">init = true;</div><div class="line">//线程B</div><div class="line">while(!init)&#123; //根据init变量决定是否使用context（为false时等待，为true时顺序执行）</div><div class="line">   sleep(100);</div><div class="line">&#125;</div><div class="line">doSomething(context);</div></pre></td></tr></table></figure>
<p>以上程序运行没有问题，然而当线程A中发生了指令重排序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">init = true;</div><div class="line">context = loadContext();</div></pre></td></tr></table></figure></p>
<p>那么B就可能跳过等待，拿到一个正在初始化或初始化未完成的context对象，从而发生程序错误。<br>当init变量用volatile修饰后，就会阻止JVM对其相关代码进行指令重排，这样就能够按照既定的顺序执行。<br> 在双重判断类型的单例模式中正是应用了volatile关键字的这个特性，才不会导致单例模式失效。</p>
<h3 id="3-volatile不保证操作的原子性"><a href="#3-volatile不保证操作的原子性" class="headerlink" title="3. volatile不保证操作的原子性"></a>3. volatile不保证操作的原子性</h3><p>原子操作：不可中断的一个或一系列操作（多线程中借助于原子操作可以实现互斥锁）<br>原子性：一个操作或多个操作要么全部成功执行，要么就都失败。一个操作是原子操作，那么我们称它具有原子性。<br>先看示例代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public class TestAtomic &#123;</div><div class="line">//计数器</div><div class="line">private static volatile int count=0;</div><div class="line">	</div><div class="line">	public void inc()&#123;</div><div class="line">		count++;</div><div class="line">	&#125;</div><div class="line">	private static class Countone implements  Runnable &#123;</div><div class="line">		public void run() &#123;</div><div class="line">			for(int i=0;i&lt;100;i++)&#123;</div><div class="line">				count++;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		</div><div class="line">		for(int i=0;i&lt;10;i++)&#123;</div><div class="line">			new Thread(new Countone()).start();</div><div class="line">		&#125;</div><div class="line">		//保证10个线程都执行完毕</div><div class="line">		while(Thread.activeCount()&gt;1)</div><div class="line">			Thread.yield();</div><div class="line">		</div><div class="line">		System.out.println(&quot;最终count的值为：&quot;+TestAtomic.count);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">输出结果：</div><div class="line">最终count的值为：863</div><div class="line">最终count的值为：1000</div><div class="line">最终count的值为：872</div><div class="line">最终count的值为：835</div></pre></td></tr></table></figure>
<p>将count变量声明为volatile int类型，保证了所有线程对变量count的可见性，上述定义了10个线程，每个线程对count执行100次自增的操作，按照理想的结果，最后的结果应该为10<em>100=1000，然而多次运行可以看到，并不是每次的结果都是1000，难道volatile修饰的变量的可见性特征失效了？<em>*并不是，而是volatile只能保证共享变量对所有线程的可见性，不能保证变量操作的原子性。</em></em> count++不是一个原子操作，因此volatile不能保证这个操作的原子性。</p>
<p><strong>有以下三种方式可以保证对变量操作的原子性：</strong></p>
<ol>
<li>使用synchronized关键字</li>
<li>使用Lock对象</li>
<li>使用java.util.concurrent.atomic包下提供的原子操作类</li>
</ol>
<h2 id="二、volatile的实现原理"><a href="#二、volatile的实现原理" class="headerlink" title="二、volatile的实现原理"></a>二、volatile的实现原理</h2><h3 id="1-可见性"><a href="#1-可见性" class="headerlink" title="1.可见性"></a>1.可见性</h3><p>它的实现原理与java内存模型（JMM）相关，每个线程都有自己的工作内存，并共享主内存的数据。下面是普通变量与volatile变量的异同：</p>
<ul>
<li><p>普通变量：读操作会优先读取工作内存的数据，如果工作内存中不存在，则从主内存中拷贝一份数据到工作内存中；写操作只会修改工作内存的副本数据。这种情况下，其它线程就无法读取变量的最新值。</p>
</li>
<li><p>volatile变量：读操作时会把工作内存中对应的值设为无效，要求线程从主内存中读取数据；写操作时会把工作内存中对应的数据刷新到主内存中。这种情况下，其它线程就可以读取变量的最新值。</p>
</li>
</ul>
<p>那么它是如何是实现的呢？这就涉及到了CPU指令。<br>如果对声明了volatile变量进行写操作，<strong>JVM就会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写回到系统内存。</strong> 但是就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题，所以在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作的时候，会强制重新从系统内存里把数据读到处理器缓存里。</p>
<h3 id="2-禁止重排序"><a href="#2-禁止重排序" class="headerlink" title="2.禁止重排序"></a>2.禁止重排序</h3><p>在执行程序时为了提高性能，编译器和处理器通常会对指令做重排序： </p>
<ul>
<li>编译器重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序； </li>
<li>处理器重排序。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序；<br>指令重排序对单线程没有影响，但是会影响多线程的正确性，因此需要对禁止指令重排序。</li>
</ul>
<p>在上面提到过lock指令，<strong>lock指令其实就相当于一个内存屏障。内存屏障是一组处理指令，用来实现对内存操作的顺序限制。</strong> volatile的底层就是通过内存屏障来实现的。</p>
<h2 id="三、volatile与synchronized的比较"><a href="#三、volatile与synchronized的比较" class="headerlink" title="三、volatile与synchronized的比较"></a>三、volatile与synchronized的比较</h2><ol>
<li><p>volatile本质是在告诉JVM当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞。 </p>
</li>
<li><p>volatile只能修饰变量，synchronized可以修饰变量、方法和类；  </p>
</li>
<li><p>volatile保证变量的修改可见性，synchronized则可以保证变量的修改可见性和原子性。  </p>
</li>
<li>volatile不会造成线程的阻塞，synchronized可能会造成线程的阻塞。  </li>
<li>volatile比synchronized的使用和执行成本更低，因为它不会引起上下文的切换和调度。</li>
</ol>
<h2 id="四、volatile的扩展"><a href="#四、volatile的扩展" class="headerlink" title="四、volatile的扩展"></a>四、volatile的扩展</h2><h3 id="1-volatile的常用场景"><a href="#1-volatile的常用场景" class="headerlink" title="1.volatile的常用场景"></a>1.volatile的常用场景</h3><ul>
<li><p>状态标记量（高并发的场景）</p>
</li>
<li><p>双重判断的单例模式</p>
</li>
</ul>
<h3 id="2-volatile修饰数组"><a href="#2-volatile修饰数组" class="headerlink" title="2.volatile修饰数组"></a>2.volatile修饰数组</h3><p><strong>问题：volatile能否保证数组中元素的可见性？</strong> 如果用volatile修饰一个数组，那么当一个线程对数组中的元素进行设值时，对另一个线程是否<strong>立即</strong>可见？ </p>
<p><strong>答案：</strong> 不能立即可见。因为volatile修饰的数组只针对数组的引用具有volatile的语义，而不是它的元素。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、volatile的特性&quot;&gt;&lt;a href=&quot;#一、volatile的特性&quot; class=&quot;headerlink&quot; title=&quot;一、volatile的特性&quot;&gt;&lt;/a&gt;一、volatile的特性&lt;/h2&gt;&lt;h3 id=&quot;1-volatile的可见性&quot;&gt;&lt;a hr
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="volatile" scheme="http://yoursite.com/tags/volatile/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2017/10/10/hello-world/"/>
    <id>http://yoursite.com/2017/10/10/hello-world/</id>
    <published>2017-10-09T16:08:31.273Z</published>
    <updated>2017-10-09T16:08:31.273Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Mysql中查询某个数据库中所有表的字段信息</title>
    <link href="http://yoursite.com/2017/08/09/Mysql%E4%B8%AD%E6%9F%A5%E8%AF%A2%E6%9F%90%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E6%89%80%E6%9C%89%E8%A1%A8%E7%9A%84%E5%AD%97%E6%AE%B5%E4%BF%A1%E6%81%AF/"/>
    <id>http://yoursite.com/2017/08/09/Mysql中查询某个数据库中所有表的字段信息/</id>
    <published>2017-08-09T09:55:55.000Z</published>
    <updated>2017-10-09T16:08:31.273Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>有时候，需要在数据库中查询一些字段的具体信息，而这些字段又存在于不同的表中，那么我们如何来查询呢？</p>
<p>在每一个数据库链接的information_schema数据库中，存在这样一张表——COLUMNS，它记录了这个数据库中所有表的字段信息。</p>
<h2 id="查询某个特定类型的字段信息"><a href="#查询某个特定类型的字段信息" class="headerlink" title="查询某个特定类型的字段信息"></a>查询某个特定类型的字段信息</h2><p>如下：查询字段类型为decimal的字段信息<br>Sql语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">SELECT</div><div class="line">	TABLE_NAME,</div><div class="line">	column_name,</div><div class="line">	DATA_TYPE,</div><div class="line">	column_comment</div><div class="line">FROM</div><div class="line">	information_schema. COLUMNS</div><div class="line">WHERE</div><div class="line">	TABLE_SCHEMA = &apos;evshare&apos;</div><div class="line">AND DATA_TYPE = &apos;decimal&apos;;</div></pre></td></tr></table></figure>
<p>其中</p>
<ul>
<li>TABLE_SCHEMA 为数据库的名称（所属的数据库）</li>
<li>TABLE_NAME 为表的名称</li>
<li>DATA_TYPE 为字段的数据类型</li>
<li>column_name  为字段名</li>
<li>column_comment 为字段注释<br>在Where的条件语句中，可以加入限制条件。<br>结果如下：</li>
</ul>
<p><img src="http://osuskkx7k.bkt.clouddn.com/clipboard1.png" alt="1"> </p>
<h2 id="查询注释乱码的字段信息"><a href="#查询注释乱码的字段信息" class="headerlink" title="查询注释乱码的字段信息"></a>查询注释乱码的字段信息</h2><p>如果需要查询数据库中所有乱码的字段信息，那么可以对以上的Sql稍稍改进：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">SELECT</div><div class="line">	TABLE_NAME,</div><div class="line">	column_name,</div><div class="line">	DATA_TYPE,</div><div class="line">	column_comment</div><div class="line">FROM</div><div class="line">	information_schema. COLUMNS</div><div class="line">WHERE</div><div class="line">	TABLE_SCHEMA = &apos;evshare&apos;</div><div class="line">AND column_comment LIKE &apos;%?%&apos;;</div></pre></td></tr></table></figure>
<p>结果如下：可以看到这个evshare数据库中，所有表的乱码字段都已显示</p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/clipboard3.png" alt="1"> </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><font size="4">以上，就是在Mysql中如何查询某个数据库中所有表的字段信息的过程。</font></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;有时候，需要在数据库中查询一些字段的具体信息，而这些字段又存在于不同的表中，那么我们如何来查询呢？&lt;/p&gt;
&lt;p&gt;在每一个数据库链接的inf
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Mysql" scheme="http://yoursite.com/tags/Mysql/"/>
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
</feed>
