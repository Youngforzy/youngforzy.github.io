<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZY&#39;s Blog</title>
  <subtitle>Young for you.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-02-24T07:44:19.001Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Z Yong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ReentrantReadWriteLock可重入读写锁</title>
    <link href="http://yoursite.com/2017/10/28/ReentrantReadWriteLock%E5%8F%AF%E9%87%8D%E5%85%A5%E8%AF%BB%E5%86%99%E9%94%81/"/>
    <id>http://yoursite.com/2017/10/28/ReentrantReadWriteLock可重入读写锁/</id>
    <published>2017-10-28T09:48:18.000Z</published>
    <updated>2018-02-24T07:44:19.001Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、ReentrantReadWriteLock的概念"><a href="#一、ReentrantReadWriteLock的概念" class="headerlink" title="一、ReentrantReadWriteLock的概念"></a>一、ReentrantReadWriteLock的概念</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>前面提到的锁（独占锁、ReentrantLock）等都是排他锁，这些锁在同一时刻只允许一个线程访问。<br>而<strong>读写锁在同一时刻可以允许多个读线程访问，但在写线程访问时，所有读线程和其他写线程都阻塞。</strong></p>
<p>ReadWriteLock并不是继承自Lock接口，而是一个单独的接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public interface ReadWriteLock &#123;</div><div class="line">    Lock readLock();</div><div class="line">    Lock writeLock();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ReentrantReadWriteLock则是这个接口的实现。通过readLock()和writeLock()方法可分别获得一个ReadLock实例和一个WriteLock实例，这两个实例实现了Lock接口。<br>因此，我们可以调用Lock接口的相关方法来完成锁的语义。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ReentrantReadWriteLock rw = new ReentrantReadWriteLock();</div><div class="line">Lock r = rw.readLock();</div><div class="line">Lock w = rw.writeLock();</div><div class="line">...</div></pre></td></tr></table></figure>
<h4 id="特性："><a href="#特性：" class="headerlink" title="特性："></a>特性：</h4><ol>
<li><p><strong>公平性：同样有公平锁和非公平锁；</strong>  </p>
</li>
<li><p><strong>重入性：读锁和写锁都支持重入（最大65535）；</strong></p>
</li>
<li><strong>锁降级：获取写锁之后，获取读锁，释放写锁，保留读锁；（按顺序）</strong></li>
</ol>
<h3 id="二、ReentrantReadWriteLock的实现原理"><a href="#二、ReentrantReadWriteLock的实现原理" class="headerlink" title="二、ReentrantReadWriteLock的实现原理"></a>二、ReentrantReadWriteLock的实现原理</h3><p>ReentrantReadWriteLock与ReentrantLock一样，锁的语义的实现依旧是依靠Sync（继承自AQS），它的读锁、写锁的实现原理如下：</p>
<ul>
<li><strong>读锁：AQS共享锁</strong></li>
<li><strong>写锁：AQS独占锁</strong></li>
</ul>
<h4 id="读写状态"><a href="#读写状态" class="headerlink" title="读写状态"></a>读写状态</h4><p>读写锁的实现同样是依赖AQS来实现同步功能。<br>那么它的读写状态如何表示呢？<br>同样是<strong>使用一个int型的变量</strong>表示，将这个变量“按位切割”成两部分，<strong>高16位表示读，低16位表示写</strong>。这样我们就能通过位运算确定它的读写状态。（如下图）  </p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/duxiesuo.jpg" alt="（图）">  </p>
<p>如果已知整体同步状态为S，那么：</p>
<ul>
<li><strong>写状态：S &amp; 0x0000FFFF</strong>（将高16位变0，抹去）</li>
<li><strong>读状态：S&gt;&gt;&gt;16</strong> （无符号补0右移16位）  </li>
</ul>
<p><strong>注：当写状态为0，S不为0时，表示读状态不为0，读锁被获取。</strong></p>
<h4 id="写锁的获取和释放"><a href="#写锁的获取和释放" class="headerlink" title="写锁的获取和释放"></a>写锁的获取和释放</h4><p>写锁是独占锁，获取时调用Sync中的tryAcquire()方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">protected final boolean tryAcquire(int acquires) &#123;</div><div class="line">            Thread current = Thread.currentThread();</div><div class="line">            //获取状态</div><div class="line">            int c = getState();</div><div class="line">            //获取写状态</div><div class="line">            int w = exclusiveCount(c);</div><div class="line">            if (c != 0) &#123;</div><div class="line">                //写状态为0表示存在读线程，获取失败</div><div class="line">                //或当前线程不是获取写锁的线程，获取失败</div><div class="line">                if (w == 0 || current != getExclusiveOwnerThread())</div><div class="line">                    return false;</div><div class="line">                //超过写锁总数量</div><div class="line">                if (w + exclusiveCount(acquires) &gt; MAX_COUNT)</div><div class="line">                    throw new Error(&quot;Maximum lock count exceeded&quot;);</div><div class="line">                //当前线程是获取写锁的线程，重进入，获取成功</div><div class="line">                setState(c + acquires);</div><div class="line">                return true;</div><div class="line">            &#125;</div><div class="line">            //是否需要阻塞</div><div class="line">            if (writerShouldBlock() ||</div><div class="line">                !compareAndSetState(c, c + acquires))</div><div class="line">                return false;</div><div class="line">            setExclusiveOwnerThread(current);</div><div class="line">            return true;</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p>
<p>写锁的获取过程如代码中注释所示。<br>只有在以下情况才能获取写锁：</p>
<ul>
<li><strong>不存在读锁或当前线程是已经获取写锁的线程（可重入）</strong></li>
</ul>
<hr>
<p>写锁的释放调用的是Sync的tryRelease()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">protected final boolean tryRelease(int releases) &#123;</div><div class="line">            if (!isHeldExclusively())</div><div class="line">                throw new IllegalMonitorStateException();</div><div class="line">            int nextc = getState() - releases;</div><div class="line">            boolean free = exclusiveCount(nextc) == 0;</div><div class="line">            if (free)</div><div class="line">                setExclusiveOwnerThread(null);</div><div class="line">            setState(nextc);</div><div class="line">            return free;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>写锁的释放与重入锁的释放过程类似，每次释放时将写状态减少，直到写锁状态为0时，表示写锁释放。</p>
<hr>
<h4 id="读锁的获取和释放"><a href="#读锁的获取和释放" class="headerlink" title="读锁的获取和释放"></a>读锁的获取和释放</h4><p>读锁是共享锁，调用的是Sync的tryAcquireShared()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">protected final int tryAcquireShared(int unused) &#123;</div><div class="line">            Thread current = Thread.currentThread();</div><div class="line">            int c = getState(); //获取状态</div><div class="line">            //写锁不为0  &amp;&amp; 且获取写锁的线程不是当前线程</div><div class="line">            //直接失败</div><div class="line">            if (exclusiveCount(c) != 0 &amp;&amp;</div><div class="line">                getExclusiveOwnerThread() != current) </div><div class="line">                return -1;</div><div class="line">            //获取读锁</div><div class="line">            int r = sharedCount(c);</div><div class="line">            //readerShouldBlock()：读锁是否要等待（公平or非公平）</div><div class="line">            // r &lt; MAX_COUNT：读锁小于最大值（65535）</div><div class="line">            //compareAndSetState(c, c + SHARED_UNIT))：CAS操作成功</div><div class="line">            if (!readerShouldBlock() &amp;&amp;</div><div class="line">                r &lt; MAX_COUNT &amp;&amp;</div><div class="line">                compareAndSetState(c, c + SHARED_UNIT)) &#123;</div><div class="line">                //r == 0：只有一个读锁（A），计数+1</div><div class="line">                if (r == 0) &#123;</div><div class="line">                    firstReader = current;</div><div class="line">                    firstReaderHoldCount = 1;</div><div class="line">                //持有读锁的线程（A）重进入，计数++</div><div class="line">                &#125; else if (firstReader == current) &#123;</div><div class="line">                    firstReaderHoldCount++;</div><div class="line">                &#125; else &#123;</div><div class="line">                //另一个线程（B）进入，此时找到缓存的rh，将计数++；</div><div class="line">                    HoldCounter rh = cachedHoldCounter;</div><div class="line">                    if (rh == null || rh.tid != getThreadId(current))</div><div class="line">                        cachedHoldCounter = rh = readHolds.get();</div><div class="line">                    else if (rh.count == 0)</div><div class="line">                        readHolds.set(rh);</div><div class="line">                    rh.count++;</div><div class="line">                &#125;</div><div class="line">                return 1;</div><div class="line">            &#125;</div><div class="line">            //循环尝试</div><div class="line">            return fullTryAcquireShared(current);</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>获取锁的过程如注释所示。<br>如果不满足第二个if语句中的判断，比如读锁需要阻塞，则会进入fullTryAcquireShared（current）方法，<strong>该方法循环不断尝试修改状态直到成功或被写入锁占有。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">final int fullTryAcquireShared(Thread current) &#123;</div><div class="line">            HoldCounter rh = null;</div><div class="line">            for (;;) &#123;</div><div class="line">                int c = getState();</div><div class="line">                //写锁存在但不是当前线程，直接失败</div><div class="line">                if (exclusiveCount(c) != 0) &#123;</div><div class="line">                    if (getExclusiveOwnerThread() != current)</div><div class="line">                        return -1;</div><div class="line">                //读锁是否要阻塞（公平 or 非公平）</div><div class="line">                &#125; else if (readerShouldBlock()) &#123;</div><div class="line">                    if (firstReader == current) &#123;</div><div class="line">                    &#125; else &#123;</div><div class="line">                        if (rh == null) &#123;</div><div class="line">                            rh = cachedHoldCounter;</div><div class="line">                            if (rh == null || rh.tid != getThreadId(current)) &#123;</div><div class="line">                                rh = readHolds.get();</div><div class="line">                                if (rh.count == 0)</div><div class="line">                                    readHolds.remove();</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                        if (rh.count == 0)</div><div class="line">                            return -1;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                //读锁达到最大值，不能再获取</div><div class="line">                if (sharedCount(c) == MAX_COUNT)</div><div class="line">                    throw new Error(&quot;Maximum lock count exceeded&quot;);</div><div class="line">                //CAS操作</div><div class="line">                if (compareAndSetState(c, c + SHARED_UNIT)) &#123;</div><div class="line">                    if (sharedCount(c) == 0) &#123;</div><div class="line">                        firstReader = current;</div><div class="line">                        firstReaderHoldCount = 1;</div><div class="line">                    &#125; else if (firstReader == current) &#123;</div><div class="line">                        firstReaderHoldCount++;</div><div class="line">                    &#125; else &#123;</div><div class="line">                        if (rh == null)</div><div class="line">                            rh = cachedHoldCounter;</div><div class="line">                        if (rh == null || rh.tid != getThreadId(current))</div><div class="line">                            rh = readHolds.get();</div><div class="line">                        else if (rh.count == 0)</div><div class="line">                            readHolds.set(rh);</div><div class="line">                        rh.count++;</div><div class="line">                        cachedHoldCounter = rh; </div><div class="line">                    &#125;</div><div class="line">                    return 1;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>以上的代码中多次出现了一个rh变量（HoldCounter），我们知道重入锁的原理就是计数器，同理这个rh变量也相当于一个计数器，记录线程获取读锁的次数。来看它的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//HoldCounter类</div><div class="line">static final class HoldCounter &#123;</div><div class="line">            int count = 0;</div><div class="line">            final long tid = getThreadId(Thread.currentThread());</div><div class="line">        &#125;</div><div class="line">//继承ThreadLocal类        </div><div class="line">static final class ThreadLocalHoldCounter</div><div class="line">            extends ThreadLocal&lt;HoldCounter&gt; &#123;</div><div class="line">            public HoldCounter initialValue() &#123;</div><div class="line">                return new HoldCounter();</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>HoldCounter的定义只包含一个计数器和当前线程的Id，它的作用就是记录该线程获取读锁的次数，那么它是如何与线程绑定的呢？我们知道ThreadLocal类是线程维护的私有变量，利用它就可以和线程绑定。  </p>
<p>注：（需要说明的是这样<strong>HoldCounter绑定线程id而不绑定线程对象的原因是**</strong>避免HoldCounter和ThreadLocal互相绑定而GC难以释放它们**，所以其实这样做只是为了帮助GC快速回收对象而已。）</p>
<hr>
<p>当读锁释放时，调用的是Sync的tryReleaseShared()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">protected final boolean tryReleaseShared(int unused) &#123;</div><div class="line">            Thread current = Thread.currentThread();</div><div class="line">            if (firstReader == current) &#123;</div><div class="line">                if (firstReaderHoldCount == 1)</div><div class="line">                    firstReader = null;</div><div class="line">                else</div><div class="line">                    firstReaderHoldCount--;</div><div class="line">            &#125; else &#123;</div><div class="line">                HoldCounter rh = cachedHoldCounter;</div><div class="line">                if (rh == null || rh.tid != getThreadId(current))</div><div class="line">                    rh = readHolds.get();</div><div class="line">                int count = rh.count;</div><div class="line">                if (count &lt;= 1) &#123;</div><div class="line">                    readHolds.remove();</div><div class="line">                    if (count &lt;= 0)</div><div class="line">                        throw unmatchedUnlockException();</div><div class="line">                &#125;</div><div class="line">                --rh.count;</div><div class="line">            &#125;</div><div class="line">            for (;;) &#123;</div><div class="line">                int c = getState();</div><div class="line">                int nextc = c - SHARED_UNIT;</div><div class="line">                if (compareAndSetState(c, nextc))</div><div class="line">                    return nextc == 0;</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>循环CAS操作直到读锁的状态为0。</p>
<h4 id="锁降级"><a href="#锁降级" class="headerlink" title="锁降级"></a>锁降级</h4><p>前面提到，读写锁有个特性是锁降级。<br>锁降级指的是：<strong>写锁降级为读锁</strong>。</p>
<p>具体过程：<strong>获取写锁的线程把持住写锁，然后获取读锁，再释放写锁。</strong>  </p>
<p><strong>目的：保证写锁修改的数据可以被其他线程看见，保证了数据的可见性。</strong> </p>
<p>锁降级中读锁的获取是否为必要？肯定是必要的。试想，假如当前线程A不获取读锁而是直接释放了写锁，这个时候另外一个线程B获取了写锁，那么这个线程B对数据的修改是不会对当前线程A可见的。   如果获取了读锁，则线程B在获取写锁过程中判断如果有读锁还没有释放则会被阻塞，只有当前线程A释放读锁后，线程B才会获取写锁成功。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、ReentrantReadWriteLock的概念&quot;&gt;&lt;a href=&quot;#一、ReentrantReadWriteLock的概念&quot; class=&quot;headerlink&quot; title=&quot;一、ReentrantReadWriteLock的概念&quot;&gt;&lt;/a&gt;一、Ree
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="ReentrantReadWriteLock" scheme="http://yoursite.com/tags/ReentrantReadWriteLock/"/>
    
      <category term="可重入读写锁" scheme="http://yoursite.com/tags/%E5%8F%AF%E9%87%8D%E5%85%A5%E8%AF%BB%E5%86%99%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>JVM之对象创建过程</title>
    <link href="http://yoursite.com/2017/10/26/JVM%E4%B9%8B%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2017/10/26/JVM之对象创建过程/</id>
    <published>2017-10-26T10:48:19.000Z</published>
    <updated>2018-02-24T07:33:25.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、Java对象的创建过程"><a href="#一、Java对象的创建过程" class="headerlink" title="一、Java对象的创建过程"></a>一、Java对象的创建过程</h3><p>在Java程序中，通常都是通过 new 关键字来创建对象，那么在虚拟机中对象是如何创建的？<br>（普通Java对象，不包含数组和Class对象）</p>
<p>虚拟机创建对象主要经历5个步骤：<strong>类加载检查、为对象分配内存、内存空间初始化、对象设置、执行对象<init>方法。</init></strong></p>
<h4 id="1-类加载检查"><a href="#1-类加载检查" class="headerlink" title="1 类加载检查"></a>1 类加载检查</h4><p>当虚拟机遇到 new 指令时，首先会去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且<strong>检查这个符号引用代表的类是否已被加载、解析和初始化过</strong>。如果没有，先执行类加载过程。</p>
<h4 id="2-为对象分配内存"><a href="#2-为对象分配内存" class="headerlink" title="2 为对象分配内存"></a>2 为对象分配内存</h4><p>对象所需的内存大小在类加载完成时已经确定，因此<strong>为对象分配内存等同于在Java堆中划分一块大小确定的内存空间</strong>。  </p>
<h5 id="两种分配方式："><a href="#两种分配方式：" class="headerlink" title="两种分配方式："></a>两种分配方式：</h5><ul>
<li><strong>指针碰撞</strong>：Java堆中的内存是完整的，将指针往空闲空间挪动一段与对象大小相等的距离</li>
<li><strong>空闲列表</strong>：Java堆中的内存不是完整的，JVM维护了一个记录可用内存的列表，分配时将列表中足够大的空间划分给对象，并更新列表</li>
</ul>
<p>因此选择何种分配方式由Java堆是否完整决定，而这又由垃圾收集器是否带有压缩整理功能决定。如：</p>
<ul>
<li><strong>Serial、ParNew等采用指针碰撞</strong></li>
<li><strong>CMS基于“标记-清除”采用空闲列表</strong></li>
</ul>
<h5 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h5><p>当处于并发情况下时，还要考虑线程安全问题。<br>两种解决方案：</p>
<ul>
<li><strong>对分配内存的动作进行同步处理</strong>。JVM采用CAS加失败重试的方式保证原子性</li>
<li><strong>把内存分配的动作按照线程划分在不同的空间进行</strong>。每个线程在Java堆中预先分配一小块内存（本地线程分配缓冲TLAB），只有TLAB用完重新分配时才同步锁定。<h4 id="3-内存空间初始化"><a href="#3-内存空间初始化" class="headerlink" title="3 内存空间初始化"></a>3 内存空间初始化</h4>JVM将分配到的内存空间都初始化为零值（不包括对象头）；若使用TLAB，则提前至TLAB分配时执行。</li>
</ul>
<p>这一步<strong>保证了对象实例字段在Java代码中可以不赋初值就直接使用</strong>，程序能访问到这些字段的数据类型所对应的零值。</p>
<h4 id="4-对象设置"><a href="#4-对象设置" class="headerlink" title="4 对象设置"></a>4 对象设置</h4><p>JVM设置对象头信息，如类元数据信息、对象的哈希码、对象的GC分代年龄信息等。还有是否启用偏向锁。</p>
<h4 id="5-执行对象方法"><a href="#5-执行对象方法" class="headerlink" title="5 执行对象方法"></a>5 执行对象<init>方法</init></h4><p>此时，对于JVM来说，对象已经产生；<br>对于Java程序来说，才刚刚开始，执行<init>方法进行初始化，一个对象才算真正创建完成。</init></p>
<h3 id="二、Java对象的初始化"><a href="#二、Java对象的初始化" class="headerlink" title="二、Java对象的初始化"></a>二、Java对象的初始化</h3><p>在Java对象初始化过程中，主要涉及三种执行对象初始化的结构，分别是 <strong>实例变量初始化、实例代码块初始化</strong> 以及 <strong>构造函数初始化</strong>。 </p>
<h4 id="实例变量初始化与实例代码块初始化"><a href="#实例变量初始化与实例代码块初始化" class="headerlink" title="实例变量初始化与实例代码块初始化"></a>实例变量初始化与实例代码块初始化</h4><p>在定义（声明）实例变量的同时，还可以直接对实例变量进行赋值或者使用实例代码块对其进行赋值。<br>如果我们<strong>以这两种方式为实例变量进行初始化，那么它们将在构造函数执行之前完成这些初始化操作。</strong> 实际上，如果我们对实例变量直接赋值或者使用实例代码块赋值，那么编译器会将其中的代码放到类的构造函数中去，并且这些代码会被放在对超类构造函数的调用语句之后(Super())，构造函数本身的代码之前。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public class Tdemo2 &#123;</div><div class="line">	//成员变量</div><div class="line">	private int i = 1;</div><div class="line">	private int j = 1;</div><div class="line">	public  Tdemo2(int c)&#123;</div><div class="line">		System.out.println(i);</div><div class="line">		System.out.println(j);</div><div class="line">		this.i = c;</div><div class="line">		System.out.println(i);</div><div class="line">	&#125;</div><div class="line">	//代码块</div><div class="line">	&#123;</div><div class="line">		j = j+1;</div><div class="line">	&#125;</div><div class="line">	//静态代码块</div><div class="line">	static&#123;</div><div class="line">		int a = 5;</div><div class="line">		System.out.println(a);</div><div class="line">	&#125;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		new Tdemo2(3);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">5</div><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td></tr></table></figure></p>
<p>可见执行顺序是static代码块、成员变量赋值、代码块、构造函数。</p>
<h4 id="构造函数初始化"><a href="#构造函数初始化" class="headerlink" title="构造函数初始化"></a>构造函数初始化</h4><p><strong>Java要求在实例化类之前，必须先实例化其超类，以保证所创建实例的完整性。</strong><br>Java强制要求Object对象(Object是Java的顶层对象，没有超类)之外的所有对象构造函数的第一条语句必须是超类构造函数的调用语句或者是类中定义的其他的构造函数，如果我们既没有调用其他的构造函数，也没有显式调用超类的构造函数，那么编译器会为我们自动生成一个对超类构造函数的调用。</p>
<p>实际上，实例化一个类的对象的过程是一个典型的递归过程。</p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/%E5%AE%9E%E4%BE%8B%E5%8C%96%E9%80%92%E5%BD%92%E8%BF%87%E7%A8%8B.png" alt="image"></p>
<p>在准备实例化一个类的对象前，首先准备实例化该类的父类，如果该类的父类还有父类，那么准备实例化该类的父类的父类，依次递归直到递归到Object类。</p>
<p><strong>注意：实例初始化不一定要在类初始化结束之后才开始初始化。</strong></p>
<p>回忆一下Java中赋值顺序： </p>
<ol>
<li>父类的静态变量赋值 </li>
<li>自身的静态变量赋值 </li>
<li>父类成员变量赋值和父类代码块赋值 </li>
<li>父类构造函数赋值 </li>
<li>自身成员变量赋值和自身块代码赋值 </li>
<li>自身构造函数赋值</li>
</ol>
<h3 id="三、Java对象的创建方式"><a href="#三、Java对象的创建方式" class="headerlink" title="三、Java对象的创建方式"></a>三、Java对象的创建方式</h3><p>Java对象的创建方式有 5 种：</p>
<ol>
<li><p>new 关键字</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Person p = new Person();</div></pre></td></tr></table></figure>
</li>
<li><p>Class类的newInstance()（反射）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Person p2 = Person.class.newInstance();</div></pre></td></tr></table></figure>
</li>
<li><p>Constructor类的newInstance方法（反射）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Constructor c = Person.class.getConstructor();</div><div class="line">Person p3 = (Person) c.newInstance();</div></pre></td></tr></table></figure>
</li>
<li><p>clone方法（实现Cloneable接口）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Person p4 = (Person) p3.clone();</div></pre></td></tr></table></figure>
</li>
<li><p>反序列化（实现Serializable接口）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//写对象</div><div class="line">ObjectOutputStream output = new ObjectOutputStream(new FileOutputStream(&quot;person.txt&quot;));</div><div class="line">output.writeObject(p);</div><div class="line">output.close();</div><div class="line"></div><div class="line">//读对象</div><div class="line">ObjectInputStream input = new ObjectInputStream(new FileInputStream(&quot;person.txt&quot;));</div><div class="line">Person p5 = (Person) input.readObject();</div></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、Java对象的创建过程&quot;&gt;&lt;a href=&quot;#一、Java对象的创建过程&quot; class=&quot;headerlink&quot; title=&quot;一、Java对象的创建过程&quot;&gt;&lt;/a&gt;一、Java对象的创建过程&lt;/h3&gt;&lt;p&gt;在Java程序中，通常都是通过 new 关键字来创建
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
      <category term="对象创建过程" scheme="http://yoursite.com/tags/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>JVM之类加载机制</title>
    <link href="http://yoursite.com/2017/10/24/JVM%E4%B9%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2017/10/24/JVM之类加载机制/</id>
    <published>2017-10-24T11:34:18.000Z</published>
    <updated>2018-02-24T07:28:54.050Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、类加载机制"><a href="#一、类加载机制" class="headerlink" title="一、类加载机制"></a>一、类加载机制</h3><p>虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被JVM直接使用的Java类型，这就是虚拟机的<strong>类加载机制</strong>。</p>
<h4 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h4><p>那么类到底什么时候会加载呢？（初始化）<br><strong>当对一个类进行主动引用的时候</strong>。</p>
<h5 id="主动引用"><a href="#主动引用" class="headerlink" title="主动引用"></a>主动引用</h5><p>主动引用有5种情况：</p>
<ol>
<li>new实例化对象、读取或设置一个类的静态字段时、调用一个类的静态方法时</li>
<li>使用java.lang.reflect包的方法对类进行反射调用时</li>
<li>初始化一个类时，父类还没初始化，则先触发父类的初始化</li>
<li>虚拟机启动时，初始化包含main()方法的主类</li>
<li>使用JDK1.7的动态语言支持的时候，如java.lang.invoke.MethodHandle实例</li>
</ol>
<h5 id="被动引用"><a href="#被动引用" class="headerlink" title="被动引用"></a>被动引用</h5><p>被动引用有以下几种情况：</p>
<ol>
<li>子类调用父类的静态变量，子类不会被初始化，只有父类会被初始化。（只有定义静态字段的类才会被初始化）</li>
<li>通过数组来定义引用类，不会初始化</li>
<li>访问类的final常量(编译期静态常量)，不会初始化</li>
<li>通过类名获取Class对象，不会触发类的初始化(其余两种getClass()和Class.forName()会)<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//类名.class获取Class对象</div><div class="line">Class clazz = A.class;</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="二、类加载过程"><a href="#二、类加载过程" class="headerlink" title="二、类加载过程"></a>二、类加载过程</h3><h4 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h4><p><img src="http://osuskkx7k.bkt.clouddn.com/%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F2.jpg.png" alt="image"></p>
<p><strong>类的生命周期包括：加载、验证、准备、解析、初始化、使用和卸载7个阶段。</strong> 验证、准备、解析这三个阶段称为连接。<br>解析阶段的顺序不是确定的，可以在初始化之后开始。</p>
<p><strong>类加载过程</strong>包括<strong>加载、验证、准备、解析、初始化</strong>。</p>
<h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p>JVM完成以下3件事：</p>
<ol>
<li>通过一个类的全限定名来获取定义此类的二进制字节流（不一定是Class文件）。</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</li>
</ol>
<p>注：</p>
<ul>
<li>数组类本身不通过类加载器创建，由虚拟机直接创建</li>
<li>内存中实例化的Class对象并不是在堆中，存放于方法区（HotSpot虚拟机）<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4>验证的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求。<br>主要完成以下4个检验动作：</li>
</ul>
<ol>
<li>文件格式验证：如魔数、版本号、常量类型….</li>
<li>元数据验证：这个类是否有父类？是不是抽象类？是否继承了不允许被继承的类？</li>
<li>字节码验证：对类的方法体进行校验分析，确定程序语义是合法、符合逻辑的。</li>
<li>符号引用验证：（发生在解析阶段）符号引用中通过字符串描述的全限定名是否能找到对应的类？…</li>
</ol>
<p>验证阶段是一个很重要但不一定是必要的阶段。</p>
<h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p><strong>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。</strong>（这里的类变量仅为Static修饰的变量，不包括实例变量，实例变量是在对象实例化时随着对象分配在堆中）</p>
<p>假设一个类变量定义为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public static int value = 666;</div></pre></td></tr></table></figure></p>
<p>那么在准备阶段过后，初始值为0，而不是666，因为把value赋值为666的动作在初始化阶段才会执行。</p>
<p>但是下面这种情况除外：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public static final int value = 666;</div></pre></td></tr></table></figure>
<p>当用final修饰时，会在准备阶段赋值为666。</p>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p><strong>解析阶段是虚拟机将常量池中的符号引用替换为直接引用的过程。</strong>  </p>
<p><strong>符号引用</strong>：定义在Java虚拟机规范的Class文件格式中（与虚拟机内存布局无关）<br><strong>直接引用</strong>：直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。（与虚拟机内存布局相关）</p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>类初始化阶段是类加载过程的最后一步。<strong>初始化阶段才真正开始执行类中定义的Java程序代码。</strong></p>
<p>在准备阶段，类变量被赋了初始值，在初始化阶段才会真正赋值。或者说，初始化阶段是执行类构造器<clinit>()方法的过程。</clinit></p>
<h5 id="方法"><a href="#方法" class="headerlink" title="()方法"></a><clinit>()方法</clinit></h5><ul>
<li><clinit>()方法是编译器自动收集类中的所有变量的赋值动作和静态语句块（static{}）中的语句合并产生的，顺序由源文件顺序决定。</clinit></li>
<li><clinit>()方法与类的构造函数不同（实例构造器<init>()），它不需要显示地调用父类构造器，虚拟机保证子类<clinit>()方法执行之前，父类<clinit>()方法已经执行完毕。因此，JVM中第一个执行的<clinit>()方法的类是java.lang.Object。</clinit></clinit></clinit></init></clinit></li>
<li><clinit>()方法对于类或接口来说不是必须的，一个类没有静态语句块或者没有对变量的赋值操作，可以没有<clinit>()方法</clinit></clinit></li>
<li>接口中有变量初始化赋值的操作时，会生成<clinit>()方法。但接口不需要执行父接口的<clinit>()方法。接口的实现类在初始化时也不要=会执行接口的<clinit>()方法。</clinit></clinit></clinit></li>
<li>虚拟机保证一个类的<clinit>()方法会在多线程情况下加锁、同步。只有一个线程会执行<clinit>()方法成功。</clinit></clinit></li>
</ul>
<h3 id="三、类加载器"><a href="#三、类加载器" class="headerlink" title="三、类加载器"></a>三、类加载器</h3><p>在加载阶段中，<strong>“通过一个类的全限定名来获取定义此类的二进制字节流”这个动作的实现是由类加载器来完成的。</strong><br>这个动作在JVM外部实现，以便让应用程序自己决定如何去获取所需要的类。</p>
<p><strong>简而言之，类加载器用于实现类的加载动作。</strong></p>
<p>只有由同一个类加载器加载的两个类才相等。若同一个Class文件由不同的类加载器加载，则不相等。</p>
<h4 id="3种类加载器"><a href="#3种类加载器" class="headerlink" title="3种类加载器"></a>3种类加载器</h4><p><img src="http://osuskkx7k.bkt.clouddn.com/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8.png" alt="image"></p>
<ul>
<li><strong>启动类加载器（Bootstrap ClassLoader）</strong>：负责加载<java_home>\lib目录中，或者被-Xbootclasspath参数所指定的路径中，并且被虚拟机识别的如rt.jar等类库</java_home></li>
<li><strong>扩展类加载器（Extension ClassLoader）</strong>：加载<java_home>\lib\ext目录中的，或通过java.ext.dirs系统变量指定路径中的类库</java_home></li>
<li><strong>应用程序类加载器（Application ClassLoader</strong>）：加载用户类路径（ClassPath）上指定的类库，也叫系统类加载器，程序默认的类加载器</li>
</ul>
<h4 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h4><p>工作过程：<strong>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此。因此所有的加载请求最终都会传送到顶层的启动类加载器中，只有当父加载器无法完成这个加载请求时，子加载器才会自己去加载。</strong></p>
<p>双亲委派模型有什么好处？  </p>
<p>保证了Java程序的稳定运行。<br>例如，java.lang.Object存放在rt.jar中，无论哪一个类加载器加载这个类，最终都会委派给启动类加载器进行加载，<strong>因此Object类在程序的各种类加载器环境中都是同一个类。</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、类加载机制&quot;&gt;&lt;a href=&quot;#一、类加载机制&quot; class=&quot;headerlink&quot; title=&quot;一、类加载机制&quot;&gt;&lt;/a&gt;一、类加载机制&lt;/h3&gt;&lt;p&gt;虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被J
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
      <category term="类加载机制" scheme="http://yoursite.com/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>JVM之垃圾收集器</title>
    <link href="http://yoursite.com/2017/10/23/JVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
    <id>http://yoursite.com/2017/10/23/JVM之垃圾收集器/</id>
    <published>2017-10-23T11:28:13.000Z</published>
    <updated>2018-02-24T06:43:07.465Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、垃圾收集器概述"><a href="#一、垃圾收集器概述" class="headerlink" title="一、垃圾收集器概述"></a>一、垃圾收集器概述</h3><p><strong>垃圾收集器是内存垃圾回收算法的具体实现。</strong><br>Java虚拟机规范中对垃圾收集器应该如何实现并没有任何规定，因此出现了7种收集器：Serial、ParNew、Parallel Scavenge、Serial Old、Parallel Old、CMS、G1。<br>它们以组合的形式配合工作来完成不同分代的垃圾收集工作。</p>
<p><strong>常用组合</strong>：</p>
<ol>
<li>Serial/Serial Old</li>
<li>ParNew/Serial Old</li>
<li>ParNew/CMS</li>
<li>Parallel Scavenge/Parallel Old</li>
<li>G1</li>
</ol>
<p><img src="http://osuskkx7k.bkt.clouddn.com/JVMtool2.png" alt="image"></p>
<h4 id="Minor-GC和Full-GC"><a href="#Minor-GC和Full-GC" class="headerlink" title="Minor GC和Full GC"></a>Minor GC和Full GC</h4><p>Minor GC（新生代GC）：发生在新生代的GC动作，频率高，回收速度块。</p>
<p>Full GC（老年代GC）：发生在老年代的GC动作，老年代满了后才进行，一般伴随至少一次Minor GC，频率低，回收速度慢。</p>
<h4 id="垃圾收集器种类"><a href="#垃圾收集器种类" class="headerlink" title="垃圾收集器种类"></a>垃圾收集器种类</h4><p>目前的收集器主要有以下三种：  </p>
<p><strong>串行收集器：</strong> 只有一条垃圾收集线程工作  </p>
<p><strong>并行收集器：</strong> 多条垃圾收集线程并行工作，用户线程等待</p>
<p><strong>并发收集器：</strong> 垃圾收集线程与用户线程同时执行（不一定并行，可能交替执行）</p>
<h3 id="二、垃圾收集器详述"><a href="#二、垃圾收集器详述" class="headerlink" title="二、垃圾收集器详述"></a>二、垃圾收集器详述</h3><h4 id="新生代收集器（3种）"><a href="#新生代收集器（3种）" class="headerlink" title="新生代收集器（3种）"></a>新生代收集器（3种）</h4><h5 id="Serial-收集器（串行）"><a href="#Serial-收集器（串行）" class="headerlink" title="Serial 收集器（串行）"></a>Serial 收集器（串行）</h5><p>Serial收集器是一个单线程的收集器。<br>“单线程”：不仅只是有一条收集线程，而且必须暂停用户工作线程。 </p>
<p>工作过程：  </p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/seria.png" alt="image"></p>
<p><strong>特点：</strong> 单线程，无线程切换，简单高效，（管理内存小，停顿可以接受）<br><strong>缺点：</strong>  暂停工作线程<br><strong>应用场景：</strong> 适用于运行在Client模式下的虚拟机</p>
<h5 id="ParNew-收集器（并行）"><a href="#ParNew-收集器（并行）" class="headerlink" title="ParNew 收集器（并行）"></a>ParNew 收集器（并行）</h5><p>ParNew收集器是Serial收集器的多线程版本。</p>
<p>工作过程：  </p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/ParNew.png" alt="image"></p>
<p><strong>特点：</strong> 多线程，除Serial外唯一能和CMS收集器配合<br><strong>缺点：</strong>  暂停工作线程，单线程下不如Serial<br><strong>应用场景：</strong> 适用于运行在Server模式下的虚拟机</p>
<h5 id="Parallel-Scavenge-收集器（并行）"><a href="#Parallel-Scavenge-收集器（并行）" class="headerlink" title="Parallel Scavenge 收集器（并行）"></a>Parallel Scavenge 收集器（并行）</h5><p>Parallel Scavenge收集器被称为“吞吐量优先”收集器。</p>
<p>工作过程：  </p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/parallel%20scavenge.png" alt="image"></p>
<p><strong>特点：</strong> </p>
<ul>
<li><strong>可控制吞吐量。</strong><br>吞吐量 = 用户代码时间/（用户代码时间+垃圾收集时间）<br>吞吐量越高，表示越高效地利用CPU，适合后台运算任务。  </li>
<li><strong>GC 自适应调节策略</strong><br>JVM可以根据当前系统的运行情况自适应调节参数，以提供最合适的停顿时间和最大的吞吐量。</li>
</ul>
<p><strong>缺点：</strong> 相比停顿时间更注重吞吐量<br><strong>应用场景：</strong> 主要用于后台计算，不需要与用户进行太多交互，对暂停时间没有特别高的要求等场景，如批量处理；</p>
<h4 id="老年代收集器（3种）"><a href="#老年代收集器（3种）" class="headerlink" title="老年代收集器（3种）"></a>老年代收集器（3种）</h4><h5 id="Serial-Old-收集器（串行）"><a href="#Serial-Old-收集器（串行）" class="headerlink" title="Serial Old 收集器（串行）"></a>Serial Old 收集器（串行）</h5><p>Serial Old是Serial的老年代版本，同样是一个单线程收集器。  </p>
<p>工作过程：  </p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/seria.png" alt="image"></p>
<p><strong>特点：</strong> 单线程，“标记-整理”算法<br><strong>缺点：</strong>  暂停工作线程<br><strong>应用场景：</strong> 适用于运行在Client模式下的虚拟机</p>
<h5 id="Parallel-Old-收集器（并行）"><a href="#Parallel-Old-收集器（并行）" class="headerlink" title="Parallel Old 收集器（并行）"></a>Parallel Old 收集器（并行）</h5><p>Parallel Old是Parallel Scavenge收集器的老年代版本，多线程收集器。（JDK1.6之后出现）</p>
<p>工作过程：  </p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/parallel%20old.png" alt="image"></p>
<p><strong>特点：</strong> 多线程，“标记-整理”算法，唯一能和Parallel Scavenge收集器配合<br><strong>缺点：</strong>  暂停工作线程<br><strong>应用场景：</strong> 适用于注重吞吐量及CPU资源敏感的场合</p>
<h5 id="CMS-收集器（并发）"><a href="#CMS-收集器（并发）" class="headerlink" title="CMS 收集器（并发）"></a>CMS 收集器（并发）</h5><p><strong>CMS（Concurrent Mark Sweep）是一种以获取最短回收停顿时间为目标的收集器。<br>第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。</strong>  </p>
<p>工作过程分为<strong>4个步骤</strong>：  </p>
<ol>
<li><strong>初始标记</strong>：标记“GC-Roots”关联的对象（Stop the World）</li>
<li><strong>并发标记</strong>： 进行GC-Roots Tracing的过程，在刚才产生的集合中标记出存活对象；</li>
<li><strong>重新标记</strong>：修正并发标记期间因用户程序继续运作而导致标记变动的那一部分对象的标记记录（Stop the World）</li>
<li><strong>并发清除</strong>：回收所有垃圾对象</li>
</ol>
<p>所以，<strong>在初始标记和重新标记阶段，还是只有垃圾收集线程工作；并发标记和并发清除阶段是和用户线程并发执行的</strong>。</p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/CMS.png" alt="image"></p>
<p><strong>特点：</strong> 多线程并发执行，停顿时间短<br><strong>缺点：</strong>  </p>
<ul>
<li>对CPU资源十分敏感</li>
<li>无法处理浮动垃圾</li>
<li>产生大量空间碎片（由于是“标记-清除”算法）  </li>
</ul>
<p><strong>应用场景：</strong> 适用于大型网站或B/S的服务端，注重响应速度和用户体验。</p>
<h4 id="通用收集器"><a href="#通用收集器" class="headerlink" title="通用收集器"></a>通用收集器</h4><h5 id="G1-收集器（并发）"><a href="#G1-收集器（并发）" class="headerlink" title="G1 收集器（并发）"></a>G1 收集器（并发）</h5><p>G1是目前最前沿的收集器，可处理整个GC堆，JDK1.7之后出现。  </p>
<p><strong>G1是如何处理整个堆</strong>？<br>G1将整个堆划分为多个大小相等的独立区域Region（不再是新生代老年代），然后跟踪各个Region获得其垃圾收集价值大小，并在后台维护一个优先列表，根据允许的收集时间，优先回收价值最大的Region（名称Garbage-First的由来）。这个过程保证了在有限的时间内可以回收更多的垃圾。</p>
<p>工作过程分为<strong>4个步骤</strong>： </p>
<ol>
<li><strong>初始标记</strong>：标记“GC-Roots”关联的对象，并修改TAMS的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象</li>
<li><strong>并发标记</strong>：根据GC-Roots进行可达性分析，找出存活对象</li>
<li><strong>最终标记</strong>：为了修正并发标记期间由于用户程序继续运作而导致标记产生变动的那一部分对象的标示记录</li>
<li><strong>筛选回收</strong>：根据各个Region的价值回收</li>
</ol>
<p><img src="http://osuskkx7k.bkt.clouddn.com/G1.png" alt="image"></p>
<p><strong>特点：</strong> </p>
<ul>
<li>并行且并发  </li>
<li>独立处理整个GC堆，不需要配合其他收集器</li>
<li>可预测停顿时间</li>
<li>不产生空间碎片</li>
</ul>
<p><strong>应用场景：</strong> 面向服务器，适用于多CPU及大容量内存的机器。</p>
<h3 id="三、常见的参数配置"><a href="#三、常见的参数配置" class="headerlink" title="三、常见的参数配置"></a>三、常见的参数配置</h3><ul>
<li><strong>Xms</strong>：堆的最小值（初始）</li>
<li><strong>Xmx</strong>：堆的最大值<br>（Xms、Xmx二者一样时，可避免自动扩展）</li>
<li><strong>Xmn</strong>：堆中新生代的大小</li>
<li><strong>Xss</strong>：每个线程的堆栈大小</li>
<li><strong>XX:PermSize</strong>：永久代的大小（初始）</li>
<li><strong>XX:MaxPermSize</strong>：永久代的最大值</li>
<li><p><strong>XX:NewRatio</strong>：年轻代（包括Eden和两个Survivor区）与年老代的比值，设置为3，则年轻代与年老代所占比值为1：3，年轻代占整个堆栈的1/4</p>
</li>
<li><p><strong>XX:SurvivorRatio</strong>：年轻代中Eden区与Survivor区的大小比值。设置为4，则两个Survivor区与一个Eden区的比值为2:4，一个Survivor区占整个年轻代的1/6</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、垃圾收集器概述&quot;&gt;&lt;a href=&quot;#一、垃圾收集器概述&quot; class=&quot;headerlink&quot; title=&quot;一、垃圾收集器概述&quot;&gt;&lt;/a&gt;一、垃圾收集器概述&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;垃圾收集器是内存垃圾回收算法的具体实现。&lt;/strong&gt;&lt;br&gt;J
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
      <category term="垃圾收集器" scheme="http://yoursite.com/tags/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>JVM之垃圾收集算法</title>
    <link href="http://yoursite.com/2017/10/21/JVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2017/10/21/JVM之垃圾收集算法/</id>
    <published>2017-10-21T11:48:18.000Z</published>
    <updated>2017-10-23T13:58:22.016Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、对象的死亡判定"><a href="#一、对象的死亡判定" class="headerlink" title="一、对象的死亡判定"></a>一、对象的死亡判定</h3><p><strong>JVM垃圾回收针对哪些区域？回收的是什么？</strong><br><strong>答：</strong><br><strong>1. 主要针对Java堆。</strong><br><strong>2. 回收“死亡”的对象，即没有引用的对象。</strong></p>
<p>那么如何判断对象是否“死亡”呢？<br>两种方法，引用计数法和可达性分析算法。</p>
<h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p><strong>原理：给每个对象添加一个引用计数器。</strong></p>
<ul>
<li>每当有一个地方引用它，引用计数器+1；</li>
<li>每当一个引用失效，引用计数器-1；</li>
<li>当引用计数器为0时，表示该对象无引用，即可回收。</li>
</ul>
<p>缺点：无法解决对象之间循环引用的问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">GCobject A = new GCobject();</div><div class="line">GCobject B = new GCobject();</div><div class="line">A.instance = B;</div><div class="line">B.instance = A;</div><div class="line">...</div><div class="line">A = null;</div><div class="line">B = null;</div></pre></td></tr></table></figure>
<p>可以看到，A、B对象都为null，已经不可能再访问，但由于A、B都有字段引用着对方，引用计数器不为0，因此不会被回收。</p>
<h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p><strong>原理：通过一系列称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为“引用链”，当一个对象到 GC Roots没有任何引用链相连时, 则说明此对象是不可用的。</strong>  </p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/gc1.jpg.png" alt="image"></p>
<p>如图，Object5、Object6、Object7这三个对象就是不可用的。</p>
<p><strong>“GC Roots”对象：</strong></p>
<ul>
<li>虚拟机栈(栈帧中的本地变量表)中引用的对象；</li>
<li>方法区中类静态引用的对象；</li>
<li>方法区中常量引用的对象；</li>
<li>本地方法栈中JNI（Native方法）引用的对象；</li>
</ul>
<hr>
<p>然而，在可达性分析算法中不可达的对象，也并不是“非死不可”。<strong>一个对象真正死亡，至少要经历两次标记过程：</strong></p>
<ol>
<li><strong>第一次标记：</strong> 对象无GC Roots的引用链，筛选是否执行finalize()方法：  </li>
</ol>
<ul>
<li>对象没有覆盖finalize()或finalize()被JVM调用过，则不需要执行；</li>
<li>若执行finalize()，则将对象放入F-Queue队列中，会由JVM自动建立的线程执行该方法；</li>
</ul>
<ol>
<li><strong>第二次标记</strong>：对F-Queue队列中的对象进行小规模的标记：</li>
</ol>
<ul>
<li>对象在finalize()中拯救自己（重新与引用链相连），则不会回收；</li>
<li>对象没有在finalize()中逃脱；</li>
</ul>
<p><strong>注：任何一个对象的finalize()方法只能被调用一次。</strong></p>
<h3 id="二、垃圾收集算法"><a href="#二、垃圾收集算法" class="headerlink" title="二、垃圾收集算法"></a>二、垃圾收集算法</h3><p>主要有4种垃圾收集算法。<br><strong>Java堆从GC的角度可以细分为: 新生代(Eden区、From Survivor区和To Survivor区)和老年代。</strong></p>
<h4 id="标记-清除算法（老年代）"><a href="#标记-清除算法（老年代）" class="headerlink" title="标记-清除算法（老年代）"></a>标记-清除算法（老年代）</h4><p>它是最基础的收集算法，<strong>算法分为标记和清除两个阶段：</strong></p>
<ol>
<li>首先标记出所有可回收的对象</li>
<li>统一回收被标记对象</li>
</ol>
<p><img src="http://osuskkx7k.bkt.clouddn.com/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4.jpg" alt="image">  </p>
<p>不足：</p>
<ol>
<li>效率问题，标记和清除的效率不高；</li>
<li>空间问题，标记清除后容易产生不连续的空间碎片（不利于大对象的内存分配）</li>
</ol>
<h4 id="复制算法（新生代）"><a href="#复制算法（新生代）" class="headerlink" title="复制算法（新生代）"></a>复制算法（新生代）</h4><p><strong>算法的核心是将可用内存按容量划分为大小相等的两块，每次只用其中一块，当这一块的内存用完，就将还存活的对象复制到另外一块上面，然后把已使用过的内存空间一次清理掉。</strong>（如图）</p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.jpg" alt="image"></p>
<p>优点：无内存碎片；<br>不足：可用内存减小；  </p>
<p>针对以上不足，就有了<strong>现代复制算法</strong>：<br>不需完全按照1∶1的比例划分新生代空间，<br>将<strong>新生代划分为一块较大的Eden区和两块较小的Survivor区(from和to)</strong>(HotSpot默认Eden和Survivor的大小为8∶1)，每次只用Eden和其中一块Survivor（from）。</p>
<ul>
<li>当发生MinorGC时, 将Eden和Survivor(from)中还存活着的对象一次性地拷贝到另外一块Survivor(to)上，最后清理掉Eden和刚才用过的Survivor(from)空间。</li>
<li>当Survivor(to)空间不够用(不足以保存尚存活的对象)时, 需要依赖老年代进行空间分配担保机制，这部分内存直接进入老年代。</li>
</ul>
<p><strong>注：现代的商业虚拟机都是采用这种收集算法回收新生代。</strong></p>
<h4 id="标记-整理算法（老年代）"><a href="#标记-整理算法（老年代）" class="headerlink" title="标记-整理算法（老年代）"></a>标记-整理算法（老年代）</h4><p>标记-清除算法会产生内存碎片问题，而复制算法需要有额外的内存担保空间，于是针对老年代的特点，又有了标记整理算法。<br><strong>标记整理算法：标记过程与标记-清除算法相同， 但后续步骤不再对可回收对象直接清理， 而是让所有存活的对象都向一端移动，然后清理掉端边界以外的内存。</strong> （如图）  </p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86.jpg" alt="image"></p>
<h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><p>当前主流JVM垃圾收集都采用”分代收集”(Generational Collection)算法。 这种算法会根据对象存活周期的不同将内存划分为几块， 如JVM中的<strong>新生代、老年代、永久代</strong>。 这样就可以根据各年代特点分别采用最适当的GC算法：</p>
<ul>
<li><strong>新生代</strong>：每次垃圾收集都能发现大批对象已死， 只有少量存活。因此选用<strong>复制算法</strong>，只需要付出少量存活对象的复制成本就可以完成收集。</li>
<li><strong>老年代</strong>：因为对象存活率高、没有额外空间对它进行分配担保，就必须采用“<strong>标记—清理”或“标记—整理</strong>”算法来进行回收，不必进行内存复制，且直接腾出空闲内存。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、对象的死亡判定&quot;&gt;&lt;a href=&quot;#一、对象的死亡判定&quot; class=&quot;headerlink&quot; title=&quot;一、对象的死亡判定&quot;&gt;&lt;/a&gt;一、对象的死亡判定&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;JVM垃圾回收针对哪些区域？回收的是什么？&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
      <category term="垃圾收集算法" scheme="http://yoursite.com/tags/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>ReentrantLock重入锁</title>
    <link href="http://yoursite.com/2017/10/20/ReentrantLock%E9%87%8D%E5%85%A5%E9%94%81/"/>
    <id>http://yoursite.com/2017/10/20/ReentrantLock重入锁/</id>
    <published>2017-10-20T11:48:18.000Z</published>
    <updated>2017-10-23T13:58:54.746Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、ReentrantLock概念"><a href="#一、ReentrantLock概念" class="headerlink" title="一、ReentrantLock概念"></a>一、ReentrantLock概念</h3><h4 id="重入锁概念"><a href="#重入锁概念" class="headerlink" title="重入锁概念"></a>重入锁概念</h4><p>什么是重入锁？   顾名思义，就是支持重复进入的锁。<br><strong>定义：支持一个线程对资源的重复加锁。（注意是一个线程）</strong></p>
<p>回忆前面有关AQS实现的文章，关于独占锁，当一个线程获取锁后，如果该线程再次调用lock()方法，那么该线程会被自己阻塞。<br>原因是在实现tryAcquire()时没有考虑占有锁的线程再次获取锁的场景。因此这个锁是不支持重入的锁。  </p>
<p>回顾synchronized的实现原理，我们知道它也是支持重进入的锁，即可以多次获取锁。</p>
<p>那么Lock能不能实现这个功能呢？当然是可以的。<br>ReentrantLock就是一个支持重进入的锁：<strong>在调用lock()方法时，已经获取到锁的线程，可以再次调用lock()方法获取锁而不被阻塞。</strong></p>
<h4 id="公平与非公平"><a href="#公平与非公平" class="headerlink" title="公平与非公平"></a>公平与非公平</h4><p>关于锁的获取，还有一个公平性的问题，于是就有了公平锁与非公平锁：  </p>
<ul>
<li><strong>公平锁：获取锁是顺序的。先对锁请求的线程先获取；</strong>  </li>
<li><strong>非公平锁：获取锁是无序的。任意线程都可以获取，无关请求先后；</strong></li>
</ul>
<p>来看看ReentrantLock的构造函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public ReentrantLock() &#123;</div><div class="line">        sync = new NonfairSync();</div><div class="line">    &#125;</div><div class="line">public ReentrantLock(boolean fair) &#123;</div><div class="line">        sync = fair ? new FairSync() : new NonfairSync();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>可以看到，ReentrantLock默认构造函数是非公平锁，另一个构造函数：  </p>
<ul>
<li>传入true：公平锁  </li>
<li>传入false：非公平锁</li>
</ul>
<h3 id="二、ReentrantLock的实现原理"><a href="#二、ReentrantLock的实现原理" class="headerlink" title="二、ReentrantLock的实现原理"></a>二、ReentrantLock的实现原理</h3><h4 id="重进入"><a href="#重进入" class="headerlink" title="重进入"></a>重进入</h4><p><strong>重进入的实现原理是定义了一个获取锁的计数器</strong>。 涉及到以下两个问题：  </p>
<ol>
<li><strong>线程再次获取锁。</strong><br>锁需要识别获取锁的线程是否为当前占据锁的线程，如果是，则再次获取锁成功，计数器+1。</li>
<li><strong>锁的最终释放。</strong><br>线程重复n次获取了锁，在第n次释放锁后，其他线程能够获取到锁。释放锁时，计数器-1，计数器为0时表示锁释放成功。</li>
</ol>
<hr>
<p><strong>ReentrantLock</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class ReentrantLock implements Lock, java.io.Serializable &#123;</div><div class="line">private final Sync sync;</div><div class="line">//AQS</div><div class="line">abstract static class Sync extends AbstractQueuedSynchronizer &#123;...&#125;;</div><div class="line">//非公平锁</div><div class="line">static final class NonfairSync extends Sync &#123;...&#125;;</div><div class="line">//公平锁</div><div class="line">static final class FairSync extends Sync &#123;...&#125;;</div><div class="line"></div><div class="line">....(省略)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从源码可以看到，<strong>ReentrantLock的实现依旧是依靠队列同步器AQS（Sync继承自AQS），不同的是这里有两个AQS的实现类，NonfairSync和FairSync，分别实现非公平锁和公平锁的功能。</strong></p>
<h4 id="非公平锁的实现"><a href="#非公平锁的实现" class="headerlink" title="非公平锁的实现"></a>非公平锁的实现</h4><p>非公平锁获取锁的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">final boolean nonfairTryAcquire(int acquires) &#123;</div><div class="line">            final Thread current = Thread.currentThread();</div><div class="line">            int c = getState();</div><div class="line">            if (c == 0) &#123;</div><div class="line">                if (compareAndSetState(0, acquires)) &#123;</div><div class="line">                    setExclusiveOwnerThread(current);</div><div class="line">                    return true;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            else if (current == getExclusiveOwnerThread()) &#123;  //判断</div><div class="line">                int nextc = c + acquires;</div><div class="line">                if (nextc &lt; 0) // overflow</div><div class="line">                    throw new Error(&quot;Maximum lock count exceeded&quot;);</div><div class="line">                setState(nextc);</div><div class="line">                return true;</div><div class="line">            &#125;</div><div class="line">            return false;</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p>
<p>该方法是Sync中的方法，NonfairSync通过重写tryAcquire()调用。<br>可以看到，该方法增加了一个判断：如果当前线程是已经获取锁的线程，那么将同步状态值State增加 <strong>（这里不需要CAS操作，因为该线程已经获取了锁，没有竞争——相当于偏向锁）</strong>，并返回true，表示同步状态获取成功。</p>
<p>非公平锁释放锁的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">protected final boolean tryRelease(int releases) &#123;</div><div class="line">            int c = getState() - releases;</div><div class="line">            if (Thread.currentThread() != getExclusiveOwnerThread())</div><div class="line">                throw new IllegalMonitorStateException();</div><div class="line">            boolean free = false;</div><div class="line">            if (c == 0) &#123;</div><div class="line">                free = true;</div><div class="line">                setExclusiveOwnerThread(null);</div><div class="line">            &#125;</div><div class="line">            setState(c);</div><div class="line">            return free;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>该方法也是由Sync实现。</p>
<p>既然获取锁的时候增加了同步状态值，那么释放时自然要减少。<br>可以看到，只有当State值减为0的时候，才返回true，表示释放锁成功，并将占有线程设置为null。</p>
<h4 id="公平锁的实现"><a href="#公平锁的实现" class="headerlink" title="公平锁的实现"></a>公平锁的实现</h4><p>公平锁获取锁的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">protected final boolean tryAcquire(int acquires) &#123;</div><div class="line">            final Thread current = Thread.currentThread();</div><div class="line">            int c = getState();</div><div class="line">            if (c == 0) &#123;</div><div class="line">                if (!hasQueuedPredecessors() &amp;&amp;</div><div class="line">                    compareAndSetState(0, acquires)) &#123;</div><div class="line">                    setExclusiveOwnerThread(current);</div><div class="line">                    return true;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            else if (current == getExclusiveOwnerThread()) &#123;</div><div class="line">                int nextc = c + acquires;</div><div class="line">                if (nextc &lt; 0)</div><div class="line">                    throw new Error(&quot;Maximum lock count exceeded&quot;);</div><div class="line">                setState(nextc);</div><div class="line">                return true;</div><div class="line">            &#125;</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>该方法是FairSync重写的tryAcquire()方法。<br>对比非公平锁的获取，<strong>唯一不同的是该方法在判断时增加了一个条件——hasQueuedPredecessors()方法，该方法判断同步队列中当前节点是否有前驱节点，如果有，表示有线程比当前线程更早请求，则需要等待前面的线程获取释放锁之后才能获取锁。</strong></p>
<p>公平锁释放锁的方法：  </p>
<p>同样也是调用Sync中的tryRelease()方法，这里不再赘述。</p>
<h4 id="公平锁与非公平锁的对比"><a href="#公平锁与非公平锁的对比" class="headerlink" title="公平锁与非公平锁的对比"></a>公平锁与非公平锁的对比</h4><p><strong>公平锁：</strong></p>
<ul>
<li>保证了锁的获取顺序，FIFO原则</li>
<li>不足是需要进行大量的线程切换</li>
</ul>
<p><strong>非公平锁</strong>：  </p>
<ul>
<li>保证了更大的吞吐量（极少的线程切换）</li>
<li>不足是可能造成线程“饥饿”（等待很久）</li>
</ul>
<p><strong>频繁的线程切换对性能有很大的影响，因此ReentrantLock的默认实现是非公平锁。</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、ReentrantLock概念&quot;&gt;&lt;a href=&quot;#一、ReentrantLock概念&quot; class=&quot;headerlink&quot; title=&quot;一、ReentrantLock概念&quot;&gt;&lt;/a&gt;一、ReentrantLock概念&lt;/h3&gt;&lt;h4 id=&quot;重入锁概念
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="ReentrantLock" scheme="http://yoursite.com/tags/ReentrantLock/"/>
    
      <category term="重入锁" scheme="http://yoursite.com/tags/%E9%87%8D%E5%85%A5%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>AQS共享锁的实现原理</title>
    <link href="http://yoursite.com/2017/10/19/AQS%E5%85%B1%E4%BA%AB%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2017/10/19/AQS共享锁的实现原理/</id>
    <published>2017-10-19T11:48:18.000Z</published>
    <updated>2017-10-23T13:55:46.632Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、AQS共享锁的实现原理"><a href="#一、AQS共享锁的实现原理" class="headerlink" title="一、AQS共享锁的实现原理"></a>一、AQS共享锁的实现原理</h3><p>前面的文章Lock的实现中分析了AQS独占锁的实现原理，那么接下来就分析下AQS是如何实现共享锁的。</p>
<h4 id="共享锁的介绍"><a href="#共享锁的介绍" class="headerlink" title="共享锁的介绍"></a>共享锁的介绍</h4><p><strong>共享锁：同一时刻有多个线程能够获取到同步状态。</strong></p>
<p>那么它是如何做到让多个线程获取到同步状态呢？<br>来看一下获取共享锁的过程：</p>
<ol>
<li>线程调用AQS的acquireShared()申请获取锁（可有多个线程获取到，根据重写的tryAcquireShared()方法决定），如果成功则进入临界区。</li>
<li>如果失败，创建一个共享型的节点进入FIFO等待队列，阻塞然后等待唤醒。</li>
<li>等待队列中的线程被唤醒重新尝试获取锁，<strong>获取成功后根据state变量值决定是否继续唤醒后续节点（如果state值为0，表示没有可用的锁，不唤醒后继节点；如果state的值&gt;0，表示有可用的锁，唤醒后继节点）</strong>，获取失败则继续等待，直到成功。</li>
</ol>
<p>释放共享锁的过程：</p>
<ol>
<li>线程调用releaseShared()进行锁资源释放，如果释放成功则唤醒队列中等待的节点（如果有）。</li>
</ol>
<h4 id="共享式获取锁"><a href="#共享式获取锁" class="headerlink" title="共享式获取锁"></a>共享式获取锁</h4><p>线程调用acquireShared()方法获取锁：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public final void acquireShared(int arg) &#123;</div><div class="line">        if (tryAcquireShared(arg) &lt; 0)</div><div class="line">            doAcquireShared(arg); //获取失败进入该方法</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>分析如下：</p>
<ul>
<li>当tryAcquireShared(arg)返回值&gt;=0时（可以在重写该方法时自定义锁的数量），表示获取锁成功，不会进入doAcquireShared。</li>
<li>当tryAcquireShared(arg)返回值&lt;0时,进入doAcquireShared(arg)方法，可以猜想这里应该是构造节点放入等待队列，看如下代码：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">private void doAcquireShared(int arg) &#123;</div><div class="line">        final Node node = addWaiter(Node.SHARED);  //构造等待队列，和独占锁类似</div><div class="line">        boolean failed = true;</div><div class="line">        try &#123;</div><div class="line">            boolean interrupted = false;</div><div class="line">            for (;;) &#123;       //自旋</div><div class="line">                final Node p = node.predecessor(); //获取前驱节点</div><div class="line">                if (p == head) &#123;</div><div class="line">                    int r = tryAcquireShared(arg); //再次尝试获取</div><div class="line">                    if (r &gt;= 0) &#123;</div><div class="line">                        setHeadAndPropagate(node, r);</div><div class="line">                        p.next = null; // help GC</div><div class="line">                        if (interrupted)</div><div class="line">                            selfInterrupt();</div><div class="line">                        failed = false;</div><div class="line">                        return;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div class="line">                    parkAndCheckInterrupt())</div><div class="line">                    interrupted = true;</div><div class="line">            &#125;</div><div class="line">        &#125; finally &#123;</div><div class="line">            if (failed)</div><div class="line">                cancelAcquire(node);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>可以看到，当前驱节点是头节点head时，线程尝试获取锁，此时注意返回值r，有以下三种可能：</p>
<ul>
<li>r<0，表示获取锁失败，继续自旋直到r>=0；</0，表示获取锁失败，继续自旋直到r></li>
<li>r=0，表示获取锁成功，但刚好是最后一把锁，不会唤醒后继节点，在setHeadAndPropagate(node, r)方法中可以体现出来，后面会分析到；</li>
<li>r&gt;0，表示获取锁成功，而且还有锁资源，会唤醒后继节点，同样在setHeadAndPropagate(node, r)方法中可以体现。  </li>
</ul>
<p>那么就来看一下setHeadAndPropagate(node, r)这个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">private void setHeadAndPropagate(Node node, int propagate) &#123;</div><div class="line">        Node h = head; // 记录原来的头节点</div><div class="line">        setHead(node);  // 将当前节点设置为头节点</div><div class="line">        if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 ||</div><div class="line">        (h = head) == null || h.waitStatus &lt; 0) &#123;</div><div class="line">            Node s = node.next;</div><div class="line">            if (s == null || s.isShared())</div><div class="line">                doReleaseShared();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>注意这里propagate的值就是上一个方法中的r，首先将当前节点设置为头节点，然后if中的判断表示以下两种情况需要执行唤醒操作：</p>
<ol>
<li>根据r的值判断，r&gt;0时，表示可以唤醒后继节点，执行doReleaseShared()方法；而当r=0时，不会直接执行doReleaseShared()方法，而是进入第二种情况继续判断；</li>
<li>头节点后面的节点需要被唤醒（waitStatus&lt;0），不论是老的头结点还是新的头结点</li>
</ol>
<p>接下来看看doReleaseShared()这个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">private void doReleaseShared() &#123;</div><div class="line">        for (;;) &#123; //自旋</div><div class="line">            Node h = head;</div><div class="line">            if (h != null &amp;&amp; h != tail) &#123;</div><div class="line">                int ws = h.waitStatus;</div><div class="line">                if (ws == Node.SIGNAL) &#123; //表示后继节点需要被唤醒</div><div class="line">                    if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))</div><div class="line">                        continue;            // loop to recheck cases</div><div class="line">                    unparkSuccessor(h); //唤醒</div><div class="line">                &#125;</div><div class="line">                else if (ws == 0 &amp;&amp;</div><div class="line">                         !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))</div><div class="line">                    continue;    //如果后继节点暂时不需要唤醒，则把当前节点状态设置为PROPAGATE确保以后可以传递下去</div><div class="line">            &#125;</div><div class="line">            if (h == head)                   // loop if head changed</div><div class="line">                break;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这里有两个入口可以进入该方法，一个是直接释放锁releaseShared()一个是上述setHeadAndPropagate()方法，因此在释放锁的过程中需要使用CAS操作保证线程安全。</p>
<ol>
<li>进入第一个if语句，表示后继节点需要被唤醒，采用CAS循环操作直到成功；</li>
<li>进入else if语句，表示暂时不需要唤醒，将状态传递；</li>
<li>最后判断头节点是否变化，没有变化则退出循环；如果头结点发生变化，比如说其他线程获取到了锁，为了使自己的唤醒动作可以传递，必须进行重试</li>
</ol>
<p>以上就是获取共享锁的大致过程。</p>
<h4 id="共享式释放锁"><a href="#共享式释放锁" class="headerlink" title="共享式释放锁"></a>共享式释放锁</h4><p>调用releaseShared()方法主动释放锁：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public final boolean releaseShared(int arg) &#123;</div><div class="line">        if (tryReleaseShared(arg)) &#123;</div><div class="line">            doReleaseShared();</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line">        return false;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>可以看到，当重写的tryReleaseShared(arg)方法返回true,成功释放锁资源，进入doReleaseShared()唤醒等待的线程，这个方法上面已经分析过，这里不再赘述。</p>
<h3 id="二、AQS共享锁与独占锁的对比"><a href="#二、AQS共享锁与独占锁的对比" class="headerlink" title="二、AQS共享锁与独占锁的对比"></a>二、AQS共享锁与独占锁的对比</h3><p>共享锁的实现稍比独占锁复杂，但大同小异。二者对比如下：</p>
<ul>
<li><strong>独占锁：</strong>  </li>
</ul>
<ol>
<li><p>独占锁是只有头节点获取锁，其余节点的线程继续等待，等待锁被释放后，才会唤醒下一个节点的线程；</p>
</li>
<li><p>同步状态state值在0和1之间切换，保证同一时间只能有一个线程是处于活动的，其他线程都被阻塞，参考ReentranLock。</p>
</li>
<li>独占锁是一种悲观锁。 </li>
</ol>
<ul>
<li><strong>共享锁：</strong>  </li>
</ul>
<ol>
<li>共享锁是只要头节点获取锁成功，就在唤醒自身节点对应的线程的同时，继续唤醒AQS队列中的下一个节点的线程，每个节点在唤醒自身的同时还会唤醒下一个节点对应的线程，以实现共享状态的“向后传播”，从而实现共享功能。</li>
<li>同步状态state值在整数区间内（自定义实现），如果state值&lt;0则阻塞，否则不阻塞。参考ReadWriteLock、Semphore、CountDownLautch等。</li>
<li>共享锁是一种乐观锁，允许多个线程同时访问共享资源。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、AQS共享锁的实现原理&quot;&gt;&lt;a href=&quot;#一、AQS共享锁的实现原理&quot; class=&quot;headerlink&quot; title=&quot;一、AQS共享锁的实现原理&quot;&gt;&lt;/a&gt;一、AQS共享锁的实现原理&lt;/h3&gt;&lt;p&gt;前面的文章Lock的实现中分析了AQS独占锁的实现原
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="AQS" scheme="http://yoursite.com/tags/AQS/"/>
    
      <category term="共享锁" scheme="http://yoursite.com/tags/%E5%85%B1%E4%BA%AB%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>Lock实现之AQS——AbstractQueuedSynchronizer</title>
    <link href="http://yoursite.com/2017/10/18/Lock%E5%AE%9E%E7%8E%B0%E4%B9%8BAQS%E2%80%94%E2%80%94AbstractQueuedSynchronizer/"/>
    <id>http://yoursite.com/2017/10/18/Lock实现之AQS——AbstractQueuedSynchronizer/</id>
    <published>2017-10-18T09:48:18.000Z</published>
    <updated>2017-10-18T11:30:17.136Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、AQS的介绍"><a href="#一、AQS的介绍" class="headerlink" title="一、AQS的介绍"></a>一、AQS的介绍</h3><p><strong>队列同步器AbstractQueuedSynchronizer（AQS）是构建锁或者其他同步组件的基础框架，是实现Lock的基础。它使用了一个volatile修饰的int变量来表示同步状态，并维护了一个FIFO队列来完成资源获取线程的排队。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public abstract class AbstractQueuedSynchronizer extends AbstractOwnableSynchronizer </div><div class="line">implements java.io.Serializable &#123;</div><div class="line"> </div><div class="line"> private transient volatile Node head;//头节点</div><div class="line"> private transient volatile Node tail;//尾节点</div><div class="line"> private volatile int state;          //同步状态</div><div class="line"> protected final int getState() &#123;</div><div class="line">      return state;</div><div class="line"> &#125;</div><div class="line">protected final void setState(int newState) &#123;</div><div class="line">    state = newState;</div><div class="line">&#125;</div><div class="line">protected final boolean compareAndSetState(int expect, int update) &#123;</div><div class="line">   return unsafe.compareAndSwapInt(this, stateOffset, expect, update);</div><div class="line">&#125;</div><div class="line">...</div></pre></td></tr></table></figure>
<p>从上面AQS的部分代码可以看到，AQS是一个类，它包含了表示同步状态的state变量（volatile修饰）；维护队列的两个引用头节点head和尾节点tail（volatile修饰）；以及提供了三个主要方法，用来保证同步状态的改变是线程安全的；省略了其他方法。</p>
<p>那么AQS是如何实现锁的呢？<br><strong>当我们需要实现锁的时候，首先继承AQS并重写指定的方法，然后将AQS子类组合在自定义组件（锁）的实现中，并调用AQS的模板方法，而这些模板方法将会调用我们重写的方法（模板方法模式）</strong>，这就可以达到我们想要的效果。<br><strong>注：重写指定的方法时需要用到AQS中的三个主要方法来对同步状态进行访问或修改。</strong></p>
<p>AQS中可重写的方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">protected boolean tryAcquire(int arg) &#123;&#125; //独占式获取</div><div class="line">protected boolean tryRelease(int arg) &#123;&#125; //独占式释放</div><div class="line">protected int tryAcquireShared(int arg) &#123;&#125; //共享式获取</div><div class="line">protected boolean tryReleaseShared(int arg) &#123;&#125; //共享式释放</div><div class="line">protected boolean isHeldExclusively() &#123;&#125; //判断AQS是否被该线程独占</div></pre></td></tr></table></figure></p>
<p>来看一个独占锁的示例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">class Mutex implements Lock, java.io.Serializable &#123;</div><div class="line">   // 内部类，自定义同步器，继承AQS</div><div class="line">   private static class Sync extends AbstractQueuedSynchronizer &#123;</div><div class="line">     // 重写方法——是否处于占用状态</div><div class="line">     protected boolean isHeldExclusively() &#123;</div><div class="line">       return getState() == 1;</div><div class="line">     &#125;</div><div class="line">     // 重写方法——当状态为0的时候获取锁</div><div class="line">     public boolean tryAcquire(int acquires) &#123;</div><div class="line">       assert acquires == 1; // Otherwise unused</div><div class="line">       if (compareAndSetState(0, 1)) &#123;</div><div class="line">         setExclusiveOwnerThread(Thread.currentThread());</div><div class="line">         return true;</div><div class="line">       &#125;</div><div class="line">       return false;</div><div class="line">     &#125;</div><div class="line">     // 重写方法——释放锁，将状态设置为0</div><div class="line">     protected boolean tryRelease(int releases) &#123;</div><div class="line">       assert releases == 1; // Otherwise unused</div><div class="line">       if (getState() == 0) throw new IllegalMonitorStateException();</div><div class="line">       setExclusiveOwnerThread(null);</div><div class="line">       setState(0);</div><div class="line">       return true;</div><div class="line">     &#125;</div><div class="line">     // 返回一个Condition，每个condition都包含了一个condition队列</div><div class="line">     Condition newCondition() &#123; return new ConditionObject(); &#125;</div><div class="line">   &#125;</div><div class="line">   // 仅需要将操作代理到Sync上即可</div><div class="line">   private final Sync sync = new Sync();</div><div class="line">   public void lock()                &#123; sync.acquire(1); &#125;</div><div class="line">   public boolean tryLock()          &#123; return sync.tryAcquire(1); &#125;</div><div class="line">   public void unlock()              &#123; sync.release(1); &#125;</div><div class="line">   public Condition newCondition()   &#123; return sync.newCondition(); &#125;</div><div class="line">   public boolean isLocked()         &#123; return sync.isHeldExclusively(); &#125;</div><div class="line">   public boolean hasQueuedThreads() &#123; return sync.hasQueuedThreads(); &#125;</div><div class="line">   public void lockInterruptibly() throws InterruptedException &#123;</div><div class="line">     sync.acquireInterruptibly(1);</div><div class="line">   &#125;</div><div class="line">   public boolean tryLock(long timeout, TimeUnit unit)</div><div class="line">       throws InterruptedException &#123;</div><div class="line">     return sync.tryAcquireNanos(1, unit.toNanos(timeout));</div><div class="line">   &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>以上就是利用AQS来实现一个独占锁的示例。<br>Mutex是一个自定义的Lock，它在同一时刻只允许一个线程占有锁。<strong>它定义了一个静态内部类继承自AQS，并重写了相应的方法，实现了独占式的获取释放锁。</strong><br>在重写的tryAcquire方法中，<strong>调用CAS方法改变同步状态，因为是原子操作只有一个线程能完成</strong>；在重写的tryRelease方法中将同步状态设为0。<br>在使用这个Lock时，我们只要调用Mutex的方法，有关同步的细节都由同步器完成。大大降低了自定义并发组件的门槛。</p>
<h3 id="二、AQS的实现原理分析"><a href="#二、AQS的实现原理分析" class="headerlink" title="二、AQS的实现原理分析"></a>二、AQS的实现原理分析</h3><p>知道了AQS的用法，那么就来分析下它的实现原理。<br><strong>同步器可分为独占式和共享式。</strong> 一般只实现其中一种。这里主要分析独占锁的实现。</p>
<h4 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h4><p>AQS是依靠内部的同步队列来完成同步状态的管理，当前线程获取同步状态失败时，会将当前线程以及等待状态等信息构造成一个节点（node）加入同步队列，并阻塞当前线程。当同步状态释放时，会把首节点中的线程唤醒，使其尝试获取同步状态。</p>
<h5 id="Node类"><a href="#Node类" class="headerlink" title="Node类"></a>Node类</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">static final class Node &#123;</div><div class="line">        static final Node SHARED = new Node();</div><div class="line">        static final Node EXCLUSIVE = null;</div><div class="line">        static final int CANCELLED =  1;</div><div class="line">        static final int SIGNAL    = -1;</div><div class="line">        static final int CONDITION = -2;</div><div class="line">        static final int PROPAGATE = -3;</div><div class="line">        volatile int waitStatus; //线程的等待状态（上述）</div><div class="line">        volatile Node prev; //前驱节点</div><div class="line">        volatile Node next; //后继节点</div><div class="line">        volatile Thread thread; //线程引用</div><div class="line">        Node nextWaiter; //等待队列中的后继节点</div><div class="line">        ...</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>Node是AQS维护的静态内部类。用来保存线程引用（失败）、等待状态和前后节点。<br>节点是构成同步队列的基础，同步器拥有首节点（head）和尾节点（tail），获取同步状态失败的线程会成为节点加入队列的尾部。同步器结构如下：<br><img src="http://osuskkx7k.bkt.clouddn.com/AQS2.png?imageView2/2/w/500/h/300" alt="image"></p>
<p><strong>注：构造节点的过程必须保证线程安全，因为会有多个线程失败。那么它是如何做到的？AQS提供了一个基于CAS的构造尾节点的方法compareAndSetTail，它可以保证节点被正确地加入到队列中。</strong></p>
<h4 id="独占式获取锁"><a href="#独占式获取锁" class="headerlink" title="独占式获取锁"></a>独占式获取锁</h4><p>来看一看获取锁的流程。<br>调用AQS的acquire（int args）方法获取同步状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public final void acquire(int arg) &#123;</div><div class="line">    if (!tryAcquire(arg) &amp;&amp;acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</div><div class="line">            selfInterrupt();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><strong>&amp;&amp;：</strong> 短路与，当第一个为false时不再判断后面条件；第一个为true时还会判断第二个条件；<br><strong>&amp;:</strong>     当第一个为false时，还会判断后面的条件；</p>
<ul>
<li>当成功获取锁，即tryAcquire(arg)为true时，!tryAcquire(arg) 为false，跳出if，此时执行selfInterrupt()；</li>
<li>当没有成功获取锁，即tryAcquire(arg)为false时，!tryAcquire(arg) 为true时，接着判断第二个条件，两个步骤： </li>
</ul>
<p>步骤一：  addWaiter(Node.EXCLUSIVE)：将该节点加入同步队列的尾部,返回该节点；<br>步骤二： acquireQueued(Node node, arg))：使该节点以”死循环”的方式获取同步状态；若获取不到则阻塞节点中的线程，被阻塞的线程的唤醒主要依靠前驱节点的出队或阻塞线程被中断来实现。</p>
<p><strong>分析步骤一：addWaiter方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">private Node addWaiter(Node mode) &#123;</div><div class="line">        Node node = new Node(Thread.currentThread(), mode);</div><div class="line">        Node pred = tail;</div><div class="line">        if (pred != null) &#123; //如果有尾节点，快速尝试在尾部添加，减少开销</div><div class="line">            node.prev = pred;</div><div class="line">            if (compareAndSetTail(pred, node)) &#123;</div><div class="line">                pred.next = node;</div><div class="line">                return node;                  //如果已经有尾节点，利用CAS将自己添加为尾节点之后返回</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        enq(node);          //如果没有尾节点，那么进入enq方法</div><div class="line">        return node;</div><div class="line">    &#125;</div><div class="line">private Node enq(final Node node) &#123;</div><div class="line">        for (;;) &#123;</div><div class="line">            Node t = tail;</div><div class="line">            if (t == null) &#123;        </div><div class="line">                if (compareAndSetHead(new Node()))    //初始化头节点</div><div class="line">                    tail = head;</div><div class="line">            &#125; else &#123;</div><div class="line">                node.prev = t;</div><div class="line">                if (compareAndSetTail(t, node)) &#123;   //CAS添加node为尾节点</div><div class="line">                    t.next = node;</div><div class="line">                    return t;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>可以看到，若队列还未生成即没有尾节点，则进入enq方法中，先创造一个头节点，然后通过死循环<strong>for(;;)</strong> 来保证节点的正确添加，再通过<strong>compareAndSetTail（CAS）</strong> 这个方法确保节点能够被线程安全地添加（可以想象多个线程获取同步失败后，如果不保证线程安全添加，将导致顺序混乱，可能丢失线程），只有从CAS返回后，线程才能返回，否则将不断尝试。<br>这个enq方法将并发的添加节点的请求通过CAS变得串行化了。</p>
<p><strong>分析步骤二：acquireQueued方法</strong><br>节点进入同步队列后，就进入了一个自旋的过程，每个节点（或线程）都在自省的观察，当获取到同步状态就可以从自旋中退出，否则依旧自旋。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">final boolean acquireQueued(final Node node, int arg) &#123;</div><div class="line">        boolean failed = true;</div><div class="line">        try &#123;</div><div class="line">            boolean interrupted = false;</div><div class="line">            for (;;) &#123;</div><div class="line">                final Node p = node.predecessor();     //获得前驱节点</div><div class="line">                if (p == head &amp;&amp; tryAcquire(arg)) &#123;  //只有前驱节点是头节点才尝试获取锁，false直接跳出if</div><div class="line">                    setHead(node);        //获取成功，将自己设置为头节点</div><div class="line">                    p.next = null;           // help GC</div><div class="line">                    failed = false;</div><div class="line">                    return interrupted;       //返回false，回到acquire方法中，不执行selfInterrupt();</div><div class="line">                &#125;</div><div class="line">                if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div class="line">                    parkAndCheckInterrupt())</div><div class="line">                    interrupted = true;</div><div class="line">            &#125;</div><div class="line">        &#125; finally &#123;</div><div class="line">            if (failed)</div><div class="line">                cancelAcquire(node);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">private void setHead(Node node) &#123;</div><div class="line">        head = node;</div><div class="line">        node.thread = null;</div><div class="line">        node.prev = null;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这段代码主要做了2件事：</p>
<ol>
<li><p>判断当前节点的前驱节点是否为头节点并尝试tryAcquire，只有当前驱节点是head的节点才会尝试tryAcquire，如果节点尝试tryAcquire成功，执行setHead方法将当前节点作为head、将当前节点中的thread设置为null、将当前节点的prev设置为null，这保证了链表中头结点永远是一个不带Thread的空节点；</p>
</li>
<li><p>如果当前节点的前驱节点不是头节点或者tryAcquire失败，那么执行第13行~第15行的代码，做了两步操作，首先判断在acquie失败后是否应该park（阻塞），其次park并检查中断状态；  </p>
</li>
</ol>
<p>分析下第2件事：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123;</div><div class="line">        int ws = pred.waitStatus;</div><div class="line">        if (ws == Node.SIGNAL)     //ws=SIGNAL= -1</div><div class="line">            return true;</div><div class="line">        if (ws &gt; 0) &#123;             //ws=CANCELLED= 1</div><div class="line">            do &#123;</div><div class="line">                node.prev = pred = pred.prev;</div><div class="line">            &#125; while (pred.waitStatus &gt; 0);</div><div class="line">            pred.next = node;</div><div class="line">        &#125; else &#123;                 //ws=CONDITION= -2 or PROPAGATE= -3</div><div class="line">            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</div><div class="line">        &#125;</div><div class="line">        return false;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>­这个方法做了以下工作，<br>­每个节点判断它前驱节点的状态：  </p>
<ol>
<li>它的前驱节点是SIGNAL状态的，返回true，表示当前节点应当park(阻塞)，执行parkAndCheckInterrupt()，­该方法利用LockSupport的park方法让当前线程阻塞，如下。 </li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">private final boolean parkAndCheckInterrupt() &#123;</div><div class="line">        LockSupport.park(this);</div><div class="line">        return Thread.interrupted();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ol>
<li>它的前驱节点的waitStatus&gt;0，即CANCELLED，那么CANCELLED的节点作废，当前节点不断向前找并重新连接为双向队列，直到找到一个前驱节点的waitStats不是CANCELLED的为止。</li>
<li>它的前驱节点不是SIGNAL状态且waitStatus&lt;=0，即CONDITION或PROPAGATE，此时执行第11行代码，利用CAS机制，将前驱节点的状态更新为SIGNAL状态。</li>
</ol>
<hr>
<h4 id="独占式释放锁"><a href="#独占式释放锁" class="headerlink" title="独占式释放锁"></a>独占式释放锁</h4><p>调用AQS的release方法可以释放同步状态，唤醒后继节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public final boolean release(int arg) &#123;</div><div class="line">        if (tryRelease(arg)) &#123;       </div><div class="line">            Node h = head;</div><div class="line">            if (h != null &amp;&amp; h.waitStatus != 0)</div><div class="line">                unparkSuccessor(h);  //调用LockSupport来唤醒处于等待状态的线程</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line">        return false;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>tryRelease释放成功，获取到head节点，如果head节点的waitStatus不为0的话，执行unparkSuccessor方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">private void unparkSuccessor(Node node) &#123;</div><div class="line">        int ws = node.waitStatus;</div><div class="line">        if (ws &lt; 0)</div><div class="line">            compareAndSetWaitStatus(node, ws, 0);</div><div class="line">        Node s = node.next;</div><div class="line">        if (s == null || s.waitStatus &gt; 0) &#123;</div><div class="line">            s = null;</div><div class="line">            for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)</div><div class="line">                if (t.waitStatus &lt;= 0)</div><div class="line">                    s = t;</div><div class="line">        &#125;</div><div class="line">        if (s != null)</div><div class="line">            LockSupport.unpark(s.thread);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这个方法做了以下工作：  </p>
<ol>
<li>头节点的waitStatus&lt;0，将头节点的waitStatus设置为0；</li>
<li>拿到头节点的下一个节点s，如果s==null或者s的waitStatus&gt;0（被取消了），那么从队列尾巴开始向前寻找一个waitStatus&lt;=0的节点作为后继要唤醒的节点；</li>
<li>如果拿到了一个不等于null的节点s，就利用LockSupport的unpark方法让它取消阻塞。<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4>获取同步状态时，AQS维护一个同步队列，获取状态失败的线程都会加入到队列中并在队列中进行自旋；移出队列的条件是前驱节点为头节点且获取同步状态成功。<br>释放同步状态时，头节点唤醒它的后继节点。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、AQS的介绍&quot;&gt;&lt;a href=&quot;#一、AQS的介绍&quot; class=&quot;headerlink&quot; title=&quot;一、AQS的介绍&quot;&gt;&lt;/a&gt;一、AQS的介绍&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;队列同步器AbstractQueuedSynchronizer（AQS）是构
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="AQS" scheme="http://yoursite.com/tags/AQS/"/>
    
      <category term="Lock" scheme="http://yoursite.com/tags/Lock/"/>
    
  </entry>
  
  <entry>
    <title>Lock接口的介绍及使用</title>
    <link href="http://yoursite.com/2017/10/17/Lock%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%8F%8A%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2017/10/17/Lock接口的介绍及使用/</id>
    <published>2017-10-17T13:40:19.000Z</published>
    <updated>2017-10-18T11:30:07.979Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、Lock的介绍"><a href="#一、Lock的介绍" class="headerlink" title="一、Lock的介绍"></a>一、Lock的介绍</h3><p>我们知道，在Java中锁的实现可以由synchronized关键字来完成，但在Java5之后，出现了一种新的方式来实现——Lock接口。</p>
<p>那么为什么提出这种新的方式呢？<br>在多线程的情况下，当一段代码被synchronized修饰之后，同一时刻只能被一个线程访问，其他线程都必须等到该线程释放锁之后才能有机会获取锁访问这段代码，占用锁的线程只有在两种情况下才能释放锁：  </p>
<ol>
<li>线程执行完了这段代码，释放锁；</li>
<li>线程执行发生异常，释放锁；  </li>
</ol>
<p>考虑一下，如果该线程由于IO操作或者其他原因（调用Sleep方法）被阻塞了，那么其他线程就会一直无期限地等待下去，后果可想而知。<br>那么能否用一种方式来防止等待的线程无限等待呢？（等待一段时间或者响应中断）通过Lock就可以实现。</p>
<p>再如：当用多线程对文件进行读写时，读与写是互斥的，写与写是互斥的，但读与读却不是互斥的。如果用synchronized来实现同步，就会有这样的问题：多个线程都只需要读操作，但只能有一个线程进行读操作，其他线程只能等待。<br>那么能不能让线程不用等待，多线程都能进行读操作呢？通过Lock就可以实现。</p>
<h3 id="二、Lock的用法"><a href="#二、Lock的用法" class="headerlink" title="二、Lock的用法"></a>二、Lock的用法</h3><p>Lock是一个接口，包含以下方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public interface Lock &#123;</div><div class="line">void lock();      //获取锁</div><div class="line">void lockInterruptibly() throws InterruptedException; //可中断的获取锁</div><div class="line">boolean tryLock(); //尝试非阻塞的获取锁</div><div class="line">boolean tryLock(long time, TimeUnit unit) throws InterruptedException; //超时获取锁</div><div class="line">void unlock(); //释放锁</div><div class="line">Condition newCondition(); //获取等待通知组件，和当前的锁绑定</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到当使用Lock时，获取锁和释放锁都是主动调用执行的，而synchronized则是系统自动释放锁的。<br>前四个方法都是用来获取锁的，但各有区别：  </p>
<ul>
<li><strong>lock()</strong>：是最常用的获取锁的方法，若锁被其他线程获取，则等待（阻塞）。</li>
<li><strong>tryLock()</strong>：尝试非阻塞地获取锁，立即返回。获取成功返回true；获取失败返回false，但不会阻塞。</li>
<li><strong>tryLock(long time, TimeUnit unit)</strong>：与tryLock()相似，但是会超时等待一段时间，如果未获取到返回false。</li>
<li><strong>lockInterruptibly()</strong>：可中断地获取锁，该方法会响应中断，在锁的获取过程中可以中断当前线程。  </li>
</ul>
<p><strong>注：当使用synchronized关键字时，一个线程在等待获取锁的过程中是无法中断的。而使用lockInterruptibly()方法获取某个锁时，如果不能获取到，在进行等待的情况下是可以响应中断的。</strong></p>
<p>Lock的使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Lock lock = new ReentrantLock(); //可重入锁（Lock的一种实现）</div><div class="line">lock.lock();</div><div class="line">try&#123;</div><div class="line">    dosomething();</div><div class="line">&#125;finally&#123;</div><div class="line">    lock.unlock();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>在finally块中释放锁的目的是保证获取锁之后，最终能被释放。</strong><br>不要将获取锁——lock()放在try中，如果在获取锁时发生了异常，异常抛出的同时，也会导致锁的无故释放（需要主动释放）。</p>
<h3 id="三、与synchronized的区别"><a href="#三、与synchronized的区别" class="headerlink" title="三、与synchronized的区别"></a>三、与synchronized的区别</h3><p>Lock与synchronized的区别：  </p>
<ol>
<li>Lock是一个接口，是代码层面的实现；synchronized是关键字，是内置的语言实现（JVM层面）。</li>
<li>Lock是显示地获取释放锁，扩展性更强；synchronized是隐式地获取释放锁，更简捷。</li>
<li>Lock在发生异常时，如果没有主动通过unlock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生。</li>
<li>Lock可以让等待锁的线程响应中断；而使用synchronized时等待锁的线程会一直等待下去，不能响应中断；</li>
<li>Lock可以尝试非阻塞、可中断、超时地获取锁；synchronized不可以。</li>
<li>Lock可以知道是否成功获取锁；synchronized无法知道。  </li>
</ol>
<p>总结：在资源竞争不是很激烈的情况下，Synchronized的性能要优于Lock；但是在资源竞争很激烈的情况下，Synchronized的性能会下降几十倍，Lock的性能更优；</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、Lock的介绍&quot;&gt;&lt;a href=&quot;#一、Lock的介绍&quot; class=&quot;headerlink&quot; title=&quot;一、Lock的介绍&quot;&gt;&lt;/a&gt;一、Lock的介绍&lt;/h3&gt;&lt;p&gt;我们知道，在Java中锁的实现可以由synchronized关键字来完成，但在Jav
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="Lock" scheme="http://yoursite.com/tags/Lock/"/>
    
  </entry>
  
  <entry>
    <title>深入理解synchronized关键字</title>
    <link href="http://yoursite.com/2017/10/14/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3synchronized/"/>
    <id>http://yoursite.com/2017/10/14/深入理解synchronized/</id>
    <published>2017-10-14T09:30:15.000Z</published>
    <updated>2017-10-14T09:54:51.785Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、synchronized的基本介绍"><a href="#一、synchronized的基本介绍" class="headerlink" title="一、synchronized的基本介绍"></a>一、synchronized的基本介绍</h2><p>谈到synchronized关键字，想必大家都不陌生，对它的初次印象如果用两个字来概括，无非就是 <strong>“同步”</strong> 。小小的一个词，蕴含了大道理，那么就让我们来探索一下。  </p>
<h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><p><strong>synchronized实现同步的基础是：java中的任何一个对象都可以作为锁。</strong>  </p>
<p>它有三种用法：  </p>
<p> <strong>1. 修饰普通同步方法，锁是当前实例对象</strong>  </p>
<p><strong>2. 修饰静态同步方法，锁是当前类的class对象（唯一）</strong></p>
<p><strong>3. 修饰同步代码块，锁是括号中的对象</strong>  </p>
<h3 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h3><p>来看以下几段代码<br>（1）不使用synchronized<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">public class SynTest &#123;</div><div class="line">	</div><div class="line">	public void method1()&#123;</div><div class="line">		System.out.println(&quot;method 1 start&quot;);</div><div class="line">		try &#123;</div><div class="line">			System.out.println(&quot;method 1 execute&quot;);</div><div class="line">			Thread.sleep(2000);</div><div class="line">		&#125; catch (InterruptedException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		System.out.println(&quot;method 1 end&quot;);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public void method2()&#123;</div><div class="line">		System.out.println(&quot;method 2 start&quot;);</div><div class="line">		try &#123;</div><div class="line">			System.out.println(&quot;method 2 execute&quot;);</div><div class="line">			Thread.sleep(1000);</div><div class="line">		&#125; catch (InterruptedException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		System.out.println(&quot;method 2 end&quot;);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		SynTest test = new SynTest();</div><div class="line">		//线程1---method1</div><div class="line">		new Thread(new Runnable() &#123;</div><div class="line">			@Override</div><div class="line">			public void run() &#123;</div><div class="line">				test.method1();</div><div class="line">			&#125;</div><div class="line">		&#125;).start();</div><div class="line">		//线程2---method2</div><div class="line">		new Thread(new Runnable() &#123;</div><div class="line">			@Override</div><div class="line">			public void run() &#123;</div><div class="line">				test.method2();</div><div class="line">			&#125;</div><div class="line">		&#125;).start();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">method 1 start</div><div class="line">method 2 start</div><div class="line">method 2 execute</div><div class="line">method 1 execute</div><div class="line">method 2 end</div><div class="line">method 1 end</div></pre></td></tr></table></figure>
<p>可以看出，在不加synchronized修饰时，两个线程同时执行，互不冲突，线程2比线程1执行的快，因此先执行完毕。<br>（2）synchronized修饰普通方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">public class SynTest &#123;</div><div class="line">	</div><div class="line">	public synchronized void  method1()&#123;</div><div class="line">		System.out.println(&quot;method 1 start&quot;);</div><div class="line">		</div><div class="line">		try &#123;</div><div class="line">			System.out.println(&quot;method 1 execute&quot;);</div><div class="line">			Thread.sleep(2000);</div><div class="line">		&#125; catch (InterruptedException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		System.out.println(&quot;method 1 end&quot;);</div><div class="line">	&#125;</div><div class="line">	public synchronized void method2()&#123;</div><div class="line">		System.out.println(&quot;method 2 start&quot;);</div><div class="line">		</div><div class="line">		try &#123;</div><div class="line">			System.out.println(&quot;method 2 execute&quot;);</div><div class="line">			Thread.sleep(1000);</div><div class="line">		&#125; catch (InterruptedException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		System.out.println(&quot;method 2 end&quot;);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		SynTest test = new SynTest();</div><div class="line">		//线程1---method1</div><div class="line">		new Thread(new Runnable() &#123;</div><div class="line">			@Override</div><div class="line">			public void run() &#123;</div><div class="line">				test.method1();</div><div class="line">			&#125;</div><div class="line">		&#125;).start();</div><div class="line">		//线程2---method2</div><div class="line">		new Thread(new Runnable() &#123;</div><div class="line">			@Override</div><div class="line">			public void run() &#123;</div><div class="line">				test.method2();</div><div class="line">			&#125;</div><div class="line">		&#125;).start();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">method 1 start</div><div class="line">method 1 execute</div><div class="line">method 1 end</div><div class="line">method 2 start</div><div class="line">method 2 execute</div><div class="line">method 2 end</div></pre></td></tr></table></figure>
<p>可以看出，线程2在线程1执行完成后才开始执行，达到了同步的效果。<strong>这是因为两个线程需要获取同一把锁（即test对象）</strong>，线程1先拿到锁，线程2只能等待直到线程1释放锁，才能执行。<br>（3）synchronized修饰静态方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">public class SynTest &#123;</div><div class="line">	</div><div class="line">	public static synchronized void  method1()&#123;</div><div class="line">		System.out.println(&quot;method 1 start&quot;);</div><div class="line">		</div><div class="line">		try &#123;</div><div class="line">			System.out.println(&quot;method 1 execute&quot;);</div><div class="line">			Thread.sleep(2000);</div><div class="line">		&#125; catch (InterruptedException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		System.out.println(&quot;method 1 end&quot;);</div><div class="line">	&#125;</div><div class="line">	public static synchronized void method2()&#123;</div><div class="line">		System.out.println(&quot;method 2 start&quot;);</div><div class="line">		</div><div class="line">		try &#123;</div><div class="line">			System.out.println(&quot;method 2 execute&quot;);</div><div class="line">			Thread.sleep(1000);</div><div class="line">		&#125; catch (InterruptedException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		System.out.println(&quot;method 2 end&quot;);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		SynTest test = new SynTest();</div><div class="line">		SynTest test2 = new SynTest();</div><div class="line">		//线程1---method1</div><div class="line">		new Thread(new Runnable() &#123;</div><div class="line">			@Override</div><div class="line">			public void run() &#123;</div><div class="line">				test.method1();</div><div class="line">			&#125;</div><div class="line">		&#125;).start();</div><div class="line">		//线程2---method2</div><div class="line">		new Thread(new Runnable() &#123;</div><div class="line">			@Override</div><div class="line">			public void run() &#123;</div><div class="line">				test2.method2();</div><div class="line">			&#125;</div><div class="line">		&#125;).start();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">method 1 start</div><div class="line">method 1 execute</div><div class="line">method 1 end</div><div class="line">method 2 start</div><div class="line">method 2 execute</div><div class="line">method 2 end</div></pre></td></tr></table></figure>
<p>可以看出，两个线程同样获得了同步的效果。但是明明是两个不同的对象（test、test2）所调用的，这是为什么？<br><strong>在这里synchronized修饰的是静态方法，而静态方法本质上是类的方法，因此这里的同步本质上是对类（Class对象）的同步</strong>，test、test2都是属于类的实例对象，所以也会同步执行，不能并发执行。<br><strong>注：每个类只有一个Class对象。</strong><br>（4）synchronized修饰同步块</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">public class SynTest &#123;</div><div class="line">	</div><div class="line">	public  void  method1()&#123;</div><div class="line">		synchronized(this)&#123;</div><div class="line">		System.out.println(&quot;method 1 start&quot;);</div><div class="line">		try &#123;</div><div class="line">			System.out.println(&quot;method 1 execute&quot;);</div><div class="line">			Thread.sleep(2000);</div><div class="line">		&#125; catch (InterruptedException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		System.out.println(&quot;method 1 end&quot;);&#125;</div><div class="line">	&#125;</div><div class="line">	public void method2()&#123;</div><div class="line">		synchronized(this)&#123;</div><div class="line">		System.out.println(&quot;method 2 start&quot;);</div><div class="line">		</div><div class="line">		try &#123;</div><div class="line">			System.out.println(&quot;method 2 execute&quot;);</div><div class="line">			Thread.sleep(1000);</div><div class="line">		&#125; catch (InterruptedException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		System.out.println(&quot;method 2 end&quot;);&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		SynTest test = new SynTest();</div><div class="line">		//线程1---method1</div><div class="line">		new Thread(new Runnable() &#123;</div><div class="line">			@Override</div><div class="line">			public void run() &#123;</div><div class="line">				test.method1();</div><div class="line">			&#125;</div><div class="line">		&#125;).start();</div><div class="line">		//线程2---method2</div><div class="line">		new Thread(new Runnable() &#123;</div><div class="line">			@Override</div><div class="line">			public void run() &#123;</div><div class="line">				test.method2();</div><div class="line">			&#125;</div><div class="line">		&#125;).start();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">method 1 start</div><div class="line">method 1 execute</div><div class="line">method 1 end</div><div class="line">method 2 start</div><div class="line">method 2 execute</div><div class="line">method 2 end</div></pre></td></tr></table></figure>
<p>可以看到，两个线程获得了同步的效果。<strong>两个线程的锁都是synchronized同步块括号中的this对象，即当前对象（test）</strong>。</p>
<h2 id="二、synchronized的实现原理"><a href="#二、synchronized的实现原理" class="headerlink" title="二、synchronized的实现原理"></a>二、synchronized的实现原理</h2><h3 id="2-1-实现原理"><a href="#2-1-实现原理" class="headerlink" title="2.1 实现原理"></a>2.1 实现原理</h3><p><strong>JVM基于进入和退出Monitor对象来实现方法同步和代码块同步。</strong> 但两者的实现细节不一样。</p>
<h4 id="1-代码块同步"><a href="#1-代码块同步" class="headerlink" title="1. 代码块同步"></a>1. 代码块同步</h4><p><strong>代码块同步是使用monitorenter和monitorexit指令（字节码指令）来完成。</strong><br>monitorenter指令是在编译后插入到同步代码块的开始位置，monitorexit指令插入到方法结束处和异常处，JVM保证每一个monitorenter都有一个monitorexit与之相对应。任何对象都有一个monitor与之相关联，当且一个monitor被持有之后，它将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor所有权，即尝试获取对象的锁； </p>
<h4 id="2-方法同步"><a href="#2-方法同步" class="headerlink" title="2. 方法同步"></a>2. 方法同步</h4><p><strong>方法同步是根据方法上的ACC_SYNCHRONIZED标识符（不是字节码指令）来实现的。</strong> 它没有通过指令monitorenter和monitorexit来完成（也可以通过它完成）。<br>反编译可以发现，相比普通方法，常量池中多了ACC_SYNCHRONIZED标示符。JVM就是根据该标示符来实现方法的同步的：当方法调用时，调用指令将会检查方法的ACC_SYNCHRONIZED访问标志是否被设置，如果设置了，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完后再释放monitor。在方法执行期间，其他任何线程都无法再获得同一个monitor对象。</p>
<p><strong>总结：</strong> 二者其实本质上没有区别，只是方法的同步是一种隐式的方式来实现，无需通过字节码指令来完成。</p>
<h3 id="2-2-对象头"><a href="#2-2-对象头" class="headerlink" title="2.2 对象头"></a>2.2 对象头</h3><p>synchronized用的锁是存在java对象头里的。<br>要了解对象头，先看看对象在内存中（<strong>java堆</strong>）的分布。分为三部分：对象头，实例数据，和对齐填充。（如下图）<br><img src="http://osuskkx7k.bkt.clouddn.com/%E5%AF%B9%E8%B1%A1%E5%A4%B421.PNG?imageView2/2/w/500/h/600" alt="image"></p>
<p>从图上可以看到，对象头由2个字存储（若是数组对象则为3个字，多一个存储数组长度）。<br>对象头主要包括以下两部分数据（还有一个Fields）：<br><img src="http://osuskkx7k.bkt.clouddn.com/%E5%AF%B9%E8%B1%A1%E5%A4%B422.PNG?imageView2/2/w/400/h/500" alt="image"><br><strong>Mark Word（标记字段）：</strong> 用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等等。<br><strong>Klass Pointer（类型指针）：</strong> 指向对象的类元数据，虚拟机通过这个指针来确定这个对象是哪个类的实例。<br>当对象头处于无锁状态时，它的Mark Word存储结构如下：</p>
<table>
<thead>
<tr>
<th>锁状态</th>
<th>25bit</th>
<th>4bit</th>
<th>1bit是否是偏向锁</th>
<th>2bit锁标志位</th>
</tr>
</thead>
<tbody>
<tr>
<td>&#160;无锁状态</td>
<td>对象的hashCode</td>
<td>对象分代年龄</td>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160;0</td>
<td>&#160;&#160;&#160;01</td>
</tr>
</tbody>
</table>
<p><strong>注：在运行期间，Mark Word里的存储数据会随着锁标志位的变化而变化。</strong></p>
<h2 id="三、锁的优化和对比"><a href="#三、锁的优化和对比" class="headerlink" title="三、锁的优化和对比"></a>三、锁的优化和对比</h2><p>jdk1.6之后对synchronized的实现进行了优化，来减少锁操作的开销。<br>因此锁出现了以下四种状态 <strong>：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态。</strong><br>它们并不是一成不变的状态，而是会通过互相竞争而升级，但是为了提高获得锁和释放锁的效率，它们只能升级不能降级。  升级顺序如下：<br>无锁 –&gt; 偏向锁 –&gt; 轻量级 –&gt; 重量级</p>
<h3 id="3-1-偏向锁"><a href="#3-1-偏向锁" class="headerlink" title="3.1 偏向锁"></a>3.1 偏向锁</h3><p>背景：大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让获取锁的代价降低而引入了偏向锁。<strong>偏向锁主要为了解决在没有竞争情况下锁的性能问题。</strong></p>
<h4 id="1-偏向锁的加锁"><a href="#1-偏向锁的加锁" class="headerlink" title="1. 偏向锁的加锁"></a>1. 偏向锁的加锁</h4><p>主要步骤如下：<br>（1）检测对象头Mark Word中的状态是否为偏向锁状态：<br>若是偏向锁状态（偏向锁标志为1，锁标志位01）执行步骤（2）；<br>若是无锁状态（偏向锁标志关闭，锁标志位01），那么线程在执行同步块之前，JVM会现在当前线程的栈帧中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，并存储锁偏向的线程ID（当前线程）；<br>（2）是偏向锁状态，则测试线程ID是否为当前线程ID，如果是则执行步骤（5），否则执行步骤（3）；<br>（3）线程ID不为当前线程ID，则通过CAS操作竞争锁，竞争成功，则将Mark Word的线程ID替换为当前线程ID，否则执行步骤（4）；<br>（4）通过CAS操作竞争锁失败，证明当前存在多线程竞争的情况，当到达全局安全点，获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码块；<br>（5）执行同步代码块</p>
<h4 id="2-偏向锁的解锁"><a href="#2-偏向锁的解锁" class="headerlink" title="2. 偏向锁的解锁"></a>2. 偏向锁的解锁</h4><p>偏向锁的释放采用了一种只有竞争才会释放锁的机制，线程是不会主动去释放偏向锁，需要等待其他线程来竞争。偏向锁的撤销需要等待全局安全点，此时没有正在执行的字节码。步骤如下：<br>（1）首先暂停持有偏向锁的线程，然后检查该线程是否活着：<br>没有活着：将对象头设置成无锁状态；<br>（2）活着：要么重新偏向于其他线程；要么恢复到无锁或升级为轻量锁；<br>（3）最后唤醒暂停的线程</p>
<h4 id="3-偏向锁的关闭"><a href="#3-偏向锁的关闭" class="headerlink" title="3. 偏向锁的关闭"></a>3. 偏向锁的关闭</h4><p>偏向锁默认开启，JVM参数关闭延迟：-XX：BiasedLockingStartupDelay=0。<br>如果确定应用程序里所有的锁通常都处于竞争状态下，通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，那么程序会默认进入轻量级锁状态。</p>
<h3 id="3-2-轻量级锁"><a href="#3-2-轻量级锁" class="headerlink" title="3.2 轻量级锁"></a>3.2 轻量级锁</h3><p>背景：<strong>“对于绝大部分的锁，在整个同步周期内都是不存在竞争的”</strong>，这是一个经验数据，也是轻量级锁能提升程序同步性能的依据。<strong>轻量级锁所适应的场景是线程交替执行同步块的情况。</strong></p>
<h4 id="1-轻量级锁的加锁"><a href="#1-轻量级锁的加锁" class="headerlink" title="1. 轻量级锁的加锁"></a>1. 轻量级锁的加锁</h4><p>当关闭偏向锁功能或偏向锁升级为轻量级锁时，会尝试去获取轻量级锁。主要步骤如下：<br>（1）检测对象头Mark Word中的状态是否为无锁状态：若是无锁状态（偏向锁标志关闭，锁标志位01）执行步骤（2）；否则步骤（4）<br>（2）若是无锁状态，将对象头中的Mark Word复制到锁记录中（在执行同步块之前，JVM会先在当前线程的栈帧中创建用于存储锁记录的空间）；<br>（3）通过CAS将Mark Word替换为指向锁记录的指针：如果成功表示竞争到锁，执行同步代码；如果失败执行步骤（4）；<br>（4）判断当前对象的Mark Word是否指向当前线程的栈帧，如果是则表示当前线程已经持有当前对象的锁，则直接执行同步代码块；否则只能说明该锁对象已经被其他线程抢占了，这时轻量级锁需要膨胀为重量级锁，锁标志位变成10，后面等待的线程将会进入阻塞状态；</p>
<h4 id="2-轻量级锁的解锁"><a href="#2-轻量级锁的解锁" class="headerlink" title="2. 轻量级锁的解锁"></a>2. 轻量级锁的解锁</h4><p>轻量级锁的释放也是通过CAS操作来进行的，主要步骤如下： </p>
<p>（1）取出获取轻量级锁时保存在Displaced Mark Word中的数据；<br>（2）用CAS操作将取出的数据替换当前对象的Mark<br>Word中，如果成功，则说明释放锁成功，否则执行（3）；<br>（3） 如果CAS操作替换失败，说明有其他线程尝试获取该锁，存在锁竞争，锁会膨胀成重量级锁。</p>
<h3 id="3-3-重量级锁"><a href="#3-3-重量级锁" class="headerlink" title="3.3 重量级锁"></a>3.3 重量级锁</h3><p><strong>重量级锁通过对象内部的监视器（monitor）实现，其中monitor的本质是依赖于底层操作系统的Mutex Lock实现</strong>，由于使用Mutex Lock需要将当前线程挂起并从用户态切换到内核态来执行，这种切换的代价非常昂贵。</p>
<h3 id="3-4-锁的对比"><a href="#3-4-锁的对比" class="headerlink" title="3.4 锁的对比"></a>3.4 锁的对比</h3><table>
<thead>
<tr>
<th>锁</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>偏向锁</td>
<td>加锁和解锁不需要额外的消耗,和执行非同步方法相比仅存在纳米级的差距</td>
<td>如果线程间存在锁竞争，有额外的锁撤销的消耗</td>
<td>适用于只有一个线程访问同步块的场景</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>竞争的线程不会阻塞，提高了程序的响应速度</td>
<td>如果始终得不到锁竞争的线程，使用自旋会消耗CPU</td>
<td>追求响应时间，同步块执行速度非常快</td>
</tr>
<tr>
<td>重量级锁</td>
<td>线程竞争不使用自旋，不会消耗CPU</td>
<td>线程阻塞，响应时间缓慢</td>
<td>追求吞吐量，同步块执行速度较长</td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、synchronized的基本介绍&quot;&gt;&lt;a href=&quot;#一、synchronized的基本介绍&quot; class=&quot;headerlink&quot; title=&quot;一、synchronized的基本介绍&quot;&gt;&lt;/a&gt;一、synchronized的基本介绍&lt;/h2&gt;&lt;p&gt;谈到
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="synchronized" scheme="http://yoursite.com/tags/synchronized/"/>
    
  </entry>
  
  <entry>
    <title>深入理解volatile关键字</title>
    <link href="http://yoursite.com/2017/10/12/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3volatile%E5%85%B3%E9%94%AE%E5%AD%97(1)/"/>
    <id>http://yoursite.com/2017/10/12/深入理解volatile关键字(1)/</id>
    <published>2017-10-12T07:12:12.000Z</published>
    <updated>2017-10-12T07:40:18.054Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、volatile的特性"><a href="#一、volatile的特性" class="headerlink" title="一、volatile的特性"></a>一、volatile的特性</h2><h3 id="1-volatile的可见性"><a href="#1-volatile的可见性" class="headerlink" title="1. volatile的可见性"></a>1. volatile的可见性</h3><p> 可见性的意思是：当一个线程修改一个共享变量时，另一个线程能读到这个修改的值。<br> volatile在多线程的开发中，保证了共享变量的可见性（立即）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//全局变量</div><div class="line">boolean open=true;</div><div class="line"></div><div class="line">//线程A</div><div class="line">resource.close();</div><div class="line">open = false;</div><div class="line"></div><div class="line">//线程B</div><div class="line">while(open) &#123;</div><div class="line">doSomething(resource);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>open是一个全局变量，用来描述一个资源的打开关闭状态，当线程A把资源关闭后，open置为false，而这个改动对线程B<strong>不是立即可见</strong>的，因此线程B还会运行，从而造成错误。<br>当添加volatile关键字修饰之后，线程B就可以<strong>立即</strong>将改动后的open变量（主内存）同步到自己的工作内存中，从而正确的停止运行。</p>
<h3 id="2-volatile的有序性（禁止指令重排序）"><a href="#2-volatile的有序性（禁止指令重排序）" class="headerlink" title="2. volatile的有序性（禁止指令重排序）"></a>2. volatile的有序性（禁止指令重排序）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//线程A</div><div class="line">context = loadContext();//初始化</div><div class="line">init = true;</div><div class="line">//线程B</div><div class="line">while(!init)&#123; //根据init变量决定是否使用context（为false时等待，为true时顺序执行）</div><div class="line">   sleep(100);</div><div class="line">&#125;</div><div class="line">doSomething(context);</div></pre></td></tr></table></figure>
<p>以上程序运行没有问题，然而当线程A中发生了指令重排序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">init = true;</div><div class="line">context = loadContext();</div></pre></td></tr></table></figure></p>
<p>那么B就可能跳过等待，拿到一个正在初始化或初始化未完成的context对象，从而发生程序错误。<br>当init变量用volatile修饰后，就会阻止JVM对其相关代码进行指令重排，这样就能够按照既定的顺序执行。<br> 在双重判断类型的单例模式中正是应用了volatile关键字的这个特性，才不会导致单例模式失效。</p>
<h3 id="3-volatile不保证操作的原子性"><a href="#3-volatile不保证操作的原子性" class="headerlink" title="3. volatile不保证操作的原子性"></a>3. volatile不保证操作的原子性</h3><p>原子操作：不可中断的一个或一系列操作（多线程中借助于原子操作可以实现互斥锁）<br>原子性：一个操作或多个操作要么全部成功执行，要么就都失败。一个操作是原子操作，那么我们称它具有原子性。<br>先看示例代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public class TestAtomic &#123;</div><div class="line">//计数器</div><div class="line">private static volatile int count=0;</div><div class="line">	</div><div class="line">	public void inc()&#123;</div><div class="line">		count++;</div><div class="line">	&#125;</div><div class="line">	private static class Countone implements  Runnable &#123;</div><div class="line">		public void run() &#123;</div><div class="line">			for(int i=0;i&lt;100;i++)&#123;</div><div class="line">				count++;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		</div><div class="line">		for(int i=0;i&lt;10;i++)&#123;</div><div class="line">			new Thread(new Countone()).start();</div><div class="line">		&#125;</div><div class="line">		//保证10个线程都执行完毕</div><div class="line">		while(Thread.activeCount()&gt;1)</div><div class="line">			Thread.yield();</div><div class="line">		</div><div class="line">		System.out.println(&quot;最终count的值为：&quot;+TestAtomic.count);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">输出结果：</div><div class="line">最终count的值为：863</div><div class="line">最终count的值为：1000</div><div class="line">最终count的值为：872</div><div class="line">最终count的值为：835</div></pre></td></tr></table></figure>
<p>将count变量声明为volatile int类型，保证了所有线程对变量count的可见性，上述定义了10个线程，每个线程对count执行100次自增的操作，按照理想的结果，最后的结果应该为10<em>100=1000，然而多次运行可以看到，并不是每次的结果都是1000，难道volatile修饰的变量的可见性特征失效了？<em>*并不是，而是volatile只能保证共享变量对所有线程的可见性，不能保证变量操作的原子性。</em></em> count++不是一个原子操作，因此volatile不能保证这个操作的原子性。</p>
<p><strong>有以下三种方式可以保证对变量操作的原子性：</strong></p>
<ol>
<li>使用synchronized关键字</li>
<li>使用Lock对象</li>
<li>使用java.util.concurrent.atomic包下提供的原子操作类</li>
</ol>
<h2 id="二、volatile的实现原理"><a href="#二、volatile的实现原理" class="headerlink" title="二、volatile的实现原理"></a>二、volatile的实现原理</h2><h3 id="1-可见性"><a href="#1-可见性" class="headerlink" title="1.可见性"></a>1.可见性</h3><p>它的实现原理与java内存模型（JMM）相关，每个线程都有自己的工作内存，并共享主内存的数据。下面是普通变量与volatile变量的异同：</p>
<ul>
<li><p>普通变量：读操作会优先读取工作内存的数据，如果工作内存中不存在，则从主内存中拷贝一份数据到工作内存中；写操作只会修改工作内存的副本数据。这种情况下，其它线程就无法读取变量的最新值。</p>
</li>
<li><p>volatile变量：读操作时会把工作内存中对应的值设为无效，要求线程从主内存中读取数据；写操作时会把工作内存中对应的数据刷新到主内存中。这种情况下，其它线程就可以读取变量的最新值。</p>
</li>
</ul>
<p>那么它是如何是实现的呢？这就涉及到了CPU指令。<br>如果对声明了volatile变量进行写操作，<strong>JVM就会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写回到系统内存。</strong> 但是就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题，所以在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作的时候，会强制重新从系统内存里把数据读到处理器缓存里。</p>
<h3 id="2-禁止重排序"><a href="#2-禁止重排序" class="headerlink" title="2.禁止重排序"></a>2.禁止重排序</h3><p>在执行程序时为了提高性能，编译器和处理器通常会对指令做重排序： </p>
<ul>
<li>编译器重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序； </li>
<li>处理器重排序。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序；<br>指令重排序对单线程没有影响，但是会影响多线程的正确性，因此需要对禁止指令重排序。</li>
</ul>
<p>在上面提到过lock指令，<strong>lock指令其实就相当于一个内存屏障。内存屏障是一组处理指令，用来实现对内存操作的顺序限制。</strong> volatile的底层就是通过内存屏障来实现的。</p>
<h2 id="三、volatile与synchronized的比较"><a href="#三、volatile与synchronized的比较" class="headerlink" title="三、volatile与synchronized的比较"></a>三、volatile与synchronized的比较</h2><ol>
<li><p>volatile本质是在告诉JVM当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞。 </p>
</li>
<li><p>volatile只能修饰变量，synchronized可以修饰变量、方法和类；  </p>
</li>
<li><p>volatile保证变量的修改可见性，synchronized则可以保证变量的修改可见性和原子性。  </p>
</li>
<li>volatile不会造成线程的阻塞，synchronized可能会造成线程的阻塞。  </li>
<li>volatile比synchronized的使用和执行成本更低，因为它不会引起上下文的切换和调度。</li>
</ol>
<h2 id="四、volatile的扩展"><a href="#四、volatile的扩展" class="headerlink" title="四、volatile的扩展"></a>四、volatile的扩展</h2><h3 id="1-volatile的常用场景"><a href="#1-volatile的常用场景" class="headerlink" title="1.volatile的常用场景"></a>1.volatile的常用场景</h3><ul>
<li><p>状态标记量（高并发的场景）</p>
</li>
<li><p>双重判断的单例模式</p>
</li>
</ul>
<h3 id="2-volatile修饰数组"><a href="#2-volatile修饰数组" class="headerlink" title="2.volatile修饰数组"></a>2.volatile修饰数组</h3><p><strong>问题：volatile能否保证数组中元素的可见性？</strong> 如果用volatile修饰一个数组，那么当一个线程对数组中的元素进行设值时，对另一个线程是否<strong>立即</strong>可见？ </p>
<p><strong>答案：</strong> 不能立即可见。因为volatile修饰的数组只针对数组的引用具有volatile的语义，而不是它的元素。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、volatile的特性&quot;&gt;&lt;a href=&quot;#一、volatile的特性&quot; class=&quot;headerlink&quot; title=&quot;一、volatile的特性&quot;&gt;&lt;/a&gt;一、volatile的特性&lt;/h2&gt;&lt;h3 id=&quot;1-volatile的可见性&quot;&gt;&lt;a hr
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="volatile" scheme="http://yoursite.com/tags/volatile/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2017/10/10/hello-world/"/>
    <id>http://yoursite.com/2017/10/10/hello-world/</id>
    <published>2017-10-09T16:08:31.273Z</published>
    <updated>2017-10-09T16:08:31.273Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Mysql中查询某个数据库中所有表的字段信息</title>
    <link href="http://yoursite.com/2017/08/09/Mysql%E4%B8%AD%E6%9F%A5%E8%AF%A2%E6%9F%90%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E6%89%80%E6%9C%89%E8%A1%A8%E7%9A%84%E5%AD%97%E6%AE%B5%E4%BF%A1%E6%81%AF/"/>
    <id>http://yoursite.com/2017/08/09/Mysql中查询某个数据库中所有表的字段信息/</id>
    <published>2017-08-09T09:55:55.000Z</published>
    <updated>2017-10-09T16:08:31.273Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>有时候，需要在数据库中查询一些字段的具体信息，而这些字段又存在于不同的表中，那么我们如何来查询呢？</p>
<p>在每一个数据库链接的information_schema数据库中，存在这样一张表——COLUMNS，它记录了这个数据库中所有表的字段信息。</p>
<h2 id="查询某个特定类型的字段信息"><a href="#查询某个特定类型的字段信息" class="headerlink" title="查询某个特定类型的字段信息"></a>查询某个特定类型的字段信息</h2><p>如下：查询字段类型为decimal的字段信息<br>Sql语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">SELECT</div><div class="line">	TABLE_NAME,</div><div class="line">	column_name,</div><div class="line">	DATA_TYPE,</div><div class="line">	column_comment</div><div class="line">FROM</div><div class="line">	information_schema. COLUMNS</div><div class="line">WHERE</div><div class="line">	TABLE_SCHEMA = &apos;evshare&apos;</div><div class="line">AND DATA_TYPE = &apos;decimal&apos;;</div></pre></td></tr></table></figure>
<p>其中</p>
<ul>
<li>TABLE_SCHEMA 为数据库的名称（所属的数据库）</li>
<li>TABLE_NAME 为表的名称</li>
<li>DATA_TYPE 为字段的数据类型</li>
<li>column_name  为字段名</li>
<li>column_comment 为字段注释<br>在Where的条件语句中，可以加入限制条件。<br>结果如下：</li>
</ul>
<p><img src="http://osuskkx7k.bkt.clouddn.com/clipboard1.png" alt="1"> </p>
<h2 id="查询注释乱码的字段信息"><a href="#查询注释乱码的字段信息" class="headerlink" title="查询注释乱码的字段信息"></a>查询注释乱码的字段信息</h2><p>如果需要查询数据库中所有乱码的字段信息，那么可以对以上的Sql稍稍改进：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">SELECT</div><div class="line">	TABLE_NAME,</div><div class="line">	column_name,</div><div class="line">	DATA_TYPE,</div><div class="line">	column_comment</div><div class="line">FROM</div><div class="line">	information_schema. COLUMNS</div><div class="line">WHERE</div><div class="line">	TABLE_SCHEMA = &apos;evshare&apos;</div><div class="line">AND column_comment LIKE &apos;%?%&apos;;</div></pre></td></tr></table></figure>
<p>结果如下：可以看到这个evshare数据库中，所有表的乱码字段都已显示</p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/clipboard3.png" alt="1"> </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><font size="4">以上，就是在Mysql中如何查询某个数据库中所有表的字段信息的过程。</font></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;有时候，需要在数据库中查询一些字段的具体信息，而这些字段又存在于不同的表中，那么我们如何来查询呢？&lt;/p&gt;
&lt;p&gt;在每一个数据库链接的inf
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Mysql" scheme="http://yoursite.com/tags/Mysql/"/>
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>在Hexo发布博客的MarkDown文件中引入JS代码</title>
    <link href="http://yoursite.com/2017/08/07/Hexo%E5%8F%91%E5%B8%83%E5%8D%9A%E5%AE%A2%E7%9A%84MarkDown%E6%96%87%E4%BB%B6%E4%B8%AD%E5%BC%95%E5%85%A5JS%E4%BB%A3%E7%A0%81/"/>
    <id>http://yoursite.com/2017/08/07/Hexo发布博客的MarkDown文件中引入JS代码/</id>
    <published>2017-08-07T07:05:05.000Z</published>
    <updated>2017-10-09T16:08:31.273Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上周困扰了两天的问题终于得到解决，于是就打算写点东西，也当作一次记录。</p>
<p>从题目可以看出，问题就是——<strong>如何在Hexo发布博客的Md文件中引入JS代码</strong>，来实现你想要的特效。<br>之所以会提出这个问题，是源于一个简单的想法，单纯地想在某一篇博客中引入echarts（一个纯 Javascript 的图表库）特效，实质上就是引入它的JS代码。</p>
<p>那么就详细讲解一下引入echarts来实现特效的过程。</p>
<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>首先，在<a href="http://echarts.baidu.com/download.html" target="_blank" rel="external">echarts下载页面</a> 中下载相应的版本，我这里下载的是完整版（echarts.min.js）。<br>文件下载完成后，将其放入下图所示文件夹当中<br><img src="http://osuskkx7k.bkt.clouddn.com/js%E5%AD%98%E5%82%A8.PNG" alt="WithYou"></p>
<p>我的博客使用的是next主题，打开themes文件夹中的next文件夹，再依次打开source、js、src文件夹，就可以看到许多js文件，将echarts.min.js放入即可。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>在文件引入后（src就是指向刚刚存入js文件的目录），那么你就可以在你的博客中引用这个js文件来达到特定的效果。<br>引用的方式很简单，只需一行代码：</p>
<p><code>&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/echarts.min.js&quot;&gt;&lt;/script&gt;</code></p>
<p>在引用js文件后，那么你只要在md文件中添加相应的js代码片段即可，这里贴出我使用的js代码片段</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">var bmapChart=echarts.init(document.getElementById(&quot;map-wrap&quot;));var data=[&#123;name:&quot;上海&quot;,value:299&#125;,&#123;name:&quot;厦门&quot;,value:245&#125;,&#123;name:&quot;丰城&quot;,value:120&#125;,&#123;name:&quot;南昌&quot;,value:160&#125;,&#123;name:&quot;张家界&quot;,value:128&#125;,&#123;name:&quot;长沙&quot;,value:75&#125;,&#123;name:&quot;杭州&quot;,value:90&#125;,&#123;name:&quot;福州&quot;,value:90&#125;,&#123;name:&quot;深圳&quot;,value:90&#125;,&#123;name:&quot;武汉&quot;,value:73&#125;];var geoCoordMap=&#123;&quot;厦门&quot;:[118.105,24.443],&quot;上海&quot;:[121.399,31.321],&quot;丰城&quot;:[115.801,28.201],&quot;南昌&quot;:[115.856,28.691],&quot;张家界&quot;:[110.489,29.118],&quot;福州&quot;:[119.3,26.08],&quot;长沙&quot;:[113,28.21],&quot;杭州&quot;:[120.16,30.28],&quot;深圳&quot;:[114.06,22.55],&quot;武汉&quot;:[114.31,30.52]&#125;;var convertData=function(data)&#123;var res=[];for(var i=0;i&lt;data.length;i++)&#123;var geoCoord=geoCoordMap[data[i].name];if(geoCoord)&#123;res.push(&#123;name:data[i].name,value:geoCoord.concat(data[i].value)&#125;)&#125;&#125;return res&#125;;option=&#123;title:&#123;text:&quot;我们的足迹 - Our footprints&quot;,subtext:&quot;一步一个脚印，让时光见证&quot;,sublink:&quot;#&quot;,left:&quot;center&quot;&#125;,tooltip:&#123;trigger:&quot;item&quot;&#125;,bmap:&#123;center:[106.320439,32.58783],zoom:5,roam:true,mapStyle:&#123;styleJson:[&#123;&quot;featureType&quot;:&quot;water&quot;,&quot;elementType&quot;:&quot;all&quot;,&quot;stylers&quot;:&#123;&quot;color&quot;:&quot;#d1d1d1&quot;&#125;&#125;,&#123;&quot;featureType&quot;:&quot;land&quot;,&quot;elementType&quot;:&quot;all&quot;,&quot;stylers&quot;:&#123;&quot;color&quot;:&quot;#f3f3f3&quot;&#125;&#125;,&#123;&quot;featureType&quot;:&quot;railway&quot;,&quot;elementType&quot;:&quot;all&quot;,&quot;stylers&quot;:&#123;&quot;visibility&quot;:&quot;off&quot;&#125;&#125;,&#123;&quot;featureType&quot;:&quot;highway&quot;,&quot;elementType&quot;:&quot;all&quot;,&quot;stylers&quot;:&#123;&quot;color&quot;:&quot;#fdfdfd&quot;&#125;&#125;,&#123;&quot;featureType&quot;:&quot;highway&quot;,&quot;elementType&quot;:&quot;labels&quot;,&quot;stylers&quot;:&#123;&quot;visibility&quot;:&quot;off&quot;&#125;&#125;,&#123;&quot;featureType&quot;:&quot;arterial&quot;,&quot;elementType&quot;:&quot;geometry&quot;,&quot;stylers&quot;:&#123;&quot;color&quot;:&quot;#fefefe&quot;&#125;&#125;,&#123;&quot;featureType&quot;:&quot;arterial&quot;,&quot;elementType&quot;:&quot;geometry.fill&quot;,&quot;stylers&quot;:&#123;&quot;color&quot;:&quot;#fefefe&quot;&#125;&#125;,&#123;&quot;featureType&quot;:&quot;poi&quot;,&quot;elementType&quot;:&quot;all&quot;,&quot;stylers&quot;:&#123;&quot;visibility&quot;:&quot;off&quot;&#125;&#125;,&#123;&quot;featureType&quot;:&quot;green&quot;,&quot;elementType&quot;:&quot;all&quot;,&quot;stylers&quot;:&#123;&quot;visibility&quot;:&quot;off&quot;&#125;&#125;,&#123;&quot;featureType&quot;:&quot;subway&quot;,&quot;elementType&quot;:&quot;all&quot;,&quot;stylers&quot;:&#123;&quot;visibility&quot;:&quot;off&quot;&#125;&#125;,&#123;&quot;featureType&quot;:&quot;manmade&quot;,&quot;elementType&quot;:&quot;all&quot;,&quot;stylers&quot;:&#123;&quot;color&quot;:&quot;#d1d1d1&quot;&#125;&#125;,&#123;&quot;featureType&quot;:&quot;local&quot;,&quot;elementType&quot;:&quot;all&quot;,&quot;stylers&quot;:&#123;&quot;color&quot;:&quot;#d1d1d1&quot;&#125;&#125;,&#123;&quot;featureType&quot;:&quot;arterial&quot;,&quot;elementType&quot;:&quot;labels&quot;,&quot;stylers&quot;:&#123;&quot;visibility&quot;:&quot;off&quot;&#125;&#125;,&#123;&quot;featureType&quot;:&quot;boundary&quot;,&quot;elementType&quot;:&quot;all&quot;,&quot;stylers&quot;:&#123;&quot;color&quot;:&quot;#fefefe&quot;&#125;&#125;,&#123;&quot;featureType&quot;:&quot;building&quot;,&quot;elementType&quot;:&quot;all&quot;,&quot;stylers&quot;:&#123;&quot;color&quot;:&quot;#d1d1d1&quot;&#125;&#125;,&#123;&quot;featureType&quot;:&quot;label&quot;,&quot;elementType&quot;:&quot;labels.text.fill&quot;,&quot;stylers&quot;:&#123;&quot;color&quot;:&quot;#999999&quot;&#125;&#125;]&#125;&#125;,series:[&#123;name:&quot;footmark&quot;,type:&quot;scatter&quot;,coordinateSystem:&quot;bmap&quot;,data:convertData(data),symbolSize:function(val)&#123;return val[2]/10&#125;,label:&#123;normal:&#123;formatter:&quot;&#123;b&#125;&quot;,position:&quot;right&quot;,show:false&#125;,emphasis:&#123;show:true&#125;&#125;,itemStyle:&#123;normal:&#123;color:&quot;#60C0DD&quot;&#125;&#125;&#125;,&#123;name:&quot;I miss you&quot;,type:&quot;effectScatter&quot;,coordinateSystem:&quot;bmap&quot;,data:convertData(data.sort(function(a,b)&#123;return b.value-a.value&#125;).slice(0,2)),symbolSize:function(val)&#123;return val[2]/10&#125;,showEffectOn:&quot;render&quot;,rippleEffect:&#123;brushType:&quot;stroke&quot;&#125;,hoverAnimation:true,label:&#123;normal:&#123;formatter:&quot;&#123;b&#125;&quot;,position:&quot;right&quot;,show:true&#125;&#125;,itemStyle:&#123;normal:&#123;color:&quot;purple&quot;,shadowBlur:10,shadowColor:&quot;#333&quot;&#125;&#125;,zlevel:1&#125;]&#125;;bmapChart.setOption(option);</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<p> 文章末尾有博客链接。<br> 在这个页面中所展现的特效中还引入了其他的js文件，如china.js、api.js、bmap.js等，例如api.js是百度地图的js代码，当然你可以引入任何你想要引用的js文件。  </p>
<h2 id="详细"><a href="#详细" class="headerlink" title="详细"></a>详细</h2><p>至于bmap.js文件可以在<a href="https://github.com/ecomfe/echarts/tree/master/extension/bmap" target="_blank" rel="external">github</a>下载，下载之后打开echarts-master文件夹，找到extension中的bamp.js,如下图所示:<br><img src="http://osuskkx7k.bkt.clouddn.com/1.PNG" alt="WithYou"></p>
<p>ECharts使用参考（其中有china.js的介绍）：</p>
<ul>
<li><a href="http://efe.baidu.com/blog/echarts-map-tutorial/" target="_blank" rel="external">ECharts 实现地图散点图（上）</a></li>
<li><a href="http://efe.baidu.com/blog/echarts-map-tutorial-2/" target="_blank" rel="external">ECharts 实现地图散点图（下）</a></li>
</ul>
<p>这里要注意一个问题，就是引入bmap.js后，地图并不显示，想要使用百度地图，还要去<a href="http://lbsyun.baidu.com/index.php?title=jspopular" target="_blank" rel="external">百度地图开放平台</a>申请一个密钥，申请成功后在页面中引入，但是经过多次尝试，直接在md文件中引入并不起作用，如下：</p>
<p><code>&lt;script src=&quot;http://api.map.baidu.com/api?v=2.0&amp;ak=？（你的密钥）&quot;&gt;&lt;/script&gt;</code></p>
<p>   由此想到在script标签中嵌入了网页链接，md可能不能识别（只是猜测），于是想着将这个链接所指向的js转为文件引入试试。直接点击链接，跳转到如下页面：</p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/%E7%99%BE%E5%BA%A61.PNG" alt="WithYou"></p>
<p>可以看到标记处同样为一个链接，再次从浏览器打开，出现如下：  </p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/%E7%99%BE%E5%BA%A62.PNG" alt="WithYou"></p>
<p>在你眼前呈现的是全屏的js代码，这就是我们所需要的js文件，即百度地图的js代码，将它全选保存为js文件，这里命名为api.js。<br>然后在md中引入它即可使用，这样我们就能取得和百度地图类似的效果。</p>
<p>下面贴出完整的文章代码，即md文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;div id=&quot;map-wrap&quot; style=&quot;height: 500px;width:800px;&quot;&gt;&lt;/div&gt;</div><div class="line"></div><div class="line">    &lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/echarts.min.js&quot;&gt;&lt;/script&gt;</div><div class="line">    &lt;script src=&quot;/js/src/china.js&quot;&gt;&lt;/script&gt;</div><div class="line">    &lt;script src=&quot;/js/src/api.js&quot;&gt;&lt;/script&gt;</div><div class="line">    &lt;script src=&quot;/js/src/bmap.js&quot;&gt;&lt;/script&gt;</div><div class="line">    </div><div class="line">&lt;script&gt;</div><div class="line">var bmapChart=echarts.init(document.getElementById(&quot;map-wrap&quot;));var data=[&#123;name:&quot;上海&quot;,value:299&#125;,&#123;name:&quot;厦门&quot;,value:245&#125;,&#123;name:&quot;丰城&quot;,value:120&#125;,&#123;name:&quot;南昌&quot;,value:160&#125;,&#123;name:&quot;张家界&quot;,value:128&#125;,&#123;name:&quot;长沙&quot;,value:75&#125;,&#123;name:&quot;杭州&quot;,value:90&#125;,&#123;name:&quot;福州&quot;,value:90&#125;,&#123;name:&quot;深圳&quot;,value:90&#125;,&#123;name:&quot;武汉&quot;,value:73&#125;];var geoCoordMap=&#123;&quot;厦门&quot;:[118.105,24.443],&quot;上海&quot;:[121.399,31.321],&quot;丰城&quot;:[115.801,28.201],&quot;南昌&quot;:[115.856,28.691],&quot;张家界&quot;:[110.489,29.118],&quot;福州&quot;:[119.3,26.08],&quot;长沙&quot;:[113,28.21],&quot;杭州&quot;:[120.16,30.28],&quot;深圳&quot;:[114.06,22.55],&quot;武汉&quot;:[114.31,30.52]&#125;;var convertData=function(data)&#123;var res=[];for(var i=0;i&lt;data.length;i++)&#123;var geoCoord=geoCoordMap[data[i].name];if(geoCoord)&#123;res.push(&#123;name:data[i].name,value:geoCoord.concat(data[i].value)&#125;)&#125;&#125;return res&#125;;option=&#123;title:&#123;text:&quot;我们的足迹 - Our footprints&quot;,subtext:&quot;一步一个脚印，让时光见证&quot;,sublink:&quot;#&quot;,left:&quot;center&quot;&#125;,tooltip:&#123;trigger:&quot;item&quot;&#125;,bmap:&#123;center:[106.320439,32.58783],zoom:5,roam:true,mapStyle:&#123;styleJson:[&#123;&quot;featureType&quot;:&quot;water&quot;,&quot;elementType&quot;:&quot;all&quot;,&quot;stylers&quot;:&#123;&quot;color&quot;:&quot;#d1d1d1&quot;&#125;&#125;,&#123;&quot;featureType&quot;:&quot;land&quot;,&quot;elementType&quot;:&quot;all&quot;,&quot;stylers&quot;:&#123;&quot;color&quot;:&quot;#f3f3f3&quot;&#125;&#125;,&#123;&quot;featureType&quot;:&quot;railway&quot;,&quot;elementType&quot;:&quot;all&quot;,&quot;stylers&quot;:&#123;&quot;visibility&quot;:&quot;off&quot;&#125;&#125;,&#123;&quot;featureType&quot;:&quot;highway&quot;,&quot;elementType&quot;:&quot;all&quot;,&quot;stylers&quot;:&#123;&quot;color&quot;:&quot;#fdfdfd&quot;&#125;&#125;,&#123;&quot;featureType&quot;:&quot;highway&quot;,&quot;elementType&quot;:&quot;labels&quot;,&quot;stylers&quot;:&#123;&quot;visibility&quot;:&quot;off&quot;&#125;&#125;,&#123;&quot;featureType&quot;:&quot;arterial&quot;,&quot;elementType&quot;:&quot;geometry&quot;,&quot;stylers&quot;:&#123;&quot;color&quot;:&quot;#fefefe&quot;&#125;&#125;,&#123;&quot;featureType&quot;:&quot;arterial&quot;,&quot;elementType&quot;:&quot;geometry.fill&quot;,&quot;stylers&quot;:&#123;&quot;color&quot;:&quot;#fefefe&quot;&#125;&#125;,&#123;&quot;featureType&quot;:&quot;poi&quot;,&quot;elementType&quot;:&quot;all&quot;,&quot;stylers&quot;:&#123;&quot;visibility&quot;:&quot;off&quot;&#125;&#125;,&#123;&quot;featureType&quot;:&quot;green&quot;,&quot;elementType&quot;:&quot;all&quot;,&quot;stylers&quot;:&#123;&quot;visibility&quot;:&quot;off&quot;&#125;&#125;,&#123;&quot;featureType&quot;:&quot;subway&quot;,&quot;elementType&quot;:&quot;all&quot;,&quot;stylers&quot;:&#123;&quot;visibility&quot;:&quot;off&quot;&#125;&#125;,&#123;&quot;featureType&quot;:&quot;manmade&quot;,&quot;elementType&quot;:&quot;all&quot;,&quot;stylers&quot;:&#123;&quot;color&quot;:&quot;#d1d1d1&quot;&#125;&#125;,&#123;&quot;featureType&quot;:&quot;local&quot;,&quot;elementType&quot;:&quot;all&quot;,&quot;stylers&quot;:&#123;&quot;color&quot;:&quot;#d1d1d1&quot;&#125;&#125;,&#123;&quot;featureType&quot;:&quot;arterial&quot;,&quot;elementType&quot;:&quot;labels&quot;,&quot;stylers&quot;:&#123;&quot;visibility&quot;:&quot;off&quot;&#125;&#125;,&#123;&quot;featureType&quot;:&quot;boundary&quot;,&quot;elementType&quot;:&quot;all&quot;,&quot;stylers&quot;:&#123;&quot;color&quot;:&quot;#fefefe&quot;&#125;&#125;,&#123;&quot;featureType&quot;:&quot;building&quot;,&quot;elementType&quot;:&quot;all&quot;,&quot;stylers&quot;:&#123;&quot;color&quot;:&quot;#d1d1d1&quot;&#125;&#125;,&#123;&quot;featureType&quot;:&quot;label&quot;,&quot;elementType&quot;:&quot;labels.text.fill&quot;,&quot;stylers&quot;:&#123;&quot;color&quot;:&quot;#999999&quot;&#125;&#125;]&#125;&#125;,series:[&#123;name:&quot;footmark&quot;,type:&quot;scatter&quot;,coordinateSystem:&quot;bmap&quot;,data:convertData(data),symbolSize:function(val)&#123;return val[2]/10&#125;,label:&#123;normal:&#123;formatter:&quot;&#123;b&#125;&quot;,position:&quot;right&quot;,show:false&#125;,emphasis:&#123;show:true&#125;&#125;,itemStyle:&#123;normal:&#123;color:&quot;#60C0DD&quot;&#125;&#125;&#125;,&#123;name:&quot;I miss you&quot;,type:&quot;effectScatter&quot;,coordinateSystem:&quot;bmap&quot;,data:convertData(data.sort(function(a,b)&#123;return b.value-a.value&#125;).slice(0,2)),symbolSize:function(val)&#123;return val[2]/10&#125;,showEffectOn:&quot;render&quot;,rippleEffect:&#123;brushType:&quot;stroke&quot;&#125;,hoverAnimation:true,label:&#123;normal:&#123;formatter:&quot;&#123;b&#125;&quot;,position:&quot;right&quot;,show:true&#125;&#125;,itemStyle:&#123;normal:&#123;color:&quot;purple&quot;,shadowBlur:10,shadowColor:&quot;#333&quot;&#125;&#125;,zlevel:1&#125;]&#125;;bmapChart.setOption(option);</div><div class="line">    &lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p>特效如下图所示：</p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/%E7%89%B9%E6%95%882.PNG" alt="WithYou"></p>
<p>欢迎访问博客页面查看效果：<a href="https://youngforzy.github.io/2017/08/07/index/#more" target="_blank" rel="external">Youngforzy</a></p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><font size="4">这里其实有个问题，就是特效虽然展现出来，但是在网页端还是无法实现地图的缩放，而在手机端和ipad中都可以进行地图的缩放，目前这个问题还未能得到解决，待日后解决再补充。</font></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是在MarkDown中插入js代码的过程。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;上周困扰了两天的问题终于得到解决，于是就打算写点东西，也当作一次记录。&lt;/p&gt;
&lt;p&gt;从题目可以看出，问题就是——&lt;strong&gt;如何在He
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
      <category term="MarkDown" scheme="http://yoursite.com/tags/MarkDown/"/>
    
  </entry>
  
  <entry>
    <title>JS特效</title>
    <link href="http://yoursite.com/2017/08/07/JS%E7%89%B9%E6%95%88/"/>
    <id>http://yoursite.com/2017/08/07/JS特效/</id>
    <published>2017-08-07T05:15:25.000Z</published>
    <updated>2017-10-09T16:08:31.273Z</updated>
    
    <content type="html"><![CDATA[<div id="map-wrap" style="height: 500px;width:800px;"></div>

<script type="text/javascript" src="/js/src/echarts.min.js"></script>
<script src="/js/src/china.js"></script>
<script src="/js/src/api.js"></script>
<script src="/js/src/bmap.js"></script>

<script>
var bmapChart=echarts.init(document.getElementById("map-wrap"));var data=[{name:"上海",value:299},{name:"厦门",value:245},{name:"丰城",value:120},{name:"南昌",value:160},{name:"张家界",value:128},{name:"长沙",value:75},{name:"杭州",value:90},{name:"福州",value:90},{name:"深圳",value:90},{name:"武汉",value:73}];var geoCoordMap={"厦门":[118.105,24.443],"上海":[121.399,31.321],"丰城":[115.801,28.201],"南昌":[115.856,28.691],"张家界":[110.489,29.118],"福州":[119.3,26.08],"长沙":[113,28.21],"杭州":[120.16,30.28],"深圳":[114.06,22.55],"武汉":[114.31,30.52]};var convertData=function(data){var res=[];for(var i=0;i<data.length;i++){var geoCoord=geoCoordMap[data[i].name];if(geoCoord){res.push({name:data[i].name,value:geoCoord.concat(data[i].value)})}}return res};option={title:{text:"我们的足迹 - Our footprints",subtext:"一步一个脚印，让时光见证",sublink:"#",left:"center"},tooltip:{trigger:"item"},bmap:{center:[106.320439,32.58783],zoom:5,roam:true,mapStyle:{styleJson:[{"featureType":"water","elementType":"all","stylers":{"color":"#d1d1d1"}},{"featureType":"land","elementType":"all","stylers":{"color":"#f3f3f3"}},{"featureType":"railway","elementType":"all","stylers":{"visibility":"off"}},{"featureType":"highway","elementType":"all","stylers":{"color":"#fdfdfd"}},{"featureType":"highway","elementType":"labels","stylers":{"visibility":"off"}},{"featureType":"arterial","elementType":"geometry","stylers":{"color":"#fefefe"}},{"featureType":"arterial","elementType":"geometry.fill","stylers":{"color":"#fefefe"}},{"featureType":"poi","elementType":"all","stylers":{"visibility":"off"}},{"featureType":"green","elementType":"all","stylers":{"visibility":"off"}},{"featureType":"subway","elementType":"all","stylers":{"visibility":"off"}},{"featureType":"manmade","elementType":"all","stylers":{"color":"#d1d1d1"}},{"featureType":"local","elementType":"all","stylers":{"color":"#d1d1d1"}},{"featureType":"arterial","elementType":"labels","stylers":{"visibility":"off"}},{"featureType":"boundary","elementType":"all","stylers":{"color":"#fefefe"}},{"featureType":"building","elementType":"all","stylers":{"color":"#d1d1d1"}},{"featureType":"label","elementType":"labels.text.fill","stylers":{"color":"#999999"}}]}},series:[{name:"footmark",type:"scatter",coordinateSystem:"bmap",data:convertData(data),symbolSize:function(val){return val[2]/10},label:{normal:{formatter:"{b}",position:"right",show:false},emphasis:{show:true}},itemStyle:{normal:{color:"#60C0DD"}}},{name:"I miss you",type:"effectScatter",coordinateSystem:"bmap",data:convertData(data.sort(function(a,b){return b.value-a.value}).slice(0,2)),symbolSize:function(val){return val[2]/10},showEffectOn:"render",rippleEffect:{brushType:"stroke"},hoverAnimation:true,label:{normal:{formatter:"{b}",position:"right",show:true}},itemStyle:{normal:{color:"purple",shadowBlur:10,shadowColor:"#333"}},zlevel:1}]};bmapChart.setOption(option);
</script>
]]></content>
    
    <summary type="html">
    
      &lt;div id=&quot;map-wrap&quot; style=&quot;height: 500px;width:800px;&quot;&gt;&lt;/div&gt;

&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/echarts.min.js&quot;&gt;&lt;/script&gt;
&lt;script 
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>使用Redis的管道（Pipeline）进行批量操作</title>
    <link href="http://yoursite.com/2017/07/28/Redis%E2%80%94Pipline/"/>
    <id>http://yoursite.com/2017/07/28/Redis—Pipline/</id>
    <published>2017-07-28T06:55:55.000Z</published>
    <updated>2017-10-09T16:08:31.273Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis管道技术简介"><a href="#Redis管道技术简介" class="headerlink" title="Redis管道技术简介"></a>Redis管道技术简介</h1><hr>
<p>Reids是一个cs模式的Tcp服务，类似于http的请求。 当客户端发送一个请求时，服务器处理之后会将结果通过响应报文返回给客户端 。  </p>
<p>那么当需要发送多个请求时，难道每次都要等待请求响应，再发送下一个请求吗？</p>
<p>当然不是，这里就可以采用Redis的管道技术。  </p>
<p>举个例子，如果说jedis是：request response，request response，…；  </p>
<p>&emsp;&emsp;&emsp;&emsp;&emsp;那么pipeline则是：request request… response response的方式。  </p>
<p>下面，就简单测试一下使用管道的效果。</p>
<hr>
<h1 id="单条插入与批量插入"><a href="#单条插入与批量插入" class="headerlink" title="单条插入与批量插入"></a>单条插入与批量插入</h1><p>这里采用逐条和批量的方式往Redis中写入一些数据。<br>先从Mysql中查出需要的数据，这里大概是300条左右，数据量并不大，但是简单做个测试应该没问题。<br><strong>单条插入—— Jedis：</strong></p>
<pre><code>Jedis jedis = jedisPool.getResource();
long start = System.currentTimeMillis();
List&lt;VehicleInfo&gt; vehicleInfos  = vehicleInfoMapper.selectByParam(param);
for (VehicleInfo vehicleInfo : vehicleInfos) {        
    //遍历每个vehicleInfo
    TVehicleRealReportMsg real = new TVehicleRealReportMsg();
    Map&lt;String, String&gt; keysmap = new HashMap&lt;String, String&gt;();
    keysmap.put(&quot;vehicleStatus&quot;, real.getVehicleStatus() + &quot;&quot;);
    keysmap.put(&quot;chargeStatus&quot;, real.getChargeStatus() + &quot;&quot;);
    keysmap.put(&quot;longitude&quot;, &quot;9&quot;);
    keysmap.put(&quot;latitude&quot;, &quot;9&quot;);
    List&lt;Long&gt; list1 = new ArrayList&lt;Long&gt;();
    Long l = 1000L;
    Long l2 = 22222L;
    list1.add(l);
    list1.add(l2);
    real.setEngineFaultsList(list1);
    keysmap.put(&quot;engineFaultsList&quot;, JSON.toJSONString(list1));
    //单条插入
    jedis.hmset(vehicleInfo.getVehicleSeq()+&quot;&quot;, keysmap);
}    
jedis.close();          
long end = System.currentTimeMillis(); System.out.println(&quot;耗时：&quot;+(end-start) +&quot;ms&quot;);  
</code></pre><p>结果：467ms  </p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/%E5%8D%95%E6%9D%A1%E6%8F%92%E5%85%A5.PNG" alt="1">  </p>
<p><strong>批量插入—— Pipeline：</strong> </p>
<pre><code>Jedis jedis = jedisPool.getResource();
Pipeline pip = jedis.pipelined();
long start = System.currentTimeMillis();
List&lt;VehicleInfo&gt; vehicleInfos  = vehicleInfoMapper.selectByParam(param);
for (VehicleInfo vehicleInfo : vehicleInfos) {        
    //遍历每个vehicleInfo
    TVehicleRealReportMsg real = new TVehicleRealReportMsg();
    Map&lt;String, String&gt; keysmap = new HashMap&lt;String, String&gt;();
    keysmap.put(&quot;vehicleStatus&quot;, real.getVehicleStatus() + &quot;&quot;);
    keysmap.put(&quot;chargeStatus&quot;, real.getChargeStatus() + &quot;&quot;);
    keysmap.put(&quot;longitude&quot;, &quot;9&quot;);
    keysmap.put(&quot;latitude&quot;, &quot;9&quot;);
    List&lt;Long&gt; list1 = new ArrayList&lt;Long&gt;();
    Long l = 1000L;
    Long l2 = 22222L;
    list1.add(l);
    list1.add(l2);
    real.setEngineFaultsList(list1);
    keysmap.put(&quot;engineFaultsList&quot;, JSON.toJSONString(list1));
    //批量插入
    pip.hmset(vehicleInfo.getVehicleSeq()+&quot;&quot;, keysmap);
}
pip.sync();//同步
jedis.close();        
long end = System.currentTimeMillis();
System.out.println(&quot;耗时：&quot;+(end-start) +&quot;ms&quot;);  
</code></pre><p>结果：175ms  </p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5.PNG" alt="2">  </p>
<p>可以看到使用管道之后的时间为，相比于单条插入的总时间大大减少，性能更优。</p>
<hr>
<h1 id="单条读取和批量读取"><a href="#单条读取和批量读取" class="headerlink" title="单条读取和批量读取"></a>单条读取和批量读取</h1><p><strong>单条读取—— Jedis：</strong>  </p>
<pre><code>Jedis jedis = jedisPool.getResource();
long start = System.currentTimeMillis();
//1.采用redis单条读取
List&lt;VehicleInfo&gt; vehicleInfos = vehicleInfoMapper.selectByParam(param);
List&lt;Coordinate&gt; list = new ArrayList&lt;Coordinate&gt;();
for(VehicleInfo key: vehicleInfos){
    String hashkey = key.getVehicleSeq()+&quot;&quot;;
    if(jedis.exists(hashkey+&quot;&quot;)){                            
    Coordinate coord = new Coordinate();
    coord.setVehicleSeq(key.getVehicleSeq());
    coord.setOrgId(key.getOrgId());    
    coord.setVehiclemodelseq(key.getVehiclemodelseq());    
    coord.setVin(jedis.hget(hashkey, &quot;vin&quot;));
    coord.setLongitude(Long.valueOf(jedis.hget(hashkey, &quot;longitude&quot;)));
    coord.setLatitude(Long.valueOf(jedis.hget(hashkey, &quot;latitude&quot;)));         
    list.add(coord);
    }
}    
jedis.close();
long end = System.currentTimeMillis();
System.out.println(&quot;耗时：&quot;+(end-start)+&quot; ms&quot;);
return list;  
</code></pre><p>结果： 第一次为1032ms，之后稳定在800~900ms<br> <img src="http://osuskkx7k.bkt.clouddn.com/%E5%8D%95%E4%BD%93%E8%AF%BB.PNG" alt="3">  </p>
<p><strong>批量读取—— Pipeline</strong>： </p>
<pre><code>Jedis jedis = jedisPool.getResource();
Pipeline pip = jedis.pipelined();
long start = System.currentTimeMillis();
//2.采用redis管道读取
List&lt;VehicleInfo&gt; vehicleInfos = vehicleInfoMapper.selectByParam(param);
List&lt;Coordinate&gt; list = new ArrayList&lt;Coordinate&gt;();
Map&lt;String,Object&gt; map = new HashMap&lt;String, Object&gt;();//map用来暂存属性
Map&lt;String,List&lt;Response&lt;String&gt;&gt;&gt; responses  = new HashMap&lt;String, List&lt;Response&lt;String&gt;&gt;&gt;(vehicleInfos.size());
for(VehicleInfo info: vehicleInfos){
    List&lt;Response&lt;String&gt;&gt; resls = new ArrayList&lt;Response&lt;String&gt;&gt;();
    resls.add(pip.hget(info.getVehicleSeq()+&quot;&quot;,&quot;longitude&quot;));
    resls.add(pip.hget(info.getVehicleSeq()+&quot;&quot;,&quot;latitude&quot;));
    responses.put(info.getVehicleSeq() + &quot;&quot;, resls);//得到了一辆车所有的实时数据--300辆车
    map.put(info.getVehicleSeq()+&quot;orgId&quot;, info.getOrgId());
    map.put(info.getVehicleSeq()+&quot;vin&quot;, info.getVin());
    map.put(info.getVehicleSeq()+&quot;vehiclemodelseq&quot;, info.getVehiclemodelseq());
}
pip.sync(); 
for(String k:responses.keySet()){
    Coordinate coord = new Coordinate();
    coord.setLongitude(Long.valueOf(responses.get(k).get(0).get()));//是get，不是toString
    coord.setLatitude(Long.valueOf(responses.get(k).get(1).get()));
    coord.setVehicleSeq(Long.valueOf(k));
    coord.setOrgId((String) map.get(k+&quot;orgId&quot;));
    coord.setVin((String) map.get(k+&quot;vin&quot;));
    coord.setVehiclemodelseq((Long) map.get(k+&quot;vehiclemodelseq&quot;));
    list.add(coord);
}
jedis.close();
long end = System.currentTimeMillis();
System.out.println(&quot;耗时：&quot;+(end-start)+&quot; ms&quot;);
return list;  
</code></pre><p>结果： 第一次为200ms，之后维持在30ms左右<br> <img src="http://osuskkx7k.bkt.clouddn.com/%E6%89%B9%E9%87%8F%E8%AF%BB.PNG" alt="4">  </p>
<p>总时间大概是单条读取总时间的1/5甚至更低，可以看出管道大大提升了效率，具有更好的性能。  </p>
<font size="3">注：使用管道所获取的值的类型是Response<string\>,因此需要转为String，如下代码片段： </string\></font> 

<pre><code>Map&lt;String,List&lt;Response&lt;String&gt;&gt;&gt; responses  = new HashMap&lt;String, List&lt;Response&lt;String&gt;&gt;&gt;  (vehicleInfos.size());  

//转String
responses.get(k).get(0).get();  
</code></pre><hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li><font size="3">这里仅仅测试了300条数据的操作，已经取得了相对明显的效果。  </font></li>
<li>对于大量数据的操作，使用Redis管道可以大大提升性能和效率。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Redis管道技术简介&quot;&gt;&lt;a href=&quot;#Redis管道技术简介&quot; class=&quot;headerlink&quot; title=&quot;Redis管道技术简介&quot;&gt;&lt;/a&gt;Redis管道技术简介&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;Reids是一个cs模式的Tcp服务，类似于http的请求
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
      <category term="Pipeline" scheme="http://yoursite.com/tags/Pipeline/"/>
    
      <category term="批量，缓存" scheme="http://yoursite.com/tags/%E6%89%B9%E9%87%8F%EF%BC%8C%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>You</title>
    <link href="http://yoursite.com/2017/07/20/our01/"/>
    <id>http://yoursite.com/2017/07/20/our01/</id>
    <published>2017-07-19T16:00:00.000Z</published>
    <updated>2017-10-09T16:08:31.273Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;
    
    </summary>
    
      <category term="芭乐" scheme="http://yoursite.com/categories/%E8%8A%AD%E4%B9%90/"/>
    
    
      <category term="Soul" scheme="http://yoursite.com/tags/Soul/"/>
    
  </entry>
  
  <entry>
    <title>Thrift——入门Demo（Java）</title>
    <link href="http://yoursite.com/2017/07/18/Thrift/"/>
    <id>http://yoursite.com/2017/07/18/Thrift/</id>
    <published>2017-07-18T09:07:07.000Z</published>
    <updated>2017-10-09T16:08:31.273Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><hr>
<p>Thrift最初由Facebook研发，主要用于各个服务之间的RPC通信。</p>
<p>Thrift是一个典型的CS（客户端/服务端）结构，客户端和服务端可以使用不同的语言开发。<br>那么它是如何实现使用不同的语言开发呢？<br>答案：一种关联客户端和服务端的中间语言。</p>
<p>这种语言就是IDL（Interface Description Language）。将这个IDL作为输入文件，编译器就可以生成代码（支持多种），即RPC客户端和服务器通信的无缝跨编程语言。</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><hr>
<p>下载官方链接：<a href="http://thrift.apache.org/download" target="_blank" rel="external">http://thrift.apache.org/download</a><br>将下载好的thrift-0.10.0 .exe文件命名为thrift .exe，放在D盘下的一个Thtift文件夹中，<br>为了更方便使用命令，将目录加入到系统Path路径下：</p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/path.png" alt="image"></p>
<p>在cmd中输入：thrift -version ，查看是否安装配置成功</p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/%E7%89%88%E6%9C%AC1.png" alt="image"></p>
<p>出现版本号，安装成功。</p>
<h2 id="定义thrift——IDL文件"><a href="#定义thrift——IDL文件" class="headerlink" title="定义thrift——IDL文件"></a>定义thrift——IDL文件</h2><hr>
<p>IDL文件有许多数据类型</p>
<ul>
<li>结构体类型： struct：定义公共的对象，类似于 C 语 言中的结构体定义，在 Java 中是一个 JavaBean</li>
<li>容器类型：<br>&emsp;&emsp;&emsp;&emsp;&emsp; list：对应 Java 的 ArrayList<br>&emsp;&emsp;&emsp;&emsp;&emsp; set：对应 Java 的 HashSet<br>&emsp;&emsp;&emsp;&emsp;&emsp; map：对应 Java 的 HashMap</li>
<li>异常类型： exception：对应 Java 的 Exception</li>
<li>服务类型： service：对应服务的类  </li>
</ul>
<p>这里仅仅定义一个服务。<br>thrift定义服务相当于Java中创建Interface，创建的service通过代码生成命令生成客户端和服务端的框架代码。<br>定义形式如下（helloworld.thrift，注意后缀！）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">namespace java com.test</div><div class="line"></div><div class="line">service HelloWorldService&#123;</div><div class="line"></div><div class="line">    string sayHello(1:string name)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>——namespace 相当于Java中的package。</p>
<p>在 cmd中 输入命令：  thrift -gen java helloworld.thrift</p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/%E5%91%BD%E4%BB%A41.PNG" alt="image"></p>
<p>可以看到生成了一个名为gen-java的文件夹，其中就是生成的代码，打开后可以看到层级目录下有：</p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90.png" alt="image"></p>
<p>代码片段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Autogenerated by Thrift Compiler (0.10.0)</div><div class="line"> *</div><div class="line"> * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING</div><div class="line"> *  @generated</div><div class="line"> */</div><div class="line">package com.test;</div><div class="line"></div><div class="line">@SuppressWarnings(&#123;&quot;cast&quot;, &quot;rawtypes&quot;, &quot;serial&quot;, &quot;unchecked&quot;, &quot;unused&quot;&#125;)</div><div class="line">@javax.annotation.Generated(value = &quot;Autogenerated by Thrift Compiler (0.10.0)&quot;, date = &quot;2017-07-18&quot;)</div><div class="line">public class HelloWorldService &#123;</div><div class="line"></div><div class="line">  public interface Iface &#123;</div><div class="line"></div><div class="line">    public java.lang.String sayHello(java.lang.String name) throws org.apache.thrift.TException;</div><div class="line"></div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<h1 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h1><hr>
<p>创建一个Maven工程，引入依赖，可在Maven依赖中看到引入的相关Jar包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">      &lt;groupId&gt;org.apache.thrift&lt;/groupId&gt;</div><div class="line">      &lt;artifactId&gt;libthrift&lt;/artifactId&gt;</div><div class="line">      &lt;version&gt;0.10.0&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure>
<h1 id="服务端实现与启动"><a href="#服务端实现与启动" class="headerlink" title="服务端实现与启动"></a>服务端实现与启动</h1><hr>
<p>服务端相关操作的步骤如下：</p>
<ul>
<li>实现服务处理接口Impl</li>
<li>创建TProcessor</li>
<li>创建TServerTransport</li>
<li>创建TProtocol</li>
<li>创建TServer</li>
<li>启动Server  </li>
</ul>
<font size="4">服务端实现</font>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">package com.test;</div><div class="line"></div><div class="line">import org.apache.thrift.TException;</div><div class="line"></div><div class="line">public class HelloWorldImpl implements HelloWorldService.Iface&#123;</div><div class="line">	</div><div class="line">	public HelloWorldImpl()&#123;	</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public String sayHello(String name) throws TException &#123;</div><div class="line">		</div><div class="line">		return &quot;Hi,&quot; +name + &quot; welcome !&quot;;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<font size="4">服务端启动</font>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">package com.test;</div><div class="line"></div><div class="line">import org.apache.thrift.TProcessor;</div><div class="line">import org.apache.thrift.protocol.TBinaryProtocol;</div><div class="line">import org.apache.thrift.server.TServer;</div><div class="line">import org.apache.thrift.server.TSimpleServer;</div><div class="line">import org.apache.thrift.transport.TServerSocket;</div><div class="line"></div><div class="line">public class HelloServer &#123;</div><div class="line">	</div><div class="line">	public static final int SERVER_PORT = 8090;</div><div class="line">	</div><div class="line">	public void startServer()&#123;	</div><div class="line">		System.out.println(&quot;Server is Runing......&quot;);</div><div class="line">		</div><div class="line">		TProcessor tprocessor = new HelloWorldService.Processor(new HelloWorldImpl());	</div><div class="line">		//简单的单线程服务模型，一般用于测试</div><div class="line">		try &#123;</div><div class="line">			TServerSocket serverTransport = new TServerSocket(SERVER_PORT);</div><div class="line">			TServer.Args tArgs = new TServer.Args(serverTransport);</div><div class="line">			tArgs.processor(tprocessor);</div><div class="line">			tArgs.protocolFactory(new TBinaryProtocol.Factory());</div><div class="line">			TServer server = new TSimpleServer(tArgs);</div><div class="line">			server.serve();</div><div class="line">			</div><div class="line">		&#125; catch (Exception e) &#123;</div><div class="line">			System.out.println(&quot;Server start error！&quot;);</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		HelloServer server = new HelloServer();</div><div class="line">		server.startServer();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行上面的启动类，控制台输出：Server is Runing……</p>
<p><img src="http://osuskkx7k.bkt.clouddn.com/%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8.png" alt="image"></p>
<h1 id="客户端启动"><a href="#客户端启动" class="headerlink" title="客户端启动"></a>客户端启动</h1><hr>
<font size="4">客户端步骤：</font>

<ul>
<li>创建Transport</li>
<li>创建TProtocol</li>
<li>基于TTransport和TProtocol创建 Client</li>
<li>调用Client的相应方法</li>
</ul>
<font size="4">客户端启动</font>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">package com.test;</div><div class="line"></div><div class="line">import org.apache.thrift.protocol.TBinaryProtocol;</div><div class="line">import org.apache.thrift.protocol.TProtocol;</div><div class="line">import org.apache.thrift.transport.TSocket;</div><div class="line">import org.apache.thrift.transport.TTransport;</div><div class="line"></div><div class="line">public class HelloClient &#123;</div><div class="line">	</div><div class="line">	public static final String SERVER_IP = &quot;localhost&quot;;</div><div class="line">	public static final int SERVER_PORT = 8090;</div><div class="line">	public static final int TIMEOUT = 30000;</div><div class="line">	</div><div class="line">	public void startClient(String userName)&#123;</div><div class="line">		TTransport transport = null;</div><div class="line">		try &#123;</div><div class="line">			transport = new TSocket(SERVER_IP,SERVER_PORT,TIMEOUT);</div><div class="line">			//协议要和服务端一致</div><div class="line">			TProtocol protocol  = new TBinaryProtocol(transport);</div><div class="line">			</div><div class="line">			HelloWorldService.Client client = new HelloWorldService.Client(protocol);</div><div class="line">			transport.open();</div><div class="line">			</div><div class="line">			String result = client.sayHello(userName);		</div><div class="line">			System.out.println(&quot;Thrift client result is:&quot;+result);</div><div class="line">			</div><div class="line">		&#125; catch (Exception e) &#123;</div><div class="line">			System.out.println(&quot;client is error!&quot;);</div><div class="line">		&#125;finally&#123;</div><div class="line">			if(null != transport)&#123;</div><div class="line">				transport.close();</div><div class="line">			&#125;</div><div class="line">		&#125;	</div><div class="line">	&#125;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		HelloClient client = new HelloClient();</div><div class="line">		client.startClient(&quot;Z Yong&quot;);</div><div class="line">	&#125;	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<font size="4">控制台输出：  Thrift client result is:  Hi,Z Yong welcome !<br></font>

<p><img src="http://osuskkx7k.bkt.clouddn.com/%E8%BE%93%E5%87%BA2.PNG" alt="image"></p>
<font size="5"><strong>客户端成功收到了服务端返回的请求结果，通信完成</strong>。</font>


]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;Thrift最初由Facebook研发，主要用于各个服务之间的RPC通信。&lt;/p&gt;
&lt;p&gt;Thrift是一个典型的CS（客户端/服
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Thrift" scheme="http://yoursite.com/tags/Thrift/"/>
    
      <category term="RPC" scheme="http://yoursite.com/tags/RPC/"/>
    
  </entry>
  
  <entry>
    <title>Mysql批量操作之更新及插入</title>
    <link href="http://yoursite.com/2017/07/12/mysql%E6%89%B9%E9%87%8F%E6%9B%B4%E6%96%B0/"/>
    <id>http://yoursite.com/2017/07/12/mysql批量更新/</id>
    <published>2017-07-12T07:12:12.000Z</published>
    <updated>2017-10-09T16:08:31.273Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>   这个问题困扰了整整一天。<br>   当遇到多条记录需要插入或者更新的时候，往往会使用批量操作来提高效率，提高性能。然而在使用过程中确是出现了各种问题，真的是有些坑只有趟过才知道！！<br>   好了，话不多说，进入正题。<br>   注：数据库Mysql     持久层框架 Mybatis</p>
<h2 id="批量更新"><a href="#批量更新" class="headerlink" title="批量更新"></a>批量更新</h2><p>需求如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Map&lt;String,Object&gt; ucmap = new HashMap&lt;String, Object&gt;();</div><div class="line">		ucmap.put(&quot;updateUser&quot;,&quot;zyong&quot;);</div><div class="line">		ucmap.put(&quot;updateTime&quot;, time);</div><div class="line">		ucmap.put(&quot;list&quot;, updateClist);</div><div class="line">		connectorInfoMapper.updateBatch(ucmap);</div></pre></td></tr></table></figure></p>
<p>这里的需求是对设备的信息进行批量更新，利用Map来传参，Map中包含了一个List，这个List包含了需要更新的对象集合，也就是多条记录。<br>sql片段如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;update id=&quot;updateBatch&quot; parameterType=&quot;java.util.Map&quot;&gt;</div><div class="line">      &lt;foreach collection=&quot;list&quot; item=&quot;item&quot; index=&quot;index&quot; separator=&quot;;&quot;&gt;</div><div class="line"> update connector_info</div><div class="line">    set  </div><div class="line">      Connector_Type = #&#123;item.connectorType,jdbcType=INTEGER&#125;,</div><div class="line">      Voltage_Upper_Limits = #&#123;item.voltageUpperLimits,jdbcType=INTEGER&#125;,</div><div class="line">      Voltage_Lower_Limits = #&#123;item.voltageLowerLimits,jdbcType=INTEGER&#125;,</div><div class="line">      Current = #&#123;item.current,jdbcType=INTEGER&#125;,</div><div class="line">      Power = #&#123;item.power,jdbcType=DOUBLE&#125;,</div><div class="line">      National_Standard = #&#123;item.nationalStandard,jdbcType=INTEGER&#125;,</div><div class="line">      Update_User = #&#123;updateUser,jdbcType=VARCHAR&#125;,</div><div class="line">	  Update_Time = FROM_UNIXTIME(#&#123;updateTime,jdbcType=TIMESTAMP&#125;)   </div><div class="line">    where Connector_ID = #&#123;item.connectorId,jdbcType=VARCHAR&#125;</div><div class="line">    &lt;/foreach&gt;</div><div class="line"> &lt;/update&gt;</div></pre></td></tr></table></figure></p>
<p>   可以看到，这里使用了foreach标签进行迭代，item代表着每一个元素，item.power等代表的就是每个元素的属性，而没有加上item的参数如updateUser、updateTime等则是存放在Map中的参数，从需求代码中能看得更加明显。</p>
<p>当我检查了多遍后，感觉没问题之后，运行。<br>控制台的错误让我明白还是太年轻——报错了！！！仔细一看，是Sql语法错误，What？我把sql放入Navicat中美化，又检查了好几遍，这明明没有错啊！</p>
<p>于是开启了百度，各种查：</p>
<ul>
<li>有的说把separator=”;”中的分号换成——separator=”UNION ALL”，测试，还是报同样的错误。</li>
<li>将几个属于Map的字段删除再测试，依然报错  </li>
</ul>
<p>查了很多并没有什么实质性的进展，将多条数据改成一条数据进行更新，测试，竟然通过了！——原因很明显：批量操作的原因导致。<br>再百度，终于找到了答案：<br>并不是Sql的原因，而是数据库设置的原因————Mysql需要打开批量更新的设置。</p>
<font size="5">在数据库JDBC链接中加入： <strong>&amp;allowMultiQueries=true</strong></font><br>如下：<br>jdbc.url=jdbc:mysql://139.224.35.81:3306/evshare?useUnicode=true&amp;characterEncoding=UTF-8&amp;allowMultiQueries=true<br><br><font size="5">在添加了这个“开关”之后，成功批量更新多条数据。</font>

<h2 id="批量插入"><a href="#批量插入" class="headerlink" title="批量插入"></a>批量插入</h2><p>相比于批量更新，批量插入则没有类似的设置。<br>一个简单的示例Sql：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;insert id=&quot;insertBatch&quot; parameterType=&quot;java.util.Map&quot;&gt;</div><div class="line">  insert into connector_info (Equipment_Seq, Connector_ID, </div><div class="line">      Connector_Type, Voltage_Upper_Limits, </div><div class="line">      Voltage_Lower_Limits, Current, Power, </div><div class="line">      National_Standard,Create_User,Create_Time,Update_Time)</div><div class="line">      values</div><div class="line">      &lt;foreach collection=&quot;list&quot; item=&quot;item&quot; index=&quot;index&quot; separator=&quot;,&quot;&gt;</div><div class="line">     (#&#123;item.equipmentSeq,jdbcType=BIGINT&#125;, #&#123;item.connectorId,jdbcType=VARCHAR&#125;, </div><div class="line">      #&#123;item.connectorType,jdbcType=INTEGER&#125;, #&#123;item.voltageUpperLimits,jdbcType=INTEGER&#125;, </div><div class="line">      #&#123;item.voltageLowerLimits,jdbcType=INTEGER&#125;, #&#123;item.current,jdbcType=INTEGER&#125;, #&#123;item.power,jdbcType=DOUBLE&#125;, </div><div class="line">      #&#123;item.nationalStandard,jdbcType=INTEGER&#125;,</div><div class="line">      #&#123;createUser,jdbcType=VARCHAR&#125;,</div><div class="line">      FROM_UNIXTIME(#&#123;createTime,jdbcType=TIMESTAMP&#125;),</div><div class="line">      FROM_UNIXTIME(#&#123;updateTime,jdbcType=TIMESTAMP&#125;))</div><div class="line">      &lt;/foreach&gt;</div><div class="line">  &lt;/insert&gt;</div></pre></td></tr></table></figure></p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><ol>
<li>有时候问题并不是出现在代码上，可以往系统环境和配置方面考虑。  </li>
<li>对于批量更新Mysql需要设置，而Oracle则不需要设置，但sql可能要变化</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;   这个问题困扰了整整一天。&lt;br&gt;   当遇到多条记录需要插入或者更新的时候，往往会使用批量操作来提高效率，提高性能。然而在使用过程中确
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Mysql" scheme="http://yoursite.com/tags/Mysql/"/>
    
      <category term="Mybatis" scheme="http://yoursite.com/tags/Mybatis/"/>
    
  </entry>
  
  <entry>
    <title>Jersey—— 一个基于Rest风格的Web Service开发框架</title>
    <link href="http://yoursite.com/2017/07/10/jersey2/"/>
    <id>http://yoursite.com/2017/07/10/jersey2/</id>
    <published>2017-07-10T13:54:27.000Z</published>
    <updated>2017-10-09T16:08:31.273Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、什么是Jersey"><a href="#一、什么是Jersey" class="headerlink" title="一、什么是Jersey"></a>一、什么是Jersey</h2><p>   Jersey 是一个Java规范（JAX-RS）下的基于Rest风格的Web Service开发框架。</p>
<p>   说的直白一点，主要应用于移动项目，用来给移动终端和服务端传递数据。</p>
<p>   Rest则是一种目前主流的软件架构风格，它可以通过一套统一的接口为 Web，iOS和Android提供服务。因为有些平台不需要显式的前端，只需要一套提供服务的接口，于是就有了Rest风格的软件架构。</p>
<h2 id="二、Jersey-Spring-Mybatis搭建一个简单的Web-Service"><a href="#二、Jersey-Spring-Mybatis搭建一个简单的Web-Service" class="headerlink" title="二、Jersey+Spring+Mybatis搭建一个简单的Web Service"></a>二、Jersey+Spring+Mybatis搭建一个简单的Web Service</h2><h4 id="1、在Eclipse下创建一个Maven工程"><a href="#1、在Eclipse下创建一个Maven工程" class="headerlink" title="1、在Eclipse下创建一个Maven工程"></a>1、在Eclipse下创建一个Maven工程</h4><p>工程目录结构如下图：</p>
<p><img src="http://img.blog.csdn.net/20170710212939408?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYmFieWxvdmVfQmFMZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="目录"><br>   上图中——com.zy包下存放业务代码<br>              ——resources文件夹下存放资源文件<br>              ——其它主要有Web.xml和Pom.xml文件</p>
<h4 id="2、pom-xml"><a href="#2、pom-xml" class="headerlink" title="2、pom.xml"></a>2、pom.xml</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div></pre></td><td class="code"><pre><div class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;  </div><div class="line">  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt;  </div><div class="line">  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;  </div><div class="line">  &lt;groupId&gt;com.zy&lt;/groupId&gt;  </div><div class="line">  &lt;artifactId&gt;jersey&lt;/artifactId&gt;  </div><div class="line">  &lt;packaging&gt;war&lt;/packaging&gt;  </div><div class="line">  &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;  </div><div class="line">  &lt;name&gt;jersey Maven Webapp&lt;/name&gt;  </div><div class="line">  &lt;url&gt;http://maven.apache.org&lt;/url&gt;  </div><div class="line">    </div><div class="line">  &lt;properties&gt;  </div><div class="line">        &lt;!-- 指明使用JDK8 --&gt;  </div><div class="line">        &lt;java-version&gt;1.8&lt;/java-version&gt;  </div><div class="line">        &lt;!-- 指明使用utf-8编码 --&gt;  </div><div class="line">        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;  </div><div class="line">        &lt;spring3.version&gt;4.2.6.RELEASE&lt;/spring3.version&gt;  </div><div class="line">        &lt;jersey.version&gt;2.22.2&lt;/jersey.version&gt;  </div><div class="line">    &lt;/properties&gt;  </div><div class="line">      </div><div class="line">      </div><div class="line">  &lt;dependencies&gt;  </div><div class="line">    &lt;dependency&gt;  </div><div class="line">      &lt;groupId&gt;junit&lt;/groupId&gt;  </div><div class="line">      &lt;artifactId&gt;junit&lt;/artifactId&gt;  </div><div class="line">      &lt;version&gt;3.8.1&lt;/version&gt;  </div><div class="line">      &lt;scope&gt;test&lt;/scope&gt;  </div><div class="line">    &lt;/dependency&gt;  </div><div class="line">    &lt;dependency&gt;  </div><div class="line">    &lt;groupId&gt;redis.clients&lt;/groupId&gt;  </div><div class="line">    &lt;artifactId&gt;jedis&lt;/artifactId&gt;  </div><div class="line">    &lt;version&gt;2.9.0&lt;/version&gt;  </div><div class="line">    &lt;/dependency&gt;  </div><div class="line">    &lt;!-- Jersey依赖 --&gt;  </div><div class="line">    &lt;dependency&gt;  </div><div class="line">            &lt;groupId&gt;org.glassfish.jersey.containers&lt;/groupId&gt;  </div><div class="line">            &lt;artifactId&gt;jersey-container-servlet&lt;/artifactId&gt;  </div><div class="line">            &lt;version&gt;$&#123;jersey.version&#125;&lt;/version&gt;  </div><div class="line">        &lt;/dependency&gt;  </div><div class="line">  </div><div class="line">        &lt;dependency&gt;  </div><div class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;  </div><div class="line">            &lt;artifactId&gt;spring-web&lt;/artifactId&gt;  </div><div class="line">            &lt;version&gt;$&#123;spring3.version&#125;&lt;/version&gt;  </div><div class="line">            &lt;scope&gt;compile&lt;/scope&gt;  </div><div class="line">        &lt;/dependency&gt;  </div><div class="line">  </div><div class="line">        &lt;dependency&gt;  </div><div class="line">            &lt;groupId&gt;org.glassfish.jersey.ext&lt;/groupId&gt;  </div><div class="line">            &lt;artifactId&gt;jersey-spring3&lt;/artifactId&gt;  </div><div class="line">            &lt;version&gt;$&#123;jersey.version&#125;&lt;/version&gt;  </div><div class="line">        &lt;/dependency&gt;  </div><div class="line">  </div><div class="line">        &lt;dependency&gt;  </div><div class="line">            &lt;groupId&gt;org.glassfish.jersey.media&lt;/groupId&gt;  </div><div class="line">            &lt;artifactId&gt;jersey-media-json-jackson&lt;/artifactId&gt;  </div><div class="line">            &lt;version&gt;$&#123;jersey.version&#125;&lt;/version&gt;  </div><div class="line">        &lt;/dependency&gt;  </div><div class="line">    &lt;!-- 加入mysql驱动依赖包 --&gt;  </div><div class="line">    &lt;dependency&gt;  </div><div class="line">            &lt;groupId&gt;mysql&lt;/groupId&gt;  </div><div class="line">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;  </div><div class="line">            &lt;version&gt;5.1.27&lt;/version&gt;  </div><div class="line">    &lt;/dependency&gt;  </div><div class="line">      </div><div class="line">    &lt;!-- 引入mybatis --&gt;  </div><div class="line">        &lt;dependency&gt;  </div><div class="line">            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;  </div><div class="line">            &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;  </div><div class="line">            &lt;version&gt;1.1.1&lt;/version&gt;  </div><div class="line">        &lt;/dependency&gt;  </div><div class="line">        &lt;dependency&gt;  </div><div class="line">            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;  </div><div class="line">            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;  </div><div class="line">            &lt;version&gt;3.2.8&lt;/version&gt;  </div><div class="line">        &lt;/dependency&gt;  </div><div class="line">    &lt;!-- 引入数据源 --&gt;  </div><div class="line">        &lt;dependency&gt;  </div><div class="line">            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;  </div><div class="line">            &lt;artifactId&gt;druid&lt;/artifactId&gt;  </div><div class="line">            &lt;version&gt;1.0.1&lt;/version&gt;  </div><div class="line">        &lt;/dependency&gt;  </div><div class="line">        &lt;dependency&gt;  </div><div class="line">            &lt;groupId&gt;org.aspectj&lt;/groupId&gt;  </div><div class="line">            &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;  </div><div class="line">            &lt;version&gt;1.7.4&lt;/version&gt;  </div><div class="line">        &lt;/dependency&gt;  </div><div class="line">        &lt;!-- 加入fastjson依赖包 --&gt;  </div><div class="line">        &lt;dependency&gt;  </div><div class="line">            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;  </div><div class="line">            &lt;artifactId&gt;fastjson&lt;/artifactId&gt;  </div><div class="line">            &lt;version&gt;1.1.37&lt;/version&gt;  </div><div class="line">        &lt;/dependency&gt;  </div><div class="line">  </div><div class="line">        &lt;dependency&gt;  </div><div class="line">            &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;  </div><div class="line">            &lt;artifactId&gt;pagehelper&lt;/artifactId&gt;  </div><div class="line">            &lt;version&gt;3.7.6&lt;/version&gt;  </div><div class="line">        &lt;/dependency&gt;  </div><div class="line">        &lt;dependency&gt;  </div><div class="line">            &lt;groupId&gt;cglib&lt;/groupId&gt;  </div><div class="line">            &lt;artifactId&gt;cglib&lt;/artifactId&gt;  </div><div class="line">            &lt;version&gt;2.2.2&lt;/version&gt;  </div><div class="line">        &lt;/dependency&gt;  </div><div class="line">        &lt;dependency&gt;  </div><div class="line">            &lt;groupId&gt;commons-io&lt;/groupId&gt;  </div><div class="line">            &lt;artifactId&gt;commons-io&lt;/artifactId&gt;  </div><div class="line">            &lt;version&gt;2.4&lt;/version&gt;  </div><div class="line">        &lt;/dependency&gt;  </div><div class="line">        &lt;dependency&gt;  </div><div class="line">            &lt;groupId&gt;org.glassfish.jersey.ext&lt;/groupId&gt;  </div><div class="line">            &lt;artifactId&gt;jersey-bean-validation&lt;/artifactId&gt;  </div><div class="line">            &lt;version&gt;2.22.2&lt;/version&gt;  </div><div class="line">            &lt;exclusions&gt;  </div><div class="line">                &lt;exclusion&gt;  </div><div class="line">                    &lt;groupId&gt;org.hibernate&lt;/groupId&gt;  </div><div class="line">                    &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;  </div><div class="line">                &lt;/exclusion&gt;  </div><div class="line">            &lt;/exclusions&gt;  </div><div class="line">        &lt;/dependency&gt;  </div><div class="line">        &lt;dependency&gt;  </div><div class="line">            &lt;groupId&gt;commons-beanutils&lt;/groupId&gt;  </div><div class="line">            &lt;artifactId&gt;commons-beanutils&lt;/artifactId&gt;  </div><div class="line">            &lt;version&gt;1.7.0&lt;/version&gt;  </div><div class="line">        &lt;/dependency&gt;  </div><div class="line">          </div><div class="line">        &lt;dependency&gt;  </div><div class="line">            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;  </div><div class="line">            &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;  </div><div class="line">            &lt;version&gt;1.7.5&lt;/version&gt;  </div><div class="line">        &lt;/dependency&gt;  </div><div class="line">        &lt;!-- E起充解码包 --&gt;  </div><div class="line">        &lt;dependency&gt;  </div><div class="line">            &lt;groupId&gt;com.extracme.evready&lt;/groupId&gt;  </div><div class="line">            &lt;artifactId&gt;decode&lt;/artifactId&gt;  </div><div class="line">            &lt;version&gt;1.1.6&lt;/version&gt;  </div><div class="line">        &lt;/dependency&gt;  </div><div class="line">        &lt;dependency&gt;  </div><div class="line">            &lt;groupId&gt;com.extracme&lt;/groupId&gt;  </div><div class="line">            &lt;artifactId&gt;evreadyHelp&lt;/artifactId&gt;  </div><div class="line">            &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;  </div><div class="line">        &lt;/dependency&gt;  </div><div class="line">        &lt;!-- disconf注解插件 --&gt;  </div><div class="line">        &lt;dependency&gt;  </div><div class="line">            &lt;groupId&gt;com.baidu.disconf&lt;/groupId&gt;  </div><div class="line">            &lt;artifactId&gt;disconf-client&lt;/artifactId&gt;  </div><div class="line">            &lt;version&gt;2.6.36&lt;/version&gt;  </div><div class="line">        &lt;/dependency&gt;  </div><div class="line">        &lt;dependency&gt;  </div><div class="line">            &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;  </div><div class="line">            &lt;artifactId&gt;httpclient&lt;/artifactId&gt;  </div><div class="line">            &lt;version&gt;4.5.2&lt;/version&gt;  </div><div class="line">        &lt;/dependency&gt;  </div><div class="line">  &lt;/dependencies&gt;  </div><div class="line">   </div><div class="line">  &lt;build&gt;  </div><div class="line">    &lt;finalName&gt;jersey&lt;/finalName&gt;  </div><div class="line">        &lt;plugins&gt;  </div><div class="line">            &lt;plugin&gt;  </div><div class="line">                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;  </div><div class="line">                &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;  </div><div class="line">                &lt;version&gt;2.18.1&lt;/version&gt;  </div><div class="line">                &lt;configuration&gt;  </div><div class="line">                    &lt;skipTests&gt;true&lt;/skipTests&gt;  </div><div class="line">                &lt;/configuration&gt;  </div><div class="line">            &lt;/plugin&gt;  </div><div class="line">            &lt;plugin&gt;  </div><div class="line">                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;  </div><div class="line">                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;  </div><div class="line">                &lt;version&gt;2.3.2&lt;/version&gt;  </div><div class="line">                &lt;configuration&gt;  </div><div class="line">                    &lt;skipTests&gt;true&lt;/skipTests&gt;  </div><div class="line">                    &lt;source&gt;1.8&lt;/source&gt;  </div><div class="line">                    &lt;target&gt;1.8&lt;/target&gt;  </div><div class="line">                &lt;/configuration&gt;  </div><div class="line">            &lt;/plugin&gt;  </div><div class="line">        &lt;/plugins&gt;  </div><div class="line">  &lt;/build&gt;  </div><div class="line">&lt;/project&gt;</div></pre></td></tr></table></figure>
<p>以上就是项目所依赖的jar包，其中有一些是项目需要的可以忽略，重点是Jersey和spring以及mybatis的依赖，上面有相关的注释。</p>
<h4 id="3、web-xml"><a href="#3、web-xml" class="headerlink" title="3、web.xml"></a>3、web.xml</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">&lt;web-app&gt;  </div><div class="line">      </div><div class="line">    &lt;listener&gt;  </div><div class="line">        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;  </div><div class="line">    &lt;/listener&gt;  </div><div class="line">    &lt;listener&gt;  </div><div class="line">        &lt;listener-class&gt;org.springframework.web.context.request.RequestContextListener&lt;/listener-class&gt;  </div><div class="line">    &lt;/listener&gt;  </div><div class="line">    &lt;context-param&gt;  </div><div class="line">        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;  </div><div class="line">        &lt;param-value&gt;classpath:spring.xml&lt;/param-value&gt;  </div><div class="line">    &lt;/context-param&gt;  </div><div class="line">    &lt;servlet&gt;  </div><div class="line">        &lt;servlet-name&gt;jersey&lt;/servlet-name&gt;  </div><div class="line">        &lt;servlet-class&gt;org.glassfish.jersey.servlet.ServletContainer&lt;/servlet-class&gt;  </div><div class="line">        &lt;init-param&gt;  </div><div class="line">            &lt;param-name&gt;javax.ws.rs.Application&lt;/param-name&gt;  </div><div class="line">            &lt;param-value&gt;com.zy.StartApplication&lt;/param-value&gt;  </div><div class="line">              </div><div class="line">        &lt;/init-param&gt;  </div><div class="line">        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;  </div><div class="line">    &lt;/servlet&gt;  </div><div class="line">    &lt;servlet-mapping&gt;  </div><div class="line">        &lt;servlet-name&gt;jersey&lt;/servlet-name&gt;  </div><div class="line">        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;  </div><div class="line">    &lt;/servlet-mapping&gt;  </div><div class="line">&lt;/web-app&gt;</div></pre></td></tr></table></figure>
<p>以上是web.xml的配置。<br>——listener定义了Spring框架中的Bean随着Web容器启动而被创建。<br>——context-param定义了Spring.xml的位置。<br>——servlet定义了org.glassfish.jersey.servlet.ServletContainer，相当于对客户端的请求（/*）进行了拦截，同时还有一个启动参数，它是Application类的实现，需要我们自己定义，利用它来注册资源，实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class StartApplication extends ResourceConfig &#123;  </div><div class="line">  </div><div class="line">    /**  </div><div class="line">     * Register JAX-RS application components.  </div><div class="line">     */  </div><div class="line">    public StartApplication() &#123;  </div><div class="line">        //register(AuthRequestFilter.class);  </div><div class="line">        packages(&quot;com.zy.resource&quot;);  </div><div class="line">      </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="4、spring-mybatis-xml和mybatis-config-xml以及spring-xml"><a href="#4、spring-mybatis-xml和mybatis-config-xml以及spring-xml" class="headerlink" title="4、spring-mybatis.xml和mybatis-config.xml以及spring.xml"></a>4、spring-mybatis.xml和mybatis-config.xml以及spring.xml</h4><p>Spring-mybatis.xml如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  </div><div class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;  </div><div class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;  </div><div class="line">    xmlns:c=&quot;http://www.springframework.org/schema/c&quot; xmlns:cache=&quot;http://www.springframework.org/schema/cache&quot;  </div><div class="line">    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;  </div><div class="line">    xmlns:jdbc=&quot;http://www.springframework.org/schema/jdbc&quot; xmlns:jee=&quot;http://www.springframework.org/schema/jee&quot;  </div><div class="line">    xmlns:lang=&quot;http://www.springframework.org/schema/lang&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;  </div><div class="line">    xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:task=&quot;http://www.springframework.org/schema/task&quot;  </div><div class="line">    xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:util=&quot;http://www.springframework.org/schema/util&quot;  </div><div class="line">    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd  </div><div class="line">        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd  </div><div class="line">        http://www.springframework.org/schema/cache http://www.springframework.org/schema/cache/spring-cache.xsd  </div><div class="line">        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd  </div><div class="line">        http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc.xsd  </div><div class="line">        http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee.xsd  </div><div class="line">        http://www.springframework.org/schema/lang http://www.springframework.org/schema/lang/spring-lang.xsd  </div><div class="line">        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd  </div><div class="line">        http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task.xsd  </div><div class="line">        http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd  </div><div class="line">        http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd&quot;&gt;  </div><div class="line">          </div><div class="line">      </div><div class="line">          </div><div class="line">          </div><div class="line">    &lt;!-- 配置测试环境数据源 --&gt;  </div><div class="line">    &lt;bean name=&quot;test-dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;  </div><div class="line">        init-method=&quot;init&quot; destroy-method=&quot;close&quot;&gt;  </div><div class="line">        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt;  </div><div class="line">        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/jersey-test?useUnicode=true&amp;characterEncoding=UTF-8&quot; /&gt;  </div><div class="line">        &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt;  </div><div class="line">        &lt;property name=&quot;password&quot; value=&quot;&quot; /&gt;  </div><div class="line">  </div><div class="line">        &lt;!-- 初始化连接大小 --&gt;  </div><div class="line">        &lt;property name=&quot;initialSize&quot; value=&quot;0&quot; /&gt;  </div><div class="line">        &lt;!-- 连接池最大使用连接数量 --&gt;  </div><div class="line">        &lt;property name=&quot;maxActive&quot; value=&quot;20&quot; /&gt;  </div><div class="line">        &lt;!-- 连接池最小空闲 --&gt;  </div><div class="line">        &lt;property name=&quot;minIdle&quot; value=&quot;0&quot; /&gt;  </div><div class="line">        &lt;!-- 获取连接最大等待时间 --&gt;  </div><div class="line">        &lt;property name=&quot;maxWait&quot; value=&quot;60000&quot; /&gt;  </div><div class="line">  </div><div class="line">        &lt;property name=&quot;testOnBorrow&quot; value=&quot;false&quot; /&gt;  </div><div class="line">        &lt;property name=&quot;testOnReturn&quot; value=&quot;false&quot; /&gt;  </div><div class="line">        &lt;property name=&quot;testWhileIdle&quot; value=&quot;true&quot; /&gt;  </div><div class="line">  </div><div class="line">        &lt;!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 --&gt;  </div><div class="line">        &lt;property name=&quot;timeBetweenEvictionRunsMillis&quot; value=&quot;60000&quot; /&gt;  </div><div class="line">        &lt;!-- 配置一个连接在池中最小生存的时间，单位是毫秒 --&gt;  </div><div class="line">        &lt;property name=&quot;minEvictableIdleTimeMillis&quot; value=&quot;25200000&quot; /&gt;  </div><div class="line">  </div><div class="line">        &lt;!-- 打开removeAbandoned功能 --&gt;  </div><div class="line">        &lt;property name=&quot;removeAbandoned&quot; value=&quot;true&quot; /&gt;  </div><div class="line">        &lt;!-- 1800秒，也就是30分钟 --&gt;  </div><div class="line">        &lt;property name=&quot;removeAbandonedTimeout&quot; value=&quot;1800&quot; /&gt;  </div><div class="line">        &lt;!-- 关闭abanded连接时输出错误日志 --&gt;  </div><div class="line">        &lt;property name=&quot;logAbandoned&quot; value=&quot;true&quot; /&gt;  </div><div class="line">  </div><div class="line">        &lt;!-- 监控数据库 --&gt;  </div><div class="line">        &lt;!-- &lt;property name=&quot;filters&quot; value=&quot;mergeStat&quot; /&gt; --&gt;  </div><div class="line">        &lt;property name=&quot;filters&quot; value=&quot;stat&quot; /&gt;  </div><div class="line">    &lt;/bean&gt;  </div><div class="line">      </div><div class="line">          </div><div class="line">          </div><div class="line">    &lt;!--根据dataSource和configLocation创建一个sqlSessionFactory --&gt;  </div><div class="line">    &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;  </div><div class="line">        &lt;property name=&quot;dataSource&quot; ref=&quot;test-dataSource&quot; /&gt;  </div><div class="line">        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;&gt;&lt;/property&gt;  </div><div class="line">    &lt;/bean&gt;  </div><div class="line">    &lt;bean id=&quot;sqlSession&quot; class=&quot;org.mybatis.spring.SqlSessionTemplate&quot;  </div><div class="line">        scope=&quot;prototype&quot;&gt;  </div><div class="line">        &lt;constructor-arg index=&quot;0&quot; ref=&quot;sqlSessionFactory&quot; /&gt;  </div><div class="line">    &lt;/bean&gt;  </div><div class="line">     &lt;!-- 配置事务管理器 --&gt;  </div><div class="line">    &lt;bean name=&quot;transactionManager&quot;  </div><div class="line">        class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;  </div><div class="line">        &lt;property name=&quot;dataSource&quot; ref=&quot;test-dataSource&quot;&gt;&lt;/property&gt;  </div><div class="line">    &lt;/bean&gt;  </div><div class="line">  </div><div class="line">    &lt;!-- 注解方式配置事物 --&gt;  </div><div class="line">     &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot; /&gt;   </div><div class="line">  </div><div class="line">    &lt;bean id=&quot;sqlSessionCache&quot; class=&quot;com.zy.utils.SqlSessionCache&quot;  </div><div class="line">        init-method=&quot;initMapper&quot;&gt;  </div><div class="line">        &lt;!-- 扫描的映射mapper.xml的文件路径 --&gt;  </div><div class="line">        &lt;property name=&quot;packageSearchPath&quot; value=&quot;classpath*:com/zy/*/sql/*.xml&quot;&gt;&lt;/property&gt;  </div><div class="line">        &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt;  </div><div class="line">    &lt;/bean&gt;  </div><div class="line">    &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;  </div><div class="line">        &lt;property name=&quot;basePackage&quot; value=&quot;com.zy.*.mapper&quot; /&gt;  </div><div class="line">    &lt;/bean&gt;  </div><div class="line">      </div><div class="line">    &lt;bean id=&quot;framelnterceptor&quot; class=&quot;com.zy.utils.Framelnterceptor&quot; /&gt;   </div><div class="line">    &lt;aop:aspectj-autoproxy/&gt;     </div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure>
<p>mybatis-config.xml如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  </div><div class="line">&lt;!DOCTYPE configuration PUBLIC    </div><div class="line">    &quot;-//mybatis.org//DTD Config 3.0//EN&quot;    </div><div class="line">    &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;    </div><div class="line">&lt;configuration&gt;    </div><div class="line">&lt;!--     &lt;properties resource=&quot;project.properties&quot; /&gt; --&gt;  </div><div class="line">    &lt;settings&gt;    </div><div class="line">        &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot; /&gt;  </div><div class="line">        &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot; /&gt;  </div><div class="line">        &lt;setting name=&quot;multipleResultSetsEnabled&quot; value=&quot;true&quot; /&gt;  </div><div class="line">        &lt;setting name=&quot;useColumnLabel&quot; value=&quot;true&quot; /&gt;  </div><div class="line">        &lt;setting name=&quot;useGeneratedKeys&quot; value=&quot;false&quot; /&gt;  </div><div class="line">        &lt;setting name=&quot;autoMappingBehavior&quot; value=&quot;PARTIAL&quot; /&gt;  </div><div class="line">        &lt;setting name=&quot;defaultExecutorType&quot; value=&quot;SIMPLE&quot; /&gt;  </div><div class="line">        &lt;setting name=&quot;defaultStatementTimeout&quot; value=&quot;25&quot; /&gt;  </div><div class="line">        &lt;setting name=&quot;safeRowBoundsEnabled&quot; value=&quot;false&quot; /&gt;  </div><div class="line">        &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;false&quot; /&gt;  </div><div class="line">        &lt;setting name=&quot;localCacheScope&quot; value=&quot;SESSION&quot; /&gt;  </div><div class="line">        &lt;!-- &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot; /&gt; --&gt;  </div><div class="line">        &lt;setting name=&quot;jdbcTypeForNull&quot; value=&quot;OTHER&quot; /&gt;  </div><div class="line">        &lt;setting name=&quot;lazyLoadTriggerMethods&quot; value=&quot;equals,clone,hashCode,toString&quot; /&gt;   </div><div class="line">    &lt;/settings&gt;&lt;/configuration&gt;</div></pre></td></tr></table></figure>
<p>Spring.xml的配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  </div><div class="line">  </div><div class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;  </div><div class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;  </div><div class="line">       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;  </div><div class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans  </div><div class="line">  http://www.springframework.org/schema/beans/spring-beans.xsd  </div><div class="line">  http://www.springframework.org/schema/context  </div><div class="line">  http://www.springframework.org/schema/context/spring-context.xsd&quot;  </div><div class="line">        &gt;  </div><div class="line">    &lt;!-- 自动扫描dao和service包(自动注入) --&gt;  </div><div class="line">    &lt;context:component-scan base-package=&quot;com.zy.*&quot; /&gt;  </div><div class="line">    &lt;import resource=&quot;classpath:spring-mybatis.xml&quot; /&gt;  </div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure>
<p>注意：在spring-mybatis.xml配置文件的底部配置了一个拦截器——<br><code>&lt;bean id=&quot;framelnterceptor&quot; class=&quot;com.zy.utils.Framelnterceptor&quot; /&gt;</code>     ——作用是输出请求接口的信息和接口返回的信息，以及获取某些与Token相关的信息。</p>
<h4 id="5、请求过程"><a href="#5、请求过程" class="headerlink" title="5、请求过程"></a>5、请求过程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">Resources</div><div class="line">package com.zy.resource;</div><div class="line"></div><div class="line">import javax.ws.rs.Consumes;</div><div class="line">import javax.ws.rs.GET;</div><div class="line">import javax.ws.rs.Path;</div><div class="line">import javax.ws.rs.Produces;</div><div class="line">import javax.ws.rs.core.MediaType;</div><div class="line"></div><div class="line"></div><div class="line">@Path(&quot;/helloworld&quot;)</div><div class="line">public class RestHelloWorld &#123;</div><div class="line">	</div><div class="line">	@GET</div><div class="line">	@Consumes(MediaType.APPLICATION_JSON)</div><div class="line">	@Produces(&quot;application/json;charset=UTF-8&quot;)</div><div class="line">	public String sayHelloWorld()&#123;</div><div class="line">		return &quot;Hello ZY!!!大苏打&quot;;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>————这是一个简单的获取资源，使用GET方式获取，屏幕输出     Hello ZY!!!大苏打 。</p>
<p>资源类是一个简单的 Java 对象 (POJO)，可以实现任何接口，简单、可重用性强。<br>资源类上的常用注解有：<br>@Path，标注资源类或者方法的相对路径<br>@GET，@PUT，@POST，@DELETE，标注方法是HTTP请求的类型。<br>@Produces，标注返回的MIME媒体类型<br>@Consumes，标注可接受请求的MIME媒体类型<br>@PathParam，@QueryParam，@HeaderParam，@CookieParam，@MatrixParam，@FormParam<br>分别标注方法的参数来自于HTTP请求的不同位置，例如<br>@PathParam来自于URL的路径，<br>@QueryParam来自于URL的查询参数，<br>@HeaderParam来自于HTTP请求的头信息，<br>@CookieParam来自于HTTP请求的Cookie。</p>
<p>##<strong>总结：以上就是一个简单的Jersey框架搭建过程，其中涉及到的很多东西这里没有详细解释，日后深入理解再详谈。</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、什么是Jersey&quot;&gt;&lt;a href=&quot;#一、什么是Jersey&quot; class=&quot;headerlink&quot; title=&quot;一、什么是Jersey&quot;&gt;&lt;/a&gt;一、什么是Jersey&lt;/h2&gt;&lt;p&gt;   Jersey 是一个Java规范（JAX-RS）下的基于Res
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Jersey" scheme="http://yoursite.com/tags/Jersey/"/>
    
  </entry>
  
</feed>
