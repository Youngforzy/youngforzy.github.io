[{"title":"多线程经典实例(一)","url":"/2018/07/20/多线程经典实例(一)/","content":"### 多线程经典实例(一)\n\n在多线程的学习当中，有许多经典的例子值得学习，比如售票窗口、线程交替执行、生产者消费者等。下面就来看两个有关线程交替执行的案例。\n\n#### 两个线程轮流打印数字\n这里采用 wait/notify 等待通知和 Lock/Condition 两种方式实现。\n\n##### wait()/notify()实现\n简单介绍一下wait/notify机制的几个方法。\n以下4个方法都必须在**获取了锁的情况下**才能调用：  \n\n**wait()**: 使当前线程进入阻塞等待状态，直到被唤醒或中断; 调用后立即释放已有的锁；    \n**wait(Long times)**: 使当前线程进入阻塞等待状态一段时间，超过时间后自动唤醒；  \n**notify()**： 唤醒在该对象上等待的一个线程；  \n**notifyAll()**： 唤醒在该对象上等待的所有线程。  \n\n释放锁的场景主要有3种：\n1. **执行完同步方法/代码块**\n2. **执行同步方法/代码块的过程中遇到异常**\n3. **执行同步方法/代码块的过程中调用了锁对象的wait()方法**\n\n```\npublic class TurnsPrintNumber {\n\n    private static Object lock = new Object(); //锁\n    private static int i = 1;\n\n    static class Print implements Runnable{\n        @Override\n        public void run() {\n            while (true) {\n                synchronized (lock) {\n                    if ( i > 20) {\n                        System.out.println(\"打印完毕！\");\n                        lock.notify();\n                        return;\n                    }\n                    System.out.println(\"线程\" + Thread.currentThread().getName() + \"打印：\"  + i ++ );\n                    lock.notify();\n                    try {\n                        Thread.sleep(100);\n                        lock.wait();\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        Print print = new Print();\n        new Thread(print).start();\n        new Thread(print).start();\n    }\n}\n```\n##### Lock/Condition实现\n\n**对于同一个锁（Lock对象）可以创建多个Condition，以便在不同的情况下使用不同的Condition。意思就是Condition可以明确指定唤醒哪一个线程。**\n```\npublic class TurnsPrintNumber2 {\n\n    private static ReentrantLock lock = new ReentrantLock();\n    private Condition a = lock.newCondition();\n    private Condition b = lock.newCondition();\n    static int i = 1;\n\n    private void print () {\n        new Thread(() ->{\n            while (i < 20) {\n                lock.lock();\n                System.out.println(\"线程1打印： \" + i++);\n                try {\n                    a.await(); //将线程1从运行状态->阻塞等待\n                    b.signal();//唤醒线程2\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                } finally {\n                    lock.unlock();\n                }\n            }\n        }).start();\n\n        new Thread(() ->{\n            while (i < 20) {\n                lock.lock();\n                System.out.println(\"线程2打印： \" + i++);\n                try {\n                    a.signal();\n                    b.await();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                } finally {\n                    lock.unlock();\n                }\n            }\n        }).start();\n    }\n\n    public static void main(String[] args) {\n        new TurnsPrintNumber2().print();\n    }\n}\n```\n\n#### 三个线程轮流打印 ABC\n线程1 打印 A，线程2 打印 B，线程3 打印 C， 线程1 打印 A...........\n\n采用以下3种方式实现：\n1. **wait()/notify()方式**\n2. **Lock/Condition方式**\n3. **Semaphore信号量方式**\n\n##### 思路：\n**要在3个线程间实现轮流打印的操作，最重要的就是要控制3个线程的执行顺序。也就是要确定等待、唤醒的顺序，所以每一个线程必须同时持有两个对象锁，才能继续执行。**\n##### wait()/notify()实现\n\n```\npublic class TurnsPrintABCWaitNotify {\n    private static Object alock = new Object();\n    private static Object block = new Object();\n    private static Object clock = new Object();\n\n    public static void main(String[] args) {\n\n        new Thread(() ->{\n            for (int i = 0; i < 5; i++) {\n            synchronized (alock) {  //先获取 A 的锁\n                synchronized (block) { //再获取 B 的锁\n                    System.out.println(\"线程1打印：A\");\n                    block.notify();    //唤醒 B\n                }\n                if (i == 5){return;}//打印5次后结束\n                    try {\n                        alock.wait();  //释放 A 的锁，进入等待阻塞\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        }).start();\n\n        new Thread(() ->{\n            for (int i = 0; i < 5; i++) {\n                synchronized (block) {\n                    synchronized (clock) {\n                        System.out.println(\"线程2打印：B\");\n                        clock.notifyAll();\n                    }\n                    try {\n                        block.wait();\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        }).start();\n\n        new Thread(() ->{\n            for (int i = 0; i < 5; i++) {\n                synchronized (clock) {\n                    synchronized (alock) {\n                        System.out.println(\"线程3打印：C\");\n                        alock.notifyAll();\n                    }\n                    try {\n                        clock.wait();\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        }).start();\n\n    }\n}\n```\n##### Lock/Condition实现\n\n```\npublic class TurnsPrintABCLock {\n\n    private static ReentrantLock lock = new ReentrantLock();\n    private Condition a = lock.newCondition();\n    private Condition b = lock.newCondition();\n    private Condition c = lock.newCondition();\n    int i = 1;\n\n    private void print () {\n        new Thread(() ->{\n            while (i < 10) {\n                lock.lock();\n                System.out.println(\"线程1打印： \" + \"A\");\n                i++;\n                if (i >= 10) {\n                    System.out.println(\"打印完毕！\");\n                    return;\n                }\n                try {\n                    b.signal(); //唤醒线程2\n                    a.await(); //将线程1从运行状态->阻塞等待\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                } finally {\n                    lock.unlock();\n                }\n            }\n        }).start();\n\n        try {\n            Thread.sleep(100);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        new Thread(() ->{\n            while (i < 10) {\n                lock.lock();\n                System.out.println(\"线程2打印： \" +  \"B\");\n                i++;\n                if (i >= 10) {\n                    System.out.println(\"打印完毕！\");\n                    return;\n                }\n                try {\n                    c.signal();\n                    b.await();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                } finally {\n                    lock.unlock();\n                }\n            }\n        }).start();\n\n        try {\n            Thread.sleep(100);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        new Thread(() ->{\n            while (i < 10) {\n                lock.lock();\n                System.out.println(\"线程3打印： \" +  \"C\");\n                i++;\n                if (i >= 10) {\n                    System.out.println(\"打印完毕！\");\n                    return;\n                }\n                try {\n                    a.signal();\n                    c.await();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                } finally {\n                    lock.unlock();\n                }\n            }\n        }).start();\n    }\n\n    public static void main(String[] args) {\n        new TurnsPrintABCLock().print();\n    }\n}\n```\n##### Semaphore信号量实现\n```\npublic class TurnsPrintABCSemaphore {\n    // A初始信号量数量为1\n    private static Semaphore A = new Semaphore(1);\n    // B、C初始信号数量为0\n    private static Semaphore B = new Semaphore(0);\n    private static Semaphore C = new Semaphore(0);\n\n    static class ThreadA extends Thread {\n        @Override\n        public void run() {\n            try {\n                for (int i = 0; i < 10; i++) {\n                    A.acquire();// A获取信号执行,A信号量减1,当A为0时将无法继续获得该信号量\n                    System.out.println(\"线程1打印： \" + \"A\");\n                    B.release();\n                    //System.out.println(B.drainPermits());//B释放之后信号量加1（初始为0），可以查看到 B 的信号量为1\n                }\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    static class ThreadB extends Thread {\n        @Override\n        public void run() {\n            try {\n                for (int i = 0; i < 10; i++) {\n                    B.acquire();\n                    System.out.println(\"线程2打印： \" + \"B\");\n                    C.release();\n                }\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    static class ThreadC extends Thread {\n        @Override\n        public void run() {\n            try {\n                for (int i = 0; i < 10; i++) {\n                    C.acquire();\n                    System.out.println(\"线程3打印： \" + \"C\");\n                    A.release();\n                }\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        new ThreadA().start();\n        new ThreadB().start();\n        new ThreadC().start();\n    }\n}\n```\n\n以上就是有关多个线程交替执行的例子。\n\n#### 扩展\n\n如何保证线程的顺序执行？比如有a，b，c三个线程，如何保证a执行完再执行b，b执行完再执行c？\n1. Join\n2. 线程池（newSingleThreadExecutor）\n3. CountDownLatch/Semaphore\n\n\n","tags":["多线程"],"categories":["技术"]},{"title":"深入浅出ThreadLocal的实现原理","url":"/2018/07/02/深入浅出ThreadLocal的实现原理/","content":"\n### ThreadLocal的简介\n\nThreadLocal称为线程局部变量。在每个线程中都有自己独立的ThreadLocal变量。  \n每个线程中可有多个threadLocal变量。\n\n\n### ThreadLocal的用法\n```\npublic class ThreadLocalDemo {\n\n    private static ThreadLocal<Integer> threadLocal1 = new ThreadLocal<Integer>();\n    private static ThreadLocal<String> threadLocal2 = new ThreadLocal<String>(){\n        @Override\n        protected String initialValue() {\n            return \"默认值\";\n        }\n    };\n\n    public static void main(String[] args) {\n\n        int temp = 100;\n        new Thread(() ->{\n            threadLocal1.set(temp + 1);\n            threadLocal2.set(\"线程A\");\n            System.out.println(\"线程:\" +Thread.currentThread().getName() + \"中 threadLocal1 的值为： \" +  threadLocal1.get());\n            System.out.println(\"线程:\" +Thread.currentThread().getName() + \"中 threadLocal2 的值为： \" +  threadLocal2.get());\n        }).start();\n\n        new Thread(() ->{\n            threadLocal1.set(temp - 1);\n            System.out.println(\"线程:\" +Thread.currentThread().getName() + \"中 threadLocal1 的值为： \" +  threadLocal1.get());\n            System.out.println(\"线程:\" +Thread.currentThread().getName() + \"中 threadLocal2 的值为： \" + threadLocal2.get());\n        }).start();\n\n    }\n}\n```\n输出：\n```\n线程:Thread-0中 threadLocal1 的值为： 101\n线程:Thread-0中 threadLocal2 的值为： 线程A\n线程:Thread-1中 threadLocal1 的值为： 99\n线程:Thread-1中 threadLocal2 的值为： 默认值\n```\n可以看到每个线程都保存着自己独立的变量threadLocal1、threadLocal2，互不影响。\n\n**ThreadLocal实例通常定义成 static 变量，因此每个线程都能访问到该实例。**\n\n抛出问题：为什么每个线程通过ThreadLocal实例时可以拿到自己设置的值？是如何实现的？\n\n### ThreadLocal 的实现原理\n\nThreadLocal类主要有四个方法set()、get()、remove()、setInitialValue()，要想了解它的实现原理，那么就来看看这几个主要方法是如何实现的。\n\n\n#### set() 方法\n```\npublic void set(T value) {\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null)\n            map.set(this, value);\n        else\n            createMap(t, value);\n    }\n```\n##### getMap(): 获取ThreadLocalMap\n```\nThreadLocalMap getMap(Thread t) {\n        return t.threadLocals;\n    }\n    \n```\n**threadLocals变量在线程Thread类中定义：**\n```\nThreadLocal.ThreadLocalMap threadLocals = null;\n```\n每个线程都有一个threadLocals变量即ThreadLocalMap对象，ThreadLocalMap类是ThreadLocal类的静态内部类，用来存储相应的值，总之就是一个Map，后面会详细讲到。\n\n##### createMap(): new 一个ThreadLocalMap\n```\nvoid createMap(Thread t, T firstValue) {\n        t.threadLocals = new ThreadLocalMap(this, firstValue);\n    }\n```\n\nset()方法的过程如下：  \n\n**1. 当前线程调用ThreadLocal.set()方法时，首先获取当前线程对象t;**  \n\n**2. 通过当前线程对象t获取到t线程中的threadLocals，即ThreadLocalMap**\n- 如果ThreadLocalMap存在，那么更新value，key为当前ThreadLocal对象;\n- 如果ThreadLocalMap不存在，那么就根据当前线程对象t创建一个ThreadLocalMap，并将value存入。\n\n\n到这里，基本就能回答开头所提出的的问题，大体上知道了ThreadLocal的实现原理。再来看get()方法的实现。\n\n\n#### get() 方法\n```\npublic T get() {\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null) {\n            ThreadLocalMap.Entry e = map.getEntry(this);\n            if (e != null) {\n                @SuppressWarnings(\"unchecked\")\n                T result = (T)e.value;\n                return result;\n            }\n        }\n        return setInitialValue();\n    }\n```\n从上面可以看到，当调用get() 方法时，实际上就是先从当前线程中获取ThreadLocalMap，然后再根据当前this对象即ThreadLocal对象来获取对应的值。如果map不存在或者this对象的key不存在，那么就返回设置的初始值。\n\n到这里就可以总结一下**ThreadLocal的实现原理：每个线程都有一个自己的ThreadLocalMap对象，用来存储以ThreadLocal为key、Object为值的键值对，线程与线程之间互不影响。**\n\n##### 原理图\n![image](http://osuskkx7k.bkt.clouddn.com/threadlocal.jpg)\n\n#### remove() 方法\n```\n public void remove() {\n         ThreadLocalMap m = getMap(Thread.currentThread());\n         if (m != null)\n             m.remove(this);\n     }\n```\n当ThreadLocal对象调用该方法时，获取到线程的ThreadLocalMap，移除以this对象（该ThreadLocal对象）为key的键值对。\n\n#### setInitialValue() 方法\n```\nprivate T setInitialValue() {\n        T value = initialValue();\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null)\n            map.set(this, value);\n        else\n            createMap(t, value);\n        return value;\n    }\nprotected T initialValue() {\n        return null;\n    }\n```\n该方法主要作用是用来返回初始值，即initialValue()中的值，默认为null，在新建ThreadLocal时可以重写该方法，设置一个初始值。\n\n\n#### ThreadLocalMap\n前面提到，ThreadLocalMap就是存储相应变量的地方。\nThreadLocalMap和大多数容器一样，维护了一个内部数组，即Entry[]数组，Entey节点如下：\n```\nstatic class Entry extends WeakReference<ThreadLocal<?>> {\n            /** The value associated with this ThreadLocal. */\n            Object value;\n\n            Entry(ThreadLocal<?> k, Object v) {\n                super(k);\n                value = v;\n            }\n        }\n```\nEntey是一个以ThreadLocal为key，Object为value的键值对，另外Entey继承了WeakReference（弱引用），在Entry的构造方法中，调用了super(k)方法将ThreadLocal实例包装成一个WeakReference。\n\n##### 为什么使用弱引用（ThreadLocal）作为key？\n如果是强引用的话，ThreadLocalMap中一直会持有ThreadLocal的强引用，如果没有手动删除，那么ThreadLocal对象就无法回收，导致内存泄漏。  \n\n我们知道弱引用无论内存是否足够都会被GC回收。这样当没有强引用指向ThreadLocal对象时就可以被回收，因此也就不会出现ThreadLocal对象的内存泄漏。但还是会出现另一种内存泄漏问题，见下面问题。\n\n\n##### 为什么会引起内存泄漏？什么时候发生内存泄漏？如何防止内存泄漏？\n**在线程的生命周期内发生内存泄漏。**\n\n**我们知道ThreadLocalMap中存储的是key为ThreadLocal的引用，当这个引用失效时即为null时，那么线程中就存在ThreadLocalMap<null, Value>的键值对，此时无法获得对应的Value，于是就存在一条Thread Ref -> Thread -> ThreaLocalMap -> Entry -> Value 强引用链，无法访问到Value，因此就出现了内存泄漏的问题。**\n\n防止内存泄漏：  \n**1. 在ThreadLocalMap的set()、get()、remove()方法中，有一个将key为null的Entry擦除的过程，这样Entry内的value也就没有强引用链，自然会被回收。（不能保证一定擦除）**  \n**2. 当使用完毕后，显示调用remove()方法，直接清除ThreadLocalMap中以ThreadLocal对象为key的键值对;**\n \n##### 扩展\n\n**ThreadLocalMap使用开放地址法来处理Hash冲突**，而不是拉链法(HashMap、concurrentHashMap)。  \n主要原因是：在ThreadLocalMap中的散列值分散的十分均匀，很少会出现冲突。并且ThreadLocalMap经常要清除无用的对象，使用纯数组更加方便。\n\n\n**开放地址法**：当发现有Hash冲突的时候，不会创建链表，而是继续在数组中寻找空的单元。探测数组中空单元的方式有很多，如**线性探测法**：从冲突的数组单元开始，依次往后搜索空单元，如果到了尾部还未找到就再从头开始查找，直到找到为止。\n\n\nThreadLocalMap<ThreadLocal,Object>键值对数量为ThreadLocal的数量，一般来说ThreadLocal数量很少，相比在ThreadLocal中用Map<Thread, Object>键值对存储线程变量（Thread数量一般来说比ThreadLocal数量多），性能提高很多。还有一个原因，如果是使用Map<Thread, Object>的方式存储线程变量，还要考虑到增加减少线程时的并发问题。\n\n\n\n#### 小结  \n- ThreadLocal由于在每个线程中都创建了副本,因此threadLocal会占用一定的内存；是一种空间换时间的思想；  \n- threadLocal只是一个工具，封装了ThreadLocalMap对象方法的入口；\n- threadLocal可以用来解决数据库连接、Session管理等问题，在spring也有大量使用，比如HttpServletRequest也是基于ThreadLocal来实现的。\n- ThreadLocal适用于每个线程需要有自己单独的实例，并且该实例需要在多个方法中共享，但不希望被多线程共享的场景。\n\n","tags":["线程局部变量"],"categories":["技术"]},{"title":"JDK动态代理的实现原理浅析","url":"/2018/06/27/jdk动态代理的实现原理浅析/","content":"\n#### JDK动态代理简介\n什么是JDK动态代理？  \n先看看代理的概念——**代理：为其他对象提供一种代理以控制对这个对象的访问**。  \n\n代理在生活中很常见，比如买火车票可以不去火车站，而是通过代售点；想要逃课了，就让同学代签到等等。\n说白了，就是可以通过代理来完成目标事件。（自我理解）\n\n不同于静态代理直接采用编码的方式实现，JDK动态代理是**利用反射机制在运行时创建代理类**，进而调用相应的方法。\n\n#### JDK动态代理的使用  \n通过一个小例子来看看如何使用JDK动态代理。\n\n##### 目标接口\n```\npublic interface GameService {\n\n    String beginGame(String s);\n\n    void playGame(String s);\n}\n```\n目标接口中定义了两个目标方法。  \n##### 目标对象\n```\npublic class GamePlay implements GameService {\n\n    public String beginGame(String name) {\n        System.out.println(\"玩家\" + name + \"进入召唤师峡谷,游戏开始！\");\n        return \"玩家名字是：\" + name;\n    }\n\n    public void playGame(String s) {\n        System.out.println(\"玩家说： \" +  s);\n    }\n}\n```\n目标对象是目标接口的实现，也是要被代理的对象。\n\n##### 调用处理器——InvocationHandler\n```\npublic class GameInvocationHandler implements InvocationHandler {\n\n    private Object target;\n\n    //构造方法（可传入目标对象）\n    public GameInvocationHandler(Object target) {\n        this.target = target;\n    }\n\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        //业务逻辑\n        System.out.println(\"before-----欢迎来到——动态召唤师峡谷\");\n \n        //方法的返回值（可以为空）\n        Object object = method.invoke(target, args);\n\n        //业务逻辑\n        System.out.println(\"after------欢迎离开——动态召唤师峡谷\");\n        return object;\n    }\n}\n```\nInvocationHandler是调用处理器接口，它只定义了唯一一个 invoke() 方法，通过重写该方法可自定义代理的业务逻辑，该方法三个参数：  \n- proxy：代理类对象（$Proxy0），在该方法中一般不会用到\n- method：被代理类调用的方法对象\n- args：方法对象中的参数\n\n\n##### 创建代理类对象——Proxy.newProxyInstance()\n\n```\npublic class GamePlayDynamicProxy {\n\n\n    public static void main(String[] args) {\n\n        //目标类（实现类）\n        GameService gameService = new GamePlay();\n        \n        //调用处理器\n        InvocationHandler invocationHandler = new GameInvocationHandler(gameService);\n\n        //生成代理对象\n        GameService GameServiceproxy = (GameService) Proxy.newProxyInstance(gameService.getClass().getClassLoader(),\n                gameService.getClass().getInterfaces(), invocationHandler);\n\n        //调用方法,实际上运行的是真实类的方法（打断点可知）\n        GameServiceproxy.playGame(\"我要超神啦！\");\n        \n        //beginGame()可获取返回值\n        //String resultFromInvoke = GameServiceproxy.beginGame(\"LBJ\");\n        //System.out.println(\"InvocationHandler中的返回值：\" + resultFromInvoke);\n    }\n}\n```\n通过Proxy类的静态方法 newProxyInstance() 来创建代理类对象实例，关于其中具体的细节在下面的实现原理中将会提及。\n##### 输出：\n```\nbefore-----欢迎来到——动态召唤师峡谷\n玩家说： 我要超神啦！\nafter------欢迎离开——动态召唤师峡谷\n```\n可见，通过使用动态代理，可以**在目标方法中增加所需要的业务逻辑**（如日志处理、事务管理等）。  \n##### JDK动态代理使用步骤  \n**1. 定义目标方法的接口（必须）**\n\n**2. 实现接口目标方法的实现类（不是必须，如RPC中客户端代理没有实现类/Mybatis中的mapper接口也没有实现类，可在代理过程中实现 ）**\n\n**3. 定义InvocationHandler，在invoke()方法中实现代理的业务逻辑，构造InvocationHandler时可传入必要的参数，以便在invoke()中使用。例如，可传入实现类作为构造参数。**\n\n**4. 调用Proxy.newProxyInstance()生成代理类对象。该方法传入三个参数**：\n- ClassLoader：代理对象的类加载器；\n- Class<?>[] interfaces：代理对象需要实现的接口；\n- InvocationHandler：自定义实现的InvocationHandler\n\n5.通过代理类对象运行目标方法。\n\n\n#### 实现原理\n那么 Java 的动态代理是如何实现的？  \n首先开门见山直接进入生成代理类对象的Proxy.newProxyInstance()方法。\n##### Proxy.newProxyInstance()方法\n```\n    @CallerSensitive\n    public static Object newProxyInstance(ClassLoader loader,\n                                          Class<?>[] interfaces,\n                                          InvocationHandler h)\n        throws IllegalArgumentException\n    {\n        Objects.requireNonNull(h);\n        //克隆传入的接口\n        final Class<?>[] intfs = interfaces.clone();\n        final SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            checkProxyAccess(Reflection.getCallerClass(), loader, intfs);\n        }\n\n        //通过类加载器和指定接口，生成代理类字节码文件，并获取代理类Class对象\n        Class<?> cl = getProxyClass0(loader, intfs);\n\n        try {\n            if (sm != null) {\n                checkNewProxyPermission(Reflection.getCallerClass(), cl);\n            }\n            \n            //获取指定构造函数对象(也就是 $Proxy0(InvocationHandler h))\n            final Constructor<?> cons = cl.getConstructor(constructorParams);\n            final InvocationHandler ih = h;\n            if (!Modifier.isPublic(cl.getModifiers())) {\n                AccessController.doPrivileged(new PrivilegedAction<Void>() {\n                    public Void run() {\n                        cons.setAccessible(true);\n                        return null;\n                    }\n                });\n            }\n            //通过构造函数对象生成代理类对象\n            return cons.newInstance(new Object[]{h});\n        } // catch...省略 \n    }\n```\n在这个方法中主要做了以下工作（如代码中的注释部分）：\n\n1. 通过类加载器和指定接口，生成代理类字节码文件，并获取代理类Class对象cl；\n\n2. 通过Class对象cl获取指定的构造函数对象cons；\n\n3. 构造函数对象cons，通过方法中传入的InvocationHandler，生成一个实例，这个实例就是代理类对象。\n\n可见**反射**在上述代码中起了重要作用。  \n\n大致了解了代理类对象是如何生成的，那么被代理的方法是如何调用的呢？ InvocationHandler中重写的invoke()方法又是如何调用的呢？接下来我们就来看看代理类究竟长什么模样。\n##### 反编译\n\n参考其他文章可知最终生成代理类的字节码是这样一行代码：\n```\n//生成字节码\nbyte[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces, accessFlags);\n```\n调用了ProxyGenerator.generateProxyClass()方法, 因此我们可以通过该方法测试生成的代理类对象Class文件，并对其进行反编译，查看生成的具体代理类究竟是什么模样。\n\n先获取代理类Class文件：\n```\npublic static void main(String[] args) {\n\n        byte[] proxyBytes = ProxyGenerator.generateProxyClass(\"ProxyObject\", new Class[]{GameService.class});\n        File file = new File(\"E:\\\\ProxyObject.class\");\n        try {\n            FileOutputStream out = new FileOutputStream(file);\n            out.write(proxyBytes);\n            out.flush();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n```\n将获取到的Class文件存入E盘，即ProxyObject.class文件，然后再通过一个[在线反编译](http://www.javadecompilers.com/)的网站进行反编译，获取代理类的源码：\n```\nimport com.proxy.GameService;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\nimport java.lang.reflect.UndeclaredThrowableException;\n\npublic final class ProxyObject\n  extends Proxy\n  implements GameService\n{\n  private static Method m1;\n  private static Method m2;\n  private static Method m4;\n  private static Method m0;\n  private static Method m3;\n  \n  public ProxyObject(InvocationHandler paramInvocationHandler)\n  {\n    super(paramInvocationHandler);\n  }\n  \n  public final boolean equals(Object paramObject)\n  {\n    try\n    {\n      return ((Boolean)h.invoke(this, m1, new Object[] { paramObject })).booleanValue();\n    }\n    catch (Error|RuntimeException localError)\n    {\n      throw localError;\n    }\n    catch (Throwable localThrowable)\n    {\n      throw new UndeclaredThrowableException(localThrowable);\n    }\n  }\n  \n  public final String toString()\n  {\n    try\n    {\n      return (String)h.invoke(this, m2, null);\n    }\n    catch (Error|RuntimeException localError)\n    {\n      throw localError;\n    }\n    catch (Throwable localThrowable)\n    {\n      throw new UndeclaredThrowableException(localThrowable);\n    }\n  }\n  \n  public final void playGame(String paramString)\n  {\n    try\n    {\n      h.invoke(this, m4, new Object[] { paramString });\n      return;\n    }\n    catch (Error|RuntimeException localError)\n    {\n      throw localError;\n    }\n    catch (Throwable localThrowable)\n    {\n      throw new UndeclaredThrowableException(localThrowable);\n    }\n  }\n  \n  public final int hashCode()\n  {\n    try\n    {\n      return ((Integer)h.invoke(this, m0, null)).intValue();\n    }\n    catch (Error|RuntimeException localError)\n    {\n      throw localError;\n    }\n    catch (Throwable localThrowable)\n    {\n      throw new UndeclaredThrowableException(localThrowable);\n    }\n  }\n  \n  public final String beginGame(String paramString)\n  {\n    try\n    {\n      return (String)h.invoke(this, m3, new Object[] { paramString });\n    }\n    catch (Error|RuntimeException localError)\n    {\n      throw localError;\n    }\n    catch (Throwable localThrowable)\n    {\n      throw new UndeclaredThrowableException(localThrowable);\n    }\n  }\n  \n  static\n  {\n    try\n    {\n      m1 = Class.forName(\"java.lang.Object\").getMethod(\"equals\", new Class[] { Class.forName(\"java.lang.Object\") });\n      m2 = Class.forName(\"java.lang.Object\").getMethod(\"toString\", new Class[0]);\n      m4 = Class.forName(\"com.proxy.GameService\").getMethod(\"playGame\", new Class[] { Class.forName(\"java.lang.String\") });\n      m0 = Class.forName(\"java.lang.Object\").getMethod(\"hashCode\", new Class[0]);\n      m3 = Class.forName(\"com.proxy.GameService\").getMethod(\"beginGame\", new Class[] { Class.forName(\"java.lang.String\") });\n      return;\n    }\n    catch (NoSuchMethodException localNoSuchMethodException)\n    {\n      throw new NoSuchMethodError(localNoSuchMethodException.getMessage());\n    }\n    catch (ClassNotFoundException localClassNotFoundException)\n    {\n      throw new NoClassDefFoundError(localClassNotFoundException.getMessage());\n    }\n  }\n}\n```\n观察上述代理类源码可以发现，包含了GameService接口中定义的两个方法playGame()和beginGame()。并且，\n**当代理类对象调用目标方法时，实际上调用的就是InvocationHandler中的invoke()方法，因此也就解释代理类是如何与invoke()方法相关联的。**\n```\n以playGame方法为例：\npublic final void playGame(String paramString) 即调用了\n h.invoke(this, m4, new Object[] { paramString });\n h：构建代理类传入的InvocationHandler\n m4: static 代码块中定义的method实例\n paramString：参数\n```\n##### 代理类特性\n观察上述代理类源码，发现动态生成的代理类有以下特点：  \n\n**1. 继承了Proxy类，实现了所代理的接口（不能再继承其他类）;**  \n\n**2. 除了包含所代理的接口方法，还有Object类的equals()、hashCode()、toString()三个方法，目的应该是防止重写保证和目标类一致；**  \n\n**3. 每一个方法都会执行调用处理器的 invoke() 方法（在其中可实现自定义的逻辑）；**\n\n**4. 提供了一个使用InvocationHandler作为参数的构造方法，通过前面源码分析也能知道；**\n \n**5. 每个代理类实例都会关联一个调用处理器对象。传入不同的调用处理器对象可生成不同的代理类对象。**\n\n\n","tags":["代理模式"],"categories":["技术"]},{"title":"基数排序的简单实现","url":"/2018/06/24/基数排序/","content":"### 基数排序\n\n**基数排序是一种基于分配的排序（空间换时间）**，不同于常见的基于比较的排序（冒泡、快排、归并...等）。  \n\n**基于比较的排序时间复杂度通常是O（n^2）或者O（nlogn），下限是O（nlogn）；**  \n\n**基于分配的排序算法的时间复杂度可以达到O（n），但需要消耗额外空间；**\n\n在某些时候，基数排序的效率高于其它基于比较的排序算法（快排、归并等）。\n\n\n#### 原理\n\n原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。进行了c次（c是整数的位数）比较之后，得到一个有序的数组。  \n基数排序是桶排序的扩展，每一次排序建立在桶排序的基础上。\n\n\n##### 步骤\n**1. 将每个数字统一位数长度（数位短的前面补0）；**  \n**2. 从最低位（个位）开始，依次进行每次排序；**  \n**3. 最高位排序完成后，数组就变成了有序数组。**\n\n\n#### 实例分析\n通过基数排序对一个无序数组进行排序{53, 542, 3, 63, 14, 214, 154, 748, 616}，它的示意图如下：\n\n![image](http://osuskkx7k.bkt.clouddn.com/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F.jpg)\n\n##### 比较过程\n结合上图分析比较过程。    \n**每次比较，根据相应位数上的值，将元素放入对应的桶（0-10）中。**\n\n![](http://osuskkx7k.bkt.clouddn.com/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%E8%A1%A8.png)\n\n经过第三次排序，如图一，得到一个有序的数组。\n\n#### 实现\n\n\n##### 计算排序的次数\n\n排序的次数即数组统一的位数（也是最大元素的位数），在这里是 3 位，总共需要比较3次。\n\n```\n        //获取最大值\n        int max = a[0];\n        for (int i = 0; i < a.length; i++) {\n            if (max < a[i]) {\n                max = a[i];\n            }\n        }\n        //根据最大值确定排序的遍数（如369三位数，就是3遍）\n        int time = 0;\n        while (max > 0) {\n            max = max / 10;\n            time ++;\n        }\n```\n##### 排序过程\n每一次排序之后，都要根据排序的结果记录新的顺序，以便下一次排序。  \n思路如下：  \n**1. 将桶数组看成是一个只有10个元素（0-9）的队列，建立该队列（父队列）；**\n**2. 父队列中的每一个元素都代表一个子队列，用于存放每个桶中的元素，可能0个也可能多个；**\n\n注：采用数组ArrayList来代替子队列，也可以采用链表\n```\n        //建立一个主队列，包含10个子队列\n        List<ArrayList> queue = new ArrayList<ArrayList>();\n        for (int i = 0; i < 10; i++) {\n            ArrayList<Integer> subQueue = new ArrayList<>();\n            queue.add(subQueue);\n        }\n```\n\n**3. 分配数组元素**\n\n将每一个数组元素分配进入相应的桶中，即子队列中。  \n每次分配时，i 的值表示获取元素对应位数上的数字：  \ni = 0 ，表示个位；  \ni= 1，表示十位；  \ni = 2， 表示百位；\n```\n            //分配数组元素\n            for (int j = 0; j < a.length; j++) {\n                int c = a[j] % (int)Math.pow(10, i + 1); //当前位上的数字\n                int x = c / (int)Math.pow(10, i); //子队列的序号\n                //System.out.println(x);\n                ArrayList<Integer> subQueue = queue.get(x);  //从父队列获取子队列\n                subQueue.add(a[j]);\n                queue.set(x, subQueue);\n            }\n```\n\n##### 代码实现\n\n\n```\n public static void radisSort(int[] a) {\n\n        //获取最大值\n        int max = a[0];\n        for (int i = 0; i < a.length; i++) {\n            if (max < a[i]) {\n                max = a[i];\n            }\n        }\n        //根据最大值确定排序的遍数（如369三位数，3遍）\n        int time = 0;\n        while (max > 0) {\n            max = max / 10;\n            time ++;\n        }\n        //建立一个主队列，包含10个子队列\n        List<ArrayList> queue = new ArrayList<ArrayList>();\n        for (int i = 0; i < 10; i++) {\n            ArrayList<Integer> subQueue = new ArrayList<>();\n            queue.add(subQueue);\n        }\n        //time次排序\n        for (int i = 0; i < time; i++) {\n\n            //分配数组元素\n            for (int j = 0; j < a.length; j++) {\n                int c = a[j] % (int)Math.pow(10, i + 1); //当前位上的数字\n                int x = c / (int)Math.pow(10, i); //子队列的序号\n                //System.out.println(x);\n                ArrayList<Integer> subQueue = queue.get(x);  //从父队列获取子队列\n                subQueue.add(a[j]);\n                queue.set(x, subQueue);\n            }\n            //分配结束后，记录新的顺序\n            int k = 0;\n            for (int n = 0; n < 10; n++) {\n                //取出有元素的子队列\n                while (queue.get(n).size() > 0) {\n                    ArrayList<Integer> subQueue = queue.get(n);\n                    a[k ++] = subQueue.get(0);  //头部元素\n                    subQueue.remove(0);  //移除元素\n                }\n            }\n            //打印每次排序后的新数组\n//            for (int m : a) {\n//                System.out.print(m + \" \");\n//            }\n        }\n        //打印最终排好序的数组\n        for (int m : a) {\n            System.out.print(m + \" \");\n        }\n\n    }\n\n    public static void main(String[] args) {\n        int[] a = {53, 542, 3, 63, 14, 214, 154, 748, 616};\n        radisSort(a);\n    }\n```\n\n输出：\n\n```\n3 14 53 63 154 214 542 616 748 \n```\n\n以上，就是基数排序的大致过程。\n\n\n\n\n\n\n\n\n\n","tags":["基数排序"],"categories":["技术"]},{"title":"ActiveMQ结合Spring收发消息","url":"/2018/02/15/ActiveMQ结合Spring收发消息/","content":"\n### ActiveMQ结合Spring收发消息\n\n直接使用ActiveMQ的方式需要重复写很多代码，且不利于管理，Spring 提供了一种更加简便的方式————Spring JMS ，通过它可以更加方便地使用ActiveMQ。\n\n#### Maven 依赖  \n\n结合Spring使用ActiveMQ的依赖如下：\n```\n        <!-- Spring JMS -->\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-jms</artifactId>\n            <version>${spring.version}</version>\n        </dependency>\n        <!-- xbean 如<amq:connectionFactory /> -->\n        <dependency>\n            <groupId>org.apache.xbean</groupId>\n            <artifactId>xbean-spring</artifactId>\n            <version>3.16</version>\n        </dependency>\n        <!-- ActiiveMQ -->\n        <dependency>\n            <groupId>org.apache.activemq</groupId>\n            <artifactId>activemq-core</artifactId>\n            <version>5.7.0</version>\n        </dependency>\n        <dependency>\n            <groupId>org.apache.activemq</groupId>\n            <artifactId>activemq-pool</artifactId>\n            <version>5.7.0</version>\n        </dependency>\n```\n\n\n#### ActiveMQ.xml 文件\n\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:amq=\"http://activemq.apache.org/schema/core\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans-4.0.xsd\n        http://activemq.apache.org/schema/core\n        http://activemq.apache.org/schema/core/activemq-core-5.12.1.xsd\">\n    <!-- ActiveMQ 连接工厂 -->\n    <amq:connectionFactory id=\"amqConnectionFactory\"\n                           brokerURL=\"tcp://localhost:61616\"\n                           userName=\"admin\"\n                           password=\"admin\" />\n\n    <!-- 提高效率，配置JMS连接工厂 -->\n    <bean id=\"connectionFactory\" class=\"org.springframework.jms.connection.CachingConnectionFactory\">\n        <constructor-arg ref=\"amqConnectionFactory\" />\n        <property name=\"sessionCacheSize\" value=\"100\" />\n    </bean>\n    <!-- 定义消息队列（Queue）-->\n   <!-- <bean id=\"QueueDestination\" class=\"org.apache.activemq.command.ActiveMQQueue\">\n        &lt;!&ndash; 设置消息队列的名字 &ndash;&gt;\n        <constructor-arg value=\"Queue-zy\"/>\n    </bean>-->\n    <!--定义主题(Topic)-->\n    <bean id=\"topicDestination\" class=\"org.apache.activemq.command.ActiveMQTopic\">\n        <constructor-arg value=\"Topic-zy\"/>\n    </bean>\n    <!-- 配置JMS模板（Queue），Spring提供的JMS工具类，利用它发送、接收消息。 -->\n    <bean id=\"jmsTemplate\" class=\"org.springframework.jms.core.JmsTemplate\">\n        <property name=\"connectionFactory\" ref=\"connectionFactory\" />\n        <property name=\"defaultDestination\" ref=\"topicDestination\" />\n        <property name=\"receiveTimeout\" value=\"10000\" />\n        <!-- true是topic，false是queue，默认是false -->\n        <property name=\"pubSubDomain\" value=\"true\" />\n    </bean>\n    <!-- 配置消息队列监听者（Queue or Topic） -->\n    <bean id=\"messageListener\" class=\"com.service.TopicMessageListener\" />\n\n    <!-- 显示注入消息监听容器，配置连接工厂，监听的目标是QueueDestination，监听器是上面定义的监听器 -->\n    <bean id=\"ListenerContainer\"\n          class=\"org.springframework.jms.listener.DefaultMessageListenerContainer\">\n        <property name=\"connectionFactory\" ref=\"connectionFactory\" />\n        <property name=\"destination\" ref=\"topicDestination\" />\n        <property name=\"messageListener\" ref=\"messageListener\" />\n    </bean>\n</beans>\n```\n\n##### 配置connectionFactory \n\nconnectionFactory是Spring用于创建到JMS服务器链接的，Spring提供了多种connectionFactory.\n\n```\n    <!-- ActiveMQ 连接工厂 -->\n    <amq:connectionFactory id=\"amqConnectionFactory\"\n                           brokerURL=\"tcp://localhost:61616\"\n                           userName=\"admin\"\n                           password=\"admin\" />\n\n    <!-- 提高效率，配置JMS连接工厂 -->\n    <bean id=\"connectionFactory\" class=\"org.springframework.jms.connection.CachingConnectionFactory\">\n        <constructor-arg ref=\"amqConnectionFactory\" />\n        <property name=\"sessionCacheSize\" value=\"100\" />\n    </bean>\n```\n\n##### 配置Queue\n\n```\n <bean id=\"QueueDestination\" class=\"org.apache.activemq.command.ActiveMQQueue\">\n        <!-- 设置消息队列的名字 -->\n        <constructor-arg value=\"Queue-zy\"/>\n </bean>\n```\n\n##### 配置Topic\n\n```\n<bean id=\"topicDestination\" class=\"org.apache.activemq.command.ActiveMQTopic\">\n        <constructor-arg value=\"Topic-zy\"/>\n</bean>\n```\n##### 配置JMS消息模板——jmsTemplate\n\n```\n    <!-- 配置JMS模板，Spring提供的JMS工具类，利用它发送、接收消息-->\n    <bean id=\"jmsTemplate\" class=\"org.springframework.jms.core.JmsTemplate\">\n        <property name=\"connectionFactory\" ref=\"connectionFactory\" />\n        <property name=\"defaultDestination\" ref=\"QueueDestination\" />\n        <!--<property name=\"defaultDestination\" ref=\"topicDestination\" />-->\n        <property name=\"receiveTimeout\" value=\"10000\" />\n        <property name=\"pubSubDomain\" value=\"false\" /><!-- true是topic，false是queue，默认是false -->\n    </bean>\n```\n最后，在applicationContext.xml中引入配置好的ActiveMQ.xml\n```\n<import resource=\"ActiveMQ.xml\" />\n```\n以上就是配置文件相关的，下面是具体的业务代码。\n\n#### 消息生产者服务\n\n```\n@Service\npublic class ProducerService {\n\n    @Autowired\n    private JmsTemplate jmsTemplate;\n\n    //使用默认目的地\n    public void sendMessageDefault(final String msg){\n        Destination destination = jmsTemplate.getDefaultDestination();\n        System.out.println(\"向队列： \" + destination + \" 成功发送一条消息\");\n        jmsTemplate.send(new MessageCreator() {\n            public Message createMessage(Session session) throws JMSException {\n                return session.createTextMessage(msg);\n            }\n        });\n    }\n\n    //可指定目的地\n    public void sendMessage(Destination destination,final String msg){\n\n        jmsTemplate.send(destination, new MessageCreator() {\n            public Message createMessage(Session session) throws JMSException {\n                return session.createTextMessage(msg);\n            }\n        });\n    }\n}\n```\n#### 消息消费者服务\n```\n@Service\npublic class ConsumerService {\n\n    @Autowired\n    private JmsTemplate jmsTemplate;\n\n    //从指定的Destination接收消息\n    public TextMessage recive(Destination destination){\n        TextMessage message = (TextMessage) jmsTemplate.receive(destination);\n        try {\n            System.out.println(\"从队列\" + destination.toString() + \"收到了消息\" + message.getText());\n        } catch (JMSException e) {\n            e.printStackTrace();\n        }\n        return message;\n    }\n\n    //从默认的Destination接收消息\n    public void reciveDefault(){\n    \n        Destination destination = jmsTemplate.getDefaultDestination();\n        jmsTemplate.setReceiveTimeout(5000);\n        while(true){\n            TextMessage message = (TextMessage) jmsTemplate.receive(destination);\n            try {\n                //这里还是同一个消费者\n                System.out.println(\"消费者  从目的地 \" + destination.toString() + \" 收到了消息\" + message.getText());\n            } catch (JMSException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n\n```\n#### 生产者\n\n直接在main方法中获取ApplicationContext运行，便于测试。\n```\n@Component\npublic class MsgProducer {\n\n    @Autowired\n    private ProducerService producerService;\n\n    public void send(){\n        System.out.println(\"生产者开始发送消息：\");\n        for(int i = 1; i < 11; i++){\n            String msg = \"生产者发出的消息\";\n            producerService.sendMessageDefault(msg + \"-----\" + i);\n        }\n    }\n\n    public static void main(String[] args) {\n        ApplicationContext context = new ClassPathXmlApplicationContext(\"classpath:/applicationContext.xml\");\n        MsgProducer msgProducer = context.getBean(MsgProducer.class);\n        msgProducer.send();\n    }\n\n}\n```\n#### 消费者\n\n```\n@Component\npublic class MsgConsumer {\n\n    @Autowired\n    private ConsumerService consumerService;\n\n    public void recive(){\n        System.out.println(\"消费者 1 开始接收消息：\");\n        consumerService.reciveDefault();\n    }\n\n    public static void main(String[] args) {\n\n        ApplicationContext context = new ClassPathXmlApplicationContext(\"classpath:/applicationContext.xml\");\n        MsgConsumer msgConsumer = context.getBean(MsgConsumer.class);\n        msgConsumer.recive();\n    }\n}\n```\n\n\n\n\n接下来就可以启动项目。同样是使用两种方式测试。\n\n#### 第一种方式————点对点（Queue）\n\n#### 同步的方式\n先启动生产者  发送10条消息， 再启动消费者，可以看到控制台显示成功收到10条消息  \n\n![image](http://osuskkx7k.bkt.clouddn.com/%E7%82%B9%E5%AF%B9%E7%82%B9%E7%94%9F%E4%BA%A7.png)\n\n![image](http://osuskkx7k.bkt.clouddn.com/%E7%82%B9%E5%AF%B9%E7%82%B9%E6%B6%88%E8%B4%B9.jpg)\n\n#### 异步监听的方式\n\n通过监听器即可实现异步接收消息的效果，而不是像上面使用while()轮询同步的方式。\n项目中一般都是使用异步监听的方式，**在A服务中发送了一条消息，B服务可以利用消息监听器监听，当收到消息后，进行相应的操作**。\n\n##### 消息监听器（3种）\n通过继承JMS中的**MessageListener接口**，实现onMessage()方法，就可以自定义监听器。这是最基本的监听器。（可根据业务实现自定义的功能）\n\n另外spring也给我们提供了其他类型的消息监听器，比如 **SessionAwareMessageListener**，它的作用不仅可以接收消息，还可以发送一条消息通知对方表示自己收到了消息。（还有一种是**MessageListenerAdapter**）\n\n一个简单的自定义监听器如下:收到消息后打印消息\n```\npublic class QueueMessageListener implements MessageListener {\n\n    public void onMessage(Message message) {\n        //如果有消息\n        TextMessage tmessage = (TextMessage) message;\n        try {\n            if(tmessage != null){\n                System.out.println(\"监听器监听消息：\"+tmessage.getText());\n            }\n        } catch (JMSException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n在ActiveMQ.xml中引入消息监听器：\n```\n<!-- 配置消息队列监听者（Queue） -->\n    <bean id=\"queueMessageListener\" class=\"com.service.QueueMessageListener\" />\n    \n <!-- 显示注入消息监听容器，配置连接工厂，监听的目标是QueueDestination 或 topicDestination，监听器是上面自定义的监听器 -->\n    <bean id=\"queueListenerContainer\"\n          class=\"org.springframework.jms.listener.DefaultMessageListenerContainer\">\n        <property name=\"connectionFactory\" ref=\"connectionFactory\" />\n        <property name=\"destination\" ref=\"QueueDestination\" />\n        <!--<property name=\"destination\" ref=\"topicDestination\" />-->\n        <property name=\"messageListener\" ref=\"queueMessageListener\" />\n    </bean>\n```\n可以看到，当使用消息监听器之后，每发送一条消息立马就会被监听到：  \n\n![image](http://osuskkx7k.bkt.clouddn.com/%E7%82%B9%E5%AF%B9%E7%82%B9%E7%9B%91%E5%90%AC%E5%99%A8.jpg)\n\n#### 第二种方式————发布/订阅（Topic）\n#### 同步的方式\n类似点对点中同步的方式，只是每个消费者都能收到生产者发出的全部消息，不再赘述。\n\n#### 异步监听的方式\n启动两个监听器（两个消费者），对消息进行异步监听。看是否各自能收到生产者发送的消息。\n\n\n```\n<!-- 配置两个监听器 -->\n    <bean id=\"messageListener\" class=\"com.service.TopicMessageListener\" />\n    <bean id=\"messageListener2\" class=\"com.service.TopicMessageListener2\" />\n```\n\n![image](http://osuskkx7k.bkt.clouddn.com/%E4%B8%A4%E4%B8%AA%E7%9B%91%E5%90%AC%E5%99%A8.jpg)\n\n可以看到，每个监听器各自都收到了生产者发送的10条消息。","tags":["消息队列"],"categories":["技术"]},{"title":"ActiveMQ的简单使用","url":"/2018/02/12/ActiveMQ的简单使用/","content":"\n### ActiveMQ的简单使用\n\nActiveMQ 是一种消息队列，是Apache提供的一个开源消息系统，完全采用Java实现，因此，它能很好地支持J2EE提出的JMS（Java Message Service,即Java消息服务）规范。\n\n#### 第一种方式（点对点）——Queue\n##### 生产者\n```java\nimport org.apache.activemq.ActiveMQConnectionFactory;\nimport javax.jms.*;\n\npublic class Producer {\n\n    public static void main(String[] args) {\n\n        //连接工厂\n        ConnectionFactory connectionFactory;\n        //连接\n        Connection connection = null;\n        //会话\n        Session session;\n        //目的地\n        Destination destination;\n        //消息生产者\n        MessageProducer messageProducer;\n\n        try {\n            connectionFactory = new ActiveMQConnectionFactory(ActiveMQConnectionFactory.DEFAULT_USER,ActiveMQConnectionFactory.DEFAULT_PASSWORD,\n                    ActiveMQConnectionFactory.DEFAULT_BROKER_URL);\n            connection = connectionFactory.createConnection();\n            connection.start();\n            session = connection.createSession(false,Session.AUTO_ACKNOWLEDGE);   //不开启事务\n\n            destination = session.createQueue(\"Queue-zy\");\n            messageProducer = session.createProducer(destination);\n            messageProducer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);       //是否持久化（默认持久化）\n\n            for(int i = 1; i<11; i++){\n                System.out.println(\"生产者成功发出消息——Queue-zy：序号---\"+i);\n                TextMessage message = session.createTextMessage(\"消息-----\"+i+\"-------hello,MQ!\");\n                messageProducer.send(message);\n            }\n\n        } catch (JMSException e) {\n            e.printStackTrace();\n        } finally{\n            try {\n                connection.close();\n            } catch (JMSException e) {\n                e.printStackTrace();\n            }\n        }\n\n\n    }\n\n}\n```\n控制台打印出发送消息成功的语句，总计10条消息：\n\n```\n生产者成功发出消息——Queue-zy：序号---1\n生产者成功发出消息——Queue-zy：序号---2\n生产者成功发出消息——Queue-zy：序号---3\n生产者成功发出消息——Queue-zy：序号---4\n生产者成功发出消息——Queue-zy：序号---5\n生产者成功发出消息——Queue-zy：序号---6\n生产者成功发出消息——Queue-zy：序号---7\n生产者成功发出消息——Queue-zy：序号---8\n生产者成功发出消息——Queue-zy：序号---9\n生产者成功发出消息——Queue-zy：序号---10\n```\n![image](http://osuskkx7k.bkt.clouddn.com/Queue1%20%282%29.jpg)\n此时，打开ActiveMQ的管理页面，点击Queues，便可看到一个名为 Queue-zy 的队列：  \nNumber Of Pending Messages ：表示等待被消费的消息数为 10  \n\nMessages Enqueued：  表示进入队列的消息数为 10  （可叠加）\n\nMessages Dequeued：  表示出队列的消息，此时为0  \n\n##### 消费者\n```\nimport org.apache.activemq.ActiveMQConnectionFactory;\nimport javax.jms.*;\n\npublic class Consumer {\n\n    public static void main(String[] args) {\n\n        //连接工厂\n        ConnectionFactory connectionFactory;\n        //连接\n        Connection connection = null;\n        //会话\n        Session session;\n        //目的地\n        Destination destination;\n        //消息生产者\n        MessageConsumer messageConsumer ;\n\n        try {\n            connectionFactory = new ActiveMQConnectionFactory(ActiveMQConnectionFactory.DEFAULT_USER,ActiveMQConnectionFactory.DEFAULT_PASSWORD,\n                    ActiveMQConnectionFactory.DEFAULT_BROKER_URL);\n            connection = connectionFactory.createConnection();\n            connection.start();\n\n            session = connection.createSession(false,Session.AUTO_ACKNOWLEDGE);\n            destination = session.createQueue(\"Queue-zy\");\n            messageConsumer = session.createConsumer(destination);\n\n            while(true){\n                TextMessage textMessage = (TextMessage) messageConsumer.receive(10000);\n                if(textMessage != null){\n                    System.out.println(\"消费者成功接收到消息： \"+textMessage.getText());\n                }else{\n                    break;\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally{\n            try {\n                connection.close();\n            } catch (JMSException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n点击Run启动消费者Main()，可以看到控制台输出，成功接收10条消息：\n```\n消费者成功接收到消息： 消息-----1-------hello,MQ!\n消费者成功接收到消息： 消息-----2-------hello,MQ!\n消费者成功接收到消息： 消息-----3-------hello,MQ!\n消费者成功接收到消息： 消息-----4-------hello,MQ!\n消费者成功接收到消息： 消息-----5-------hello,MQ!\n消费者成功接收到消息： 消息-----6-------hello,MQ!\n消费者成功接收到消息： 消息-----7-------hello,MQ!\n消费者成功接收到消息： 消息-----8-------hello,MQ!\n消费者成功接收到消息： 消息-----9-------hello,MQ!\n消费者成功接收到消息： 消息-----10-------hello,MQ!\n```\n![image](http://osuskkx7k.bkt.clouddn.com/Queue-2.jpg)\n\n再次查看ActiveMQ的管理页面，点击Queues  \n\nNumber Of Pending Messages ：等待被消费的消息数变为 0，此时消息已经全部被消费  \n\nMessages Enqueued： 进入队列的消息数为 10  （叠加）  \n\nMessages Dequeued： 出队列的消息，此时为10  \n\n#### 第二种方式（发布/订阅）——Topic\n\n**两种方式的代码只有一处区别：由Session创建的目的地不同**\n\n```\n    //Queue\n    destination = session.createQueue(\"Queue-zy\");\n    //Topic\n    destination = session.createTopic(\"Topic-zy\");\n```\n注意：**先启动订阅者（消费者），再启动发布者（生产者）————因为在没有实现订阅消息持久化的情况下，只能在订阅者上线后才能接收到发布者发布的消息。**\n\n##### 生产者\n```\nimport org.apache.activemq.ActiveMQConnectionFactory;\nimport javax.jms.*;\n\npublic class Producer {\n\n    public static void main(String[] args) {\n\n        //连接工厂\n        ConnectionFactory connectionFactory;\n        //连接\n        Connection connection = null;\n        //会话\n        Session session;\n        //目的地\n        Destination destination;\n        //消息生产者\n        MessageProducer messageProducer;\n\n        try {\n            connectionFactory = new ActiveMQConnectionFactory(ActiveMQConnectionFactory.DEFAULT_USER,ActiveMQConnectionFactory.DEFAULT_PASSWORD,\n                    ActiveMQConnectionFactory.DEFAULT_BROKER_URL);\n            connection = connectionFactory.createConnection();\n            connection.start();\n            session = connection.createSession(false,Session.AUTO_ACKNOWLEDGE);   //不开启事务\n\n            //destination = session.createQueue(\"Queue-zy\");\n            destination = session.createTopic(\"Topic-zy\");\n            messageProducer = session.createProducer(destination);\n            messageProducer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);       //是否持久化（默认持久化）\n\n            for(int i = 1; i<11; i++){\n                System.out.println(\"生产者成功发出消息——Topic-zy：序号---\"+i);\n                TextMessage message = session.createTextMessage(\"消息-----\"+i+\"-------hello,MQ!\");\n                messageProducer.send(message);\n            }\n        } catch (JMSException e) {\n            e.printStackTrace();\n        } finally{\n            try {\n                connection.close();\n            } catch (JMSException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n##### 消费者 1\n```\nimport org.apache.activemq.ActiveMQConnectionFactory;\n\nimport javax.jms.*;\n\npublic class Consumer {\n\n    public static void main(String[] args) {\n\n        //连接工厂\n        ConnectionFactory connectionFactory;\n        //连接\n        Connection connection = null;\n        //会话\n        Session session;\n        //目的地\n        Destination destination;\n        //消息生产者\n        MessageConsumer messageConsumer ;\n\n        try {\n            connectionFactory = new ActiveMQConnectionFactory(ActiveMQConnectionFactory.DEFAULT_USER,ActiveMQConnectionFactory.DEFAULT_PASSWORD,\n                    ActiveMQConnectionFactory.DEFAULT_BROKER_URL);\n            connection = connectionFactory.createConnection();\n            connection.start();\n            session = connection.createSession(false,Session.AUTO_ACKNOWLEDGE);\n\n            //destination = session.createQueue(\"Queue-zy\");\n            destination = session.createTopic(\"Topic-zy\");\n            messageConsumer = session.createConsumer(destination);\n\n            while(true){\n                TextMessage textMessage = (TextMessage) messageConsumer.receive(10000);\n                if(textMessage != null){\n                    System.out.println(\"消费者 1 成功接收到消息： \"+textMessage.getText());\n                }else{\n                    break;\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n##### 消费者 2\n\n```\nimport org.apache.activemq.ActiveMQConnectionFactory;\nimport javax.jms.*;\n\npublic class Consumer2 {\n    public static void main(String[] args) {\n\n        //连接工厂\n        ConnectionFactory connectionFactory;\n        //连接\n        Connection connection = null;\n        //会话\n        Session session;\n        //目的地\n        Destination destination;\n        //消息生产者\n        MessageConsumer messageConsumer ;\n\n        try {\n            connectionFactory = new ActiveMQConnectionFactory(ActiveMQConnectionFactory.DEFAULT_USER,ActiveMQConnectionFactory.DEFAULT_PASSWORD,\n                    ActiveMQConnectionFactory.DEFAULT_BROKER_URL);\n            connection = connectionFactory.createConnection();\n            connection.start();\n            session = connection.createSession(false,Session.AUTO_ACKNOWLEDGE);\n\n            //destination = session.createQueue(\"Queue-zy\");\n            destination = session.createTopic(\"Topic-zy\");\n            messageConsumer = session.createConsumer(destination);\n\n            while(true){\n                TextMessage textMessage = (TextMessage) messageConsumer.receive(10000);\n                if(textMessage != null){\n                    System.out.println(\"消费者 2 成功接收到消息： \"+textMessage.getText());\n                }else{\n                    break;\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n先启动消费者 1 和 2，再启动生产者，可以看到控制台输出，消费者 1 、2都接收到了消息:\n\n![image](http://osuskkx7k.bkt.clouddn.com/c1.jpg)\n\n![image](http://osuskkx7k.bkt.clouddn.com/c2.jpg)\n\n![image](http://osuskkx7k.bkt.clouddn.com/Topic-2.jpg)\n\n查看ActiveMQ的管理页面，点击Topics，查看名为 Topic-zy 的主题：    \n\nNumber Of Consumers ：表示消费者数目为 2    \n\nMessages Enqueued： 进入队列的消息数为 10    \n\nMessages Dequeued： 出队列的消息，为20 （因为2个消费者） \n\n以上就是直接使用 ActiveMQ 在**点对点**和**发布订阅** 两种模式下收发消息的过程。\n\n下一篇，将介绍[ActiveMQ结合Spring收发消息](http://youngforzy.top/2018/02/15/ActiveMQ%E7%BB%93%E5%90%88Spring%E6%94%B6%E5%8F%91%E6%B6%88%E6%81%AF/)的过程。\n\n\n\n\n\n\n","tags":["消息队列"],"categories":["技术"]},{"title":"Mysql自动还原脚本（.sh文件）","url":"/2018/01/25/Mysql自动还原脚本/","content":"###  Mysql自动还原脚本（.sh文件）\n \n#### 还原数据库的基本指令\n\n```\nsource d:/abc.sql\n```\n当连接数据库之后，可以直接使用 以上命令来还原指定数据库。\n\n\n#### 自动还原脚本\n\n那么能不能使用脚本的方式自动还原呢？\n**当每次都是还原同一个数据库，或者还原同一个数据库中的指定表时，便可以采用脚本的方式执行。**\n\n当数据库备份文件存储在云端时，可采用以下脚本：\n \n```\n#!/bin/bash\n\nHOSTNAME = \"bd.gameplat2dev.db\"         #数据库信息    \nPORT = \"1516\"                                  #端口\nUSERNAME = \"username\"                          #用户名\nPASSWORD = \"123456\"                            #密码\n\nDBNAME = \"game_product\"                        #数据库名称\n#TABLENAME1 = \"t_approve\"                      #表名\n#TABLENAME2 = \"t_approve_role\"  \n\n#sql文件下载路径\nURL = \"http://osuskkx7k.bkt.clouddn.com/ab.sql\"\n\n#定义文件名（自定义）\nFILE = \"sqlfile.sql\"\n\n#下载sql文件\nwget ${URL} -O ${FILE}\n\n#输出(可无)\necho ${FILE}\n\n#定义 source 命令\nrestore_sql = \"source  ${FILE}\"\n\n#还原指令\nmysql -h${HOSTNAME}  -P${PORT}  -u${USERNAME} -p${PASSWORD} ${DBNAME} -e\"${restore_sql}\"\n```\n\n\n**记得另存为时，后缀是 .sh，双击即可运行**\n\n##### 注意：\n- 若为本地数据库可将数据库名改为 localhost ，端口无需指定\n- 脚本中 wget 工具需要安装\n- 若sql文件不是存储云端，可直接指定路径\n- FILE文件名可自定义\n","tags":["自动还原脚本"],"categories":["技术"]},{"title":"Map 的4种遍历方式及比较","url":"/2018/01/07/Map 的4种遍历方式及比较/","content":"###  Map 的4种遍历方式及比较\n\n\n#### KeySet\n\n第一种方式：   **keySet 其实遍历了两次，第一次获取Iterator，第二次根据key获取value，因此性能较差。**\n```\n    public void testKetSet(Map<String, String> map) {\n        Set<String> keys = map.keySet();\n        for (String key : keys) {\n            String value =  map.get(key);\n            System.out.println(\"key: \"+ key + \"  value: \" + value );\n        }\n    }\n```\n\n#### EntrySet\n第二种方式: **entrySet 优于keySet，因为一次就把key和value放入了entry)**\n```\n  public void testEntrySet(Map<String, String> map) {\n        Set<Map.Entry<String, String>> entry = map.entrySet();\n        for (Map.Entry<String, String> stringEntry : entry) {\n            System.out.println(\"key: \"+ stringEntry.getKey() + \"  value: \" + stringEntry.getValue());\n        }\n    }\n```\n\n#### Iterator\n第三种方式：**Iterator （可用 it.remove()在遍历时删除）**\n```\n public void testIterator(Map<String, String> map) {\n        Iterator<Map.Entry<String, String>> it = map.entrySet().iterator();\n        while (it.hasNext()) {\n            Map.Entry<String, String> entry1 = it.next();\n            System.out.println(\"key: \"+ entry1.getKey() + \"  value: \" + entry1.getValue());\n//            if (\"1\".equals(entry1.getKey())) {\n//                it.remove();\n//            }\n        }\n    }\n```\n\n#### Lambda （JDK8）\n第四种方式：Lambda （**本质是 entrySet**）\n```\n public void testLambda(Map<String, String> map) {\n        map.forEach((key, value) -> {\n            System.out.println(\"key: \"+ key + \"  value: \" + value );\n        });\n    }\n```\n\n#### Values\n获取map所有的值，values()返回的是一个集合 **Collection（可转List/Set）**\n```\n public void testValues(Map<String, String> map) {\n        Collection<String> collection = map.values();\n        for (String s : collection) {\n            System.out.println(\"value: \" + s);\n        }\n    }\n```\n\n\n\n","tags":["Java"],"categories":["技术"]},{"title":"Java(spring)实现Mysql的定时备份与还原","url":"/2017/12/25/Java(spring)实现Mysql的定时备份与还原/","content":"### 一、数据库的定时备份\n\n#### 备份命令\nMysql的备份指令：\n\n1. 指定数据库：\n```\nmysqldump -h localhost -uroot -proot  tuser>d:\\user_2017-12-25_15-42-10.sql\t\n```\ntuser：数据库名  \nuser_2017-12-25_15-42-10.sql：文件名\n\n2. 指定数据库中的多个表：\n\n```\nmysqldump -h localhost -uroot -proot --databases tuser --tables t_user t_user2>d:\\user_2017-12-25_15-42-two.sql \n```\n在 --tables 之后加上所需备份的表名\n\n#### 定时（Spring-Task）\n了解了mysql的备份命令，那么如何实现定时呢？  \n**这里采用Spring的定时任务来实现，基于注解的方式。**\n\n主要有两点注意：\n\n##### 1. Spring.xml中开启定时任务注解的配置：\n```\n <!--开启定时任务注解-->\n<task:annotation-driven />\n```\n注意在头部引入task的标签及描述\n\n```\n     xmlns:task=\"http://www.springframework.org/schema/task\"\n     http://www.springframework.org/schema/task\n     http://www.springframework.org/schema/task/spring-task-4.0.xsd\n```\n##### 2.在相应的方法中添加注解@Scheduled\n\n```\n    @Scheduled(cron=\"0/5 * *  * * ? \")   //每5秒执行一次\n    public void task1(){\n        System.out.println(\"北京时间：\"+new Date());\n    }\n\n```\n注意(cron=\"0/5 * *  * * ? \")  表达式\n\n```\ncron=\"0/5 * *  * * ? \"   表示每隔5s执行一次\ncron=\" * * 0/1 * * ? \"   表示每隔1小时执行一次\n\n关于cronExpression的配置可以百度\n```\n\n对数据库  tuser  中的两张表 t_user 和 t_user2 进行备份:  \n代码如下：\n\n```\n //定时备份方案\n    @Scheduled(cron=\"0/5 * *  * * ? \")   //每5秒执行一次  @Scheduled(cron=\" * * 0/1 * * ? \") 每小时一次\n    public void back(){\n        System.out.println(\"现在时间是\"+new Date());\n        Runtime runtime = Runtime.getRuntime();  //获取Runtime实例\n        String user = \"root\";\n        String password = \"root\";\n        String database1 = \"tuser\"; // 需要备份的数据库名\n        String table1 = \"t_user\";\n        String table2 = \"t_user2\";\n        Date currentDate = new Date();\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd_HH-mm-ss\");\n        String sdfDate = sdf.format(currentDate);\n        String filepath = \"d:\\\\time_\" + sdfDate + \".sql\"; // 备份的路径地址\n        //执行命令\n        String stmt = \"mysqldump  -h localhost -u \"+user+\" -p\"+password+\" --databases \"+database1+\" --tables \"+table1+\" \"+table2 +\" > \"+filepath;   \n        System.out.println(stmt);\n        try {\n            String[] command = { \"cmd\", \"/c\", stmt};\n            Process process = runtime.exec(command);\n            InputStream input = process.getInputStream();\n            System.out.println(IOUtils.toString(input, \"UTF-8\"));\n            //若有错误信息则输出\n            InputStream errorStream = process.getErrorStream();\n            System.out.println(IOUtils.toString(errorStream, \"UTF-8\"));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n```\n### 二、数据库的还原\n#### 还原命令\n可以通过两种方式来进行还原操作。\n##### 1. mysql 利用sql文件还原数据库\n```\nmysql -h localhost -uroot -proot tuser< D:\\user_2017-12-25_15-42-10.sql\n```\n##### 2. source 命令  \n这也是导入sql文件的方式，登录mysql之后，输入：\n```\nsource d:/game_product2018-01-02_10-41-30.sql\n```\n注意反斜杠的方向，“source d:\\ab.sql” 这样会执行失败。  \n**注：在Navicat中无法使用 source 命令**\n\n#### 还原\n\n在代码中采用第一种方式实现还原操作\n\n\n```\n    public void restore() {\n        String user = \"root\";\n        String password = \"root\";\n        String database = \"tuser\"; // 需要备份的数据库名\n        System.out.println(\"现在时间是\" + new Date());\n        Runtime runtime = Runtime.getRuntime();\n\n        String cmd = \"mysql  -h localhost\" + \" -u \" + user + \" -p\" + password + \" \" + database;\n        System.out.println(cmd);\n        try {\n            String filePath =  \"D:\\\\user_2017-12-25_15-42-10.sql\"; // sql文件路径\n            String stmt = cmd + \" < \" + filePath;\n            String[] command = {\"cmd\", \"/c\", stmt};\n            Process process = runtime.exec(command);\n            //若有错误信息则输出\n            InputStream errorStream = process.getErrorStream();\n            System.out.println(IOUtils.toString(errorStream, \"utf-8\"));\n            //等待操作\n            int processComplete = process.waitFor();\n            if (processComplete == 0) {\n                System.out.println(\"还原成功.\");\n            } else {\n                throw new RuntimeException(\"还原数据库失败.\");\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n```\n","tags":["Mysql备份还原"],"categories":["技术"]},{"title":"中缀表达式转后缀表达式（逆波兰）","url":"/2017/12/18/中缀表达式转后缀表达式（逆波兰）/","content":"### 一、中缀表达式转后缀表达式\n\n中缀表达式就是普通的表达式。如：9+（3-1）*3+10/2  \n后缀表达式是一种不需要括号的表示法，又叫逆波兰表达式。\n\n上面的式子用后缀法表示：9 3 1 - 3 * + 10 2 / +\n\n那么如何转化成后缀表达式？\n\n#### 思路：  \n从左往右遍历：  \n**1. 如果是数字则直接输出**  \n**2. 如果是符号则入栈，但要通过以下判断**\n- **若该符号c是右括号或者c的优先级≤栈顶符号，则栈中元素依次出栈输出，c入栈**\n\n代码实现：\n```\n//中缀转后缀表达式（逆波兰）------栈实现\npublic class NiPoLan2 {\n\n\tpublic static void main(String[] args) {\n\t\t//创建栈\n\t\tStack<String> s = new Stack<String>();\n\t\tString s1 = \"9+(3-1)*3+10/2\"; \t//例子  (1-2)*(4+5)   9+(3-1)*3+10/2\n\t\tchar[] o = s1.toCharArray();\n\t\tString r = \"\";\t//字符串r记录输出\n\t\t//遍历\n\t\tfor(int i=0;i<o.length;i++){\n\t\t//符号是数字\n\t\tif(Character.isDigit(o[i])){\n\t\t\t//判断两位整数，如10\n\t\t\tif(i<o.length-1&&Character.isDigit(o[i+1])){\n\t\t\t\tr = r+o[i]+o[i+1]+\" \";\n\t\t\t\ti++; //减少一次循环\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tr = r+o[i]+\" \";\n\t\t}\n\t\t//符号是 (\n\t\tif(o[i]=='('){\n\t\t\ts.push(o[i]+\"\");\n\t\t}\n\t\t//符号是+ or -\n\t\tif(o[i]=='+'|o[i]=='-'){\n\t\t\t//栈不为空，且有乘除符号，则弹出\n\t\t\tif(!s.isEmpty()&&(s.peek().equals(\"*\")|s.peek().equals(\"/\"))){\n\t\t\t\t//全部出栈\n\t\t\t\twhile(!s.isEmpty()){\n\t\t\t\t\tr = r + s.pop()+\" \";\n\t\t\t\t}\n\t\t\t\t//出栈后，再将+-入栈\n\t\t\t\ts.push(o[i]+\"\");\n\t\t\t\t//栈为空\n\t\t\t}else{\n\t\t\t\ts.push(o[i]+\"\");\n\t\t\t\tSystem.out.println(o[i]+\"\");\n\t\t\t}\n\t\t}\n\t\t//符号是右括号则配对\n\t\tif(o[i]==')'){\n\t\t\tString a = s.pop();\n\t\t\tSystem.out.println(a);\n\t\t\tr = r + a+\" \";\n\t\t\ts.pop();\n\t\t}\n\t\t//符号是乘除\n\t\tif(o[i]=='*'|o[i]=='/'){\n\t\t\tSystem.out.println(s.peek());\n\t\t\t//栈顶是加减、括号\n\t\t\tif(s.isEmpty()){\n\t\t\t\ts.push(o[i]+\"\");\n\t\t\t}else if(s.peek().equals(\"+\")|s.peek().equals(\"-\")|s.peek().equals(\"(\")){\t//s.peek()==\"-\"|s.peek()==\"+\"|s.peek()==\"(\"\n\t\t\t\ts.push(o[i]+\"\");\n\t\t\t}\n\t\t    //栈顶是乘除，则出栈\n\t\t\telse if(s.peek()==\"*\"|s.peek()==\"/\"){\n\t\t\t\t//全部出栈\n\t\t\t\twhile(!s.isEmpty()){\n\t\t\t\t\tr = r + s.pop();\n\t\t\t\t}\n\t\t\t\ts.push(o[i]+\"\");\n\t\t\t}\n\t\t}\n\t\t}\n\t\t//最后栈中不为空，全部出栈\n\t\twhile(!s.isEmpty()){\n\t\t\tr = r + s.pop()+\" \"; \n\t\t}\n\t\tSystem.out.println(r);\n}\n}\t\n```\n输出结果：\n```\n9 3 1 - 3 * + 10 2 / + \n```\n\n### 二、计算后缀表达式\n中缀表达式容易计算：9+（3-1）*3+10/2=20  \n那么后缀表达式如何计算呢？\n\n还是上面的例子： 9 3 1 - 3 * + 10 2 / + \n#### 思路：\n**从左往右遍历：**   \n\n1. **遇到数字就入栈**  \n2. **遇到符号就将栈顶的两个元素取出计算，将结果入栈；最后栈中的数就是最终结果**\n\n代码实现：\n\n```\npublic class NiPoLan {\n\n\tpublic static void main(String[] args) {\n\t\t\n\t\tStack<Integer> s = new Stack<Integer>();\n\t\tString s1 = \"9 3 1 - 3 * + 10 2 / +\";\n\t\tString[] r = s1.split(\" \");\t\t\t\t//转为字符串数组\n\t\tSystem.out.println(s1);\n\t\tfor(int i=0;i<r.length;i++){\n\t\t\t//判断字符串r[i]是数字还是符号\n\t\t\t//r[i]是数字，入栈\n\t\t\tif(Character.isDigit(r[i].charAt(0))){\n\t\t\t\tint c = Integer.valueOf(r[i]);\n\t\t\t\ts.push(c);\n\t\t\t}else{\n\t\t\t\t//r[i]是符号，则运算\n\t\t\t\tswitch (r[i]) {\n\t\t\t\tcase \"-\":\n\t\t\t\t\tint a = s.pop();  \n\t\t\t\t\tint b = s.pop();  \n\t\t\t\t\ts.push(b-a);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"+\":\n\t\t\t\t\t a = s.pop();  \n\t\t\t\t\t b = s.pop();  \n\t\t\t\t\ts.push(b+a); \n\t\t\t\t\tbreak;\n\t\t\t\tcase \"/\":\n\t\t\t\t\t a = s.pop();  \n\t\t\t\t\t b = s.pop();  \n\t\t\t\t\ts.push(b/a);\n\t\t\tbreak;\n\t\t\t\tcase \"*\":\n\t\t\t\t\t a = s.pop();  \n\t\t\t\t\t b = s.pop();  \n\t\t\t\t\ts.push(b*a);\n\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t}\n\t\t//输出结果\n\t\tSystem.out.println(s.pop());\n\t}\n\t}\n```\n输出结果：\n```\n9 3 1 - 3 * + 10 2 / +\n20\n```\n结果为 20。","tags":["逆波兰表达式"],"categories":["技术"]},{"title":"Java并发工具类之Semaphore","url":"/2017/12/12/Java并发工具类之Semaphore/","content":"### 一、Semaphore的概念\n\n**Semaphore又叫信号量，用来控制同时访问特定资源的线程数量**。它通过协调各个线程，以保证合理地使用公共资源。\n\n**Semaphore和CountDownLatch一样，也是维护了一个计数器，其本质是一个共享锁。**\n\n**Semaphore有公平性和非公平性之分。**\n\n**Semaphore的工作过程：**\n\n\n![image](http://osuskkx7k.bkt.clouddn.com/timg.jpg)  \n\n\n1. 当一个线程想要访问某个共享资源时，它必须要先获取Semaphore；\n2. 当Semaphore > 0 时，获取该资源并使Semaphore – 1；\n3. 当Semaphore = 0，则表示全部的共享资源已经被其他线程全部占用，线程必须要等待其他线程释放资源；\n3. 当有线程释放资源时，Semaphore+1，其他线程可以争抢资源；\n\n\n### 二、Semaphore的实现分析\n\n前面分析可知，**Semaphore的实现是共享锁。**\n\n#### 构造函数\nSemaphore有两个构造函数。\n```\npublic Semaphore(int permits) {\n        sync = new NonfairSync(permits);\n    }\npublic Semaphore(int permits, boolean fair) {\n    sync = fair ? new FairSync(permits) : new NonfairSync(permits);\n}\n```\n第一个构造函数中传入的是资源许可的数量，默认是非公平锁。\n第二个构造函数传入资源许可的数量和一个boolean变量，该变量可实现公平锁。\n\n\n\nSemaphore在使用时有两个主要方法，acquire()方法表示获取一个资源许可，而 release()方法表示释放一个资源许可。\n\n#### 资源获取：acquire()方法\n\n调用acquire()方法获取一个资源：\n```\npublic void acquire() throws InterruptedException {\n        sync.acquireSharedInterruptibly(1);\n    }\n```\n该方法调用AQS的acquireSharedInterruptibly()方法，以共享的模式获取同步状态：\n```\npublic final void acquireSharedInterruptibly(int arg)\n            throws InterruptedException {\n        if (Thread.interrupted())\n            throw new InterruptedException();\n        if (tryAcquireShared(arg) < 0)\n            doAcquireSharedInterruptibly(arg);\n    }\n```\n然后调用tryAcquireShared()方法，该方法由Sync的子类来实现：\n- 如果是非公平模式，调用NonfairSync的tryAcquireShared()方法；\n- 如果是公平模式，调用FairSync的tryAcquireShared()方法。\n\n在前面的文章 [ReentrantLock重入锁](http://blog.csdn.net/babylove_bale/article/details/78317204) 中有提到公平与非公平的实现。\n\n\n**非公平模式**\n```\nfinal int nonfairTryAcquireShared(int acquires) {\n            for (;;) {\n                int available = getState();\n                int remaining = available - acquires;\n                if (remaining < 0 ||\n                    compareAndSetState(available, remaining))\n                    return remaining;\n            }\n        }\n```\nremaining 表示剩余的资源许可，如果< 0，表示目前没有剩余的许可。当前线程继续等待。如果remaining >0 则执行CAS操作获取资源许可。\n\n\n**公平模式**\n\n```\nprotected int tryAcquireShared(int acquires) {\n            for (;;) {\n                if (hasQueuedPredecessors())\n                    return -1;\n                int available = getState();\n                int remaining = available - acquires;\n                if (remaining < 0 ||\n                    compareAndSetState(available, remaining))\n                    return remaining;\n            }\n        }\n```\n**在公平模式的方法中，增加了一个判断，判断同步队列中是否有等待的线程：**\n- 有，则插入作为尾节点，线程阻塞；\n- 没有，则参与资源竞争；\n\n简而言之，公平模式就是要按等待队列中的顺序获取资源许可。\n#### 资源释放：release()方法\n\nSemaphore调用release()方法释放资源许可，默认释放1个。\n```\npublic void release() {\n        sync.releaseShared(1);\n    }\n```\n调用AQS的releaseShared()方法：\n```\npublic final boolean releaseShared(int arg) {\n        if (tryReleaseShared(arg)) {\n            doReleaseShared();\n            return true;\n        }\n        return false;\n    }\n```\n调用Sync中重写的tryReleaseShared()方法（**公平与非公平都是调用该方法**），\n```\nprotected final boolean tryReleaseShared(int releases) {\n            for (;;) {\n                int current = getState();\n                int next = current + releases;\n                if (next < current) // overflow\n                    throw new Error(\"Maximum permit count exceeded\");\n                if (compareAndSetState(current, next))\n                    return true;\n            }\n        }\n```\n**next代表如果许可释放成功，可用资源许可的数量。  \n这里可能有多个线程同时释放，因此利用CAS操作将资源许可数量置为next。  \n释放成功后，进入doReleaseShared()唤醒队列中等待的线程。**\n\n**注：公平模式与非公平模式都是调用该release()方法。**\n\n\n","tags":["Semaphore"],"categories":["技术"]},{"title":"Java并发工具类之CyclicBarrier","url":"/2017/12/08/Java并发工具类之CyclicBarrier/","content":"### 一、CyclicBarrier的概念\n\nCyclicBarrier的意思是可循环使用的屏障。**它可以让一组线程到达一个屏障时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有阻塞的线程才会继续执行。**\n\n它就好像一道关卡，只有所有的部队（线程）都到了才能放行。\n\n![image](http://osuskkx7k.bkt.clouddn.com/cycle.png)\n\n\n### 二、CyclicBarrier的实现分析\n\n**部分源码：**\n```\npublic class CyclicBarrier {\n    \n    private final ReentrantLock lock = new ReentrantLock();\n    private final Condition trip = lock.newCondition();\n    private final int parties;\n    private final Runnable barrierCommand;\n    private Generation generation = new Generation();\n    private int count;\n    private static class Generation {\n        boolean broken = false;\n    }\n    ....\n}\n```\n可以看到，**CyclicBarrier是基于ReentrantLock和Condition实现的。**\n- parties 表示拦截线程的数量\n- barrierCommand 表示所有线程到达屏障后优先执行的命令\n- Generation 表示屏障循环利用\n\n#### 构造函数\nCyclicBarrier有两个构造函数：\n\n```\npublic CyclicBarrier(int parties) {\n        this(parties, null);\n    }\npublic CyclicBarrier(int parties, Runnable barrierAction) {\n        if (parties <= 0) throw new IllegalArgumentException();\n        this.parties = parties;\n        this.count = parties;\n        this.barrierCommand = barrierAction;\n    }\n```\n第一个构造函数调用的其实也是第二个构造函数，只是第二个参数barrierAction为null。这个参数其实是一个线程任务命令，用于在所有线程到达屏障时，优先执行该线程任务，方便处理更加复杂的业务场景。\n\n#### await()方法：\n每当一个线程调用await()方法表示该线程到达屏障，\n\n```\npublic int await() throws InterruptedException, BrokenBarrierException {\n        try {\n            return dowait(false, 0L);\n        } catch (TimeoutException toe) {\n            throw new Error(toe); \n        }\n    }\n```\n进入dowait()方法：\n\n```\nprivate int dowait(boolean timed, long nanos)\n        throws InterruptedException, BrokenBarrierException,\n               TimeoutException {\n        final ReentrantLock lock = this.lock;\n        lock.lock();\n        try {\n            final Generation g = generation;\n            \n            //当前generation“已损坏”，抛出异常\n            if (g.broken)\n                throw new BrokenBarrierException();\n                \n            //如果线程中断，终止CyclicBarrier\n            if (Thread.interrupted()) {\n                breakBarrier();\n                throw new InterruptedException();\n            }\n            //每当线程进入，计数-1\n            int index = --count;\n            if (index == 0) {  //计数为0时，进入\n                boolean ranAction = false;\n                try {\n                    final Runnable command = barrierCommand;\n                    if (command != null)   //如果有barrierCommand，则优先执行该任务\n                        command.run();\n                    ranAction = true;\n                    nextGeneration();//唤醒所有等待线程，并更新generation\n                    return 0;\n                } finally {\n                    if (!ranAction)\n                        breakBarrier();\n                }\n            }\n            // loop until tripped, broken, interrupted, or timed out\n            //自旋\n            for (;;) {\n                try {\n                    if (!timed)//如果不是超时等待，则调用Condition.await()方法等待\n                        trip.await();\n                    else if (nanos > 0L)//超时等待，调用Condition.awaitNanos()方法等待\n                        nanos = trip.awaitNanos(nanos);\n                } catch (InterruptedException ie) {\n                    //如果等待过程中，线程被中断，则执行下面的函数。\n                    if (g == generation && ! g.broken) {\n                        breakBarrier();\n                        throw ie;\n                    } else {\n                    }\n                }\n                \n                //当前generation“已损坏”，抛出异常\n                if (g.broken)\n                    throw new BrokenBarrierException();\n                    \n                //generation已经更新，返回index\n                if (g != generation)\n                    return index;\n\n                //“超时等待”，并且时间已到,终止CyclicBarrier，并抛出异常\n                if (timed && nanos <= 0L) {\n                    breakBarrier();\n                    throw new TimeoutException();\n                }\n            }\n        } finally {\n            lock.unlock();\n        }\n    }\n```\ndowait()的主要处理逻辑如下：如果该线程不是到达的最后一个线程，则它会一直处于等待状态，除非发生以下情况：\n1. 最后一个线程到达，即index == 0\n2. 超出了指定时间（超时等待）\n3. 其他的某个线程中断当前线程\n4. 其他的某个线程中断另一个等待的线程\n5. 其他的某个线程在等待barrier超时\n6. 其他的某个线程在此barrier调用reset()方法。reset()方法用于将屏障重置为初始状态。\n\nGeneration对象描述着CyclicBarrier的更新换代。在CyclicBarrier中，同一批线程属于同一代。当有parties个线程到达barrier，generation就会被更新换代。\n\n### 三、CyclicBarrier与CountDownLatch的对比\n\n\n**CyclicBarrier允许一系列线程相互等待对方到达屏障，先到达的线程被阻塞在屏障前，必须等到所有线程都到达了屏障，所有线程才能运行；CountDownLatch允许一个或多个线程等待一些特定的操作完成，而这些操作是在其它的线程中进行的，只有“被等的线程”的操作完成后，“等待的线程”才能执行；**\n\n**CyclicBarrier强调的是n个线程互相等待，CountDownLatch强调的是1个线程或n个线程等待其他线程操作。**\n\n\n\n**CyclicBarrier的计数器可以循环使用（出现错误可重置计数），CountDownLatch的计数器只能用一次；**\n\n**CyclicBarrier可以在所有线程到达屏障后先执行一个线程任务，再运行所有线程，用于处理复杂的业务，CountDownLatch不可以。**","tags":["CyclicBarrier"],"categories":["技术"]},{"title":"Java并发工具类之CountDownLatch","url":"/2017/12/03/Java并发工具类之CountDownLatch/","content":"### 一、概念\n\nCountDownLatch也叫闭锁，是并发包的工具类之一，允许一个或多个线程等待其他线程完成操作后再执行。\n\n回忆之前，我们知道Join方法，用于让当前线程等待join的线程执行结束。\n\n```\nwhile(isAlive()){\n    wait(0);\n}\n```\n\n\n其原理就是不停地检查join线程是否存活，如果存活则一直等待。\nCountDownLatch也可以实现join的功能，且功能更多。  \n\n![image](http://osuskkx7k.bkt.clouddn.com/CountDownLatch.png)\n\nCountDownLatch是通过一个计数器来实现的，当new 一个CountDownLatch对象的时候需要传入该计数器值。  \nCountDownLatch有两个最主要的方法await()和countDown()。\n\n当一个线程调用await()时会阻塞；每当一个其他线程完成自己的任务调用countDown()后，计数器的值就会减1。当计数器的值为0时，就表示所有的线程均已经完成了任务，然后阻塞的线程就可以继续执行了。\n\n### 二、实现分析\n\n**部分源码**：\n```\npublic class CountDownLatch {\n    private final Sync sync;\n    //内部类Sync（继承AQS）\n    private static final class Sync extends AbstractQueuedSynchronizer {\n        Sync(int count) {\n            setState(count);\n        }\n        //重写\n        protected int tryAcquireShared(int acquires) {\n            return (getState() == 0) ? 1 : -1;\n        }\n        protected boolean tryReleaseShared(int releases) {\n            for (;;) {\n                int c = getState();\n                if (c == 0)\n                    return false;\n                int nextc = c-1;\n                if (compareAndSetState(c, nextc))\n                    return nextc == 0;\n            }\n        }\n    }\n    //构造方法\n     public CountDownLatch(int count) {\n        if (count < 0) throw new IllegalArgumentException(\"count < 0\");\n        this.sync = new Sync(count);\n    }\n    ....\n}\n```\n可以看到，CountDownLatch的实现同样依赖AQS，可见AQS作用之大。\n观察Sync重写的方法（tryAcquireShared、tryReleaseShared），我们可以断定：\n**CountDownLatch使用的是共享锁。**\n\n#### await()的实现\n\n调用await()方法会阻塞当前线程，直到计数器为0或被中断。\n\n```\npublic void await() throws InterruptedException {\n        sync.acquireSharedInterruptibly(1);\n    }\n```\n可以看到，其实调用了AQS的acquireSharedInterruptibly()方法：\n```\npublic final void acquireSharedInterruptibly(int arg)\n            throws InterruptedException {\n        if (Thread.interrupted())\n            throw new InterruptedException();\n        if (tryAcquireShared(arg) < 0)\n            doAcquireSharedInterruptibly(arg);\n    }\n```\n该方法中，如果线程被中断则抛出异常；否则尝试获取锁。\n\n```\nprotected int tryAcquireShared(int acquires) {\n            return (getState() == 0) ? 1 : -1;\n        }\n\n```\n尝试获取锁时调用了Sync重写的tryAcquireShared()方法：\n很简单只有一行代码，但却是CountDownLatch的原理：**如果同步状态为0（计数器值为0）那么返回1，表示获取锁成功；否则返回-1，获取锁失败**，并进入doAcquireSharedInterruptibly()方法：\n\n```\nprivate void doAcquireSharedInterruptibly(int arg)\n        throws InterruptedException {\n        final Node node = addWaiter(Node.SHARED);\n        boolean failed = true;\n        try {\n            for (;;) {\n                final Node p = node.predecessor();\n                if (p == head) {\n                    int r = tryAcquireShared(arg);\n                    //注意r只会等于 0 or -1；\n                    if (r >= 0) {\n                        setHeadAndPropagate(node, r);\n                        p.next = null; // help GC\n                        failed = false;\n                        return;\n                    }\n                }\n                if (shouldParkAfterFailedAcquire(p, node) &&\n                    parkAndCheckInterrupt())\n                    throw new InterruptedException();\n            }\n        } finally {\n            if (failed)\n                cancelAcquire(node);\n        }\n    }\n```\n该方法在前面共享锁的文章中有提到，它是一个自旋尝试获取锁的方法，这里不再赘述。**注意18行的代码：int r = tryAcquireShared(arg)，在获取同步状态时只会返回两个值0和-1。**\n\n\n#### countDown()的实现\n每次调用countDown()时，计数器的数量就会减1。\n\n```\npublic void countDown() {\n        sync.releaseShared(1);\n    }\n```\n调用的是AQS的releaseShared()方法，释放同步状态：\n```\npublic final boolean releaseShared(int arg) {\n        if (tryReleaseShared(arg)) {\n            doReleaseShared();\n            return true;\n        }\n        return false;\n    }\n```\n进入releaseShared()方法，调用Sync重写的tryReleaseShared()方法：\n```\nprotected boolean tryReleaseShared(int releases) {\n            for (;;) {\n                int c = getState();\n                if (c == 0)\n                    return false;\n                int nextc = c-1;\n                if (compareAndSetState(c, nextc))\n                    return nextc == 0;\n            }\n        }\n```\n可以看到，**该方法自旋CAS操作释放同步状态（可能多个线程同时调用countDown()方法，所以用CAS保证原子性），计数器每次-1，但是直到同步状态为0（计数器为0）时，才返回true**。然后进入doReleaseShared()方法，唤醒阻塞的线程，使其从await()方法退出。\n\n#### 总结\n\n**CountDownLatch的内部实现是共享锁。**\n\n\n**创建CountDownLatch时，需要传入计数器的初始值，可以理解为共享锁的总次数。**  \n**当一个线程调用await()方法，会检查计数器的值，不为0则阻塞直到为0。  \n当其他线程调用countDown()方法时（可以一个线程调用多次），会释放共享状态，计数器-1。**  \n**当计数器减为0时，阻塞的线程才会运行。**\n\n\n### 三、应用场景\nCountDownLatch的应用场景：**主线程等到N个子线程执行完毕之后，再继续往下执行。** 如跑步比赛统计排名、启动程序等。\n\n```\npublic class CountDownLatchDemo {\n\t\n\tprivate CountDownLatch cd = new CountDownLatch(5);\n\t/*\n\t * 飞船类\n\t */\n\t class Plane extends Thread{\n\t\t @Override\n\t\tpublic void run() {\n\t\t\tSystem.out.println(\"飞船准备就绪，倒计时5s：\");\n\t\t\tSystem.out.println(cd.getCount());//计数器的值\n\t\t\ttry {\n\t\t\t\tcd.await();\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(\"飞船起飞啦！！！！\");\n\t\t}\n\t }\n\t /*\n\t * 倒计时类\n\t */\n\t class Time extends Thread{\n\t\t @Override\n\t\tpublic void run() {\n\t\t\t for(int i=5;i>0;i--){\n\t\t\t\t System.out.println(\"起飞倒计时：\"+i+\"s\");\n\t\t\t\t cd.countDown();\n\t\t\t }\n\t\t}\n\t }\n\t\n\tpublic static void main(String[] args) {\n\t\tCountDownLatchDemo cdemo = new CountDownLatchDemo();\n\t\tPlane p = cdemo.new Plane();\n\t\tp.start();\n\t\tTime t = cdemo.new Time();\n\t\tt.start();\n\t}\n}\n```\n输出结果：\n```\n飞船准备就绪，倒计时5s：\n5\n起飞倒计时：5s\n起飞倒计时：4s\n起飞倒计时：3s\n起飞倒计时：2s\n起飞倒计时：1s\n飞船起飞啦！！！！\n```\n**当调用CountDownLatch的countDown方法时，计数器N就会-1，无论是在多个线程调用，还是一个线程调用多次（上面的例子就是在一个线程中多次调用）。**\n","tags":["CountDownLatch"],"categories":["技术"]},{"title":"Java并发之Condition的实现分析","url":"/2017/12/01/Java并发之Condition的实现分析/","content":"### 一、Condition的概念\n\n#### 介绍\n回忆synchronized关键字，它配合Object的wait()、notify()系列方法可以实现等待/通知模式。\n\n对于Lock，通过Condition也可以实现等待/通知模式。\n\n\n\nCondition是一个接口。  \nCondition接口的实现类是Lock（AQS）中的ConditionObject。  \nLock接口中有个 newCondition()方法，通过这个方法可以获得Condition对象（其实就是ConditionObject）。  \n因此，**通过Lock对象可以获得Condition对象。**\n```\nLock lock  = new ReentrantLock();\nCondition c1 = lock.newCondition();\nCondition c2 = lock.newCondition();\n```\n\n\n\n### 二、Condition的实现分析\n\n#### 实现\n\nConditionObject类是AQS的内部类，实现了Condition接口。\n\n```\npublic class ConditionObject implements Condition, java.io.Serializable {\n        private transient Node firstWaiter;\n        private transient Node lastWaiter;\n        ...\n```\n可以看到，等待队列和同步队列一样，使用的都是同步器AQS中的节点类Node。\n同样拥有首节点和尾节点，\n每个Condition对象都包含着一个FIFO队列。  \n结构图：\n\n![image](http://osuskkx7k.bkt.clouddn.com/condition.jpg)\n\n#### 等待\n\n调用Condition的await()方法会使线程进入等待队列，并释放锁，线程状态变为等待状态。\n```\npublic final void await() throws InterruptedException {\n            if (Thread.interrupted())\n                throw new InterruptedException();\n            Node node = addConditionWaiter();\n            //释放同步状态（锁）\n            int savedState = fullyRelease(node);\n            int interruptMode = 0;\n            //判断节点是否放入同步对列\n            while (!isOnSyncQueue(node)) {\n                //阻塞\n                LockSupport.park(this);\n                //如果已经中断了，则退出\n                if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)\n                    break;\n            }\n            if (acquireQueued(node, savedState) && interruptMode != THROW_IE)\n                interruptMode = REINTERRUPT;\n            if (node.nextWaiter != null) // clean up if cancelled\n                unlinkCancelledWaiters();\n            if (interruptMode != 0)\n                reportInterruptAfterWait(interruptMode);\n        }\n```\n\n分析上述方法的大概过程：\n1. 将当前线程创建为节点，加入等待队列\n2. 释放锁，唤醒同步队列中的后继节点\n3. while循环判断节点是否放入同步队列：\n\n- 没有放入，则阻塞，继续while循环（如果已经中断了，则退出）\n- 放入，则退出while循环，执行后面的判断\n4. 退出while说明节点已经在同步队列中，调用acquireQueued()方法加入同步状态竞争。\n5. 竞争到锁后从await()方法返回，即退出该方法。  \n\n![image](http://osuskkx7k.bkt.clouddn.com/enterCon.png)\n\n**addConditionWaiter()方法：**\n```\nprivate Node addConditionWaiter() {\n            Node t = lastWaiter;\n            if (t != null && t.waitStatus != Node.CONDITION) {\n                //清除条件队列中所有状态不为Condition的节点\n                unlinkCancelledWaiters();\n                t = lastWaiter;\n            }\n            //将该线程创建节点，放入等待队列\n            Node node = new Node(Thread.currentThread(), Node.CONDITION);\n            if (t == null)\n                firstWaiter = node;\n            else\n                t.nextWaiter = node;\n            lastWaiter = node;\n            return node;\n        }\n```\n\n过程分析：同步队列的首节点移动到等待队列。加入尾节点之前会清除所有状态不为Condition的节点。\n\n\n---\n#### 通知\n调用Condition的signal()方法，可以唤醒等待队列的首节点（等待时间最长），唤醒之前会将该节点移动到同步队列中。\n\n```\npublic final void signal() {\n            //判断是否获取了锁\n            if (!isHeldExclusively())\n                throw new IllegalMonitorStateException();\n            Node first = firstWaiter;\n            if (first != null)\n                doSignal(first);\n        }\n```\n过程：\n1. 先判断当前线程是否获取了锁\n2. 然后对首节点调用doSignal()方法\n\n```\nprivate void doSignal(Node first) {\n            do {\n                if ( (firstWaiter = first.nextWaiter) == null)\n                    lastWaiter = null;\n                first.nextWaiter = null;\n            } while (!transferForSignal(first) &&\n                     (first = firstWaiter) != null);\n        }\n```\n过程：\n1. 修改首节点\n2. 调用transferForSignal()方法将节点移动到同步队列\n\n\n```\nfinal boolean transferForSignal(Node node) {\n        //将节点状态变为0   \n        if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))\n            return false;\n        //将该节点加入同步队列\n        Node p = enq(node);\n        int ws = p.waitStatus;\n        //如果结点p的状态为cancel 或者修改waitStatus失败，则直接唤醒\n        if (ws > 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))\n            LockSupport.unpark(node.thread);\n        return true;\n    }\n```\n调用同步器的enq方法，将节点移动到同步队列，\n满足条件后使用LockSupport唤醒该线程。  \n\n![image](http://osuskkx7k.bkt.clouddn.com/signalcon.png)\n\n\n---\n当Condition调用signalAll()方法：\n```\npublic final void signalAll() {\n            if (!isHeldExclusively())\n                throw new IllegalMonitorStateException();\n            Node first = firstWaiter;\n            if (first != null)\n                doSignalAll(first);\n        }\nprivate void doSignalAll(Node first) {\n            lastWaiter = firstWaiter = null;\n            do {\n                Node next = first.nextWaiter;\n                first.nextWaiter = null;\n                transferForSignal(first);\n                first = next;\n            } while (first != null);\n        }\n```\n可以看到doSignalAll()方法使用了do-while循环来唤醒每一个等待队列中的节点，直到first为null时，停止循环。\n\n一句话总结signalAll()的作用：**将等待队列中的全部节点移动到同步队列中，并唤醒每个节点的线程。**\n\n\n#### 总结\n整个过程可以分为三步：\n\n第一步：一个线程获取锁后，通过调用Condition的await()方法，会将当前线程先加入到等待队列中，并释放锁。然后就在await()中的一个while循环中判断节点是否已经在同步队列，是则尝试获取锁，否则一直阻塞。\n\n\n第二步：当线程调用signal()方法后，程序首先检查当前线程是否获取了锁，然后通过doSignal(Node first)方法将节点移动到同步队列，并唤醒节点中的线程。\n\n\n第三步：被唤醒的线程，将从await()中的while循环中退出来，然后调用acquireQueued()方法竞争同步状态。竞争成功则退出await()方法，继续执行。\n\n","tags":["Condition"],"categories":["技术"]},{"title":"Java并发之Executor框架","url":"/2017/11/22/Java并发之Executor框架/","content":"### 一、Executor框架的介绍\n\nJava中的线程既是工作单元又是执行机制。JDK1.5开始，把工作单元与执行机制分离开来。**工作单元为Runnable（Thread实现该接口）和Callable，执行机制就是Executor框架。** 使用Executor框架时不用显式的创建线程Thread。\n\nExecutor框架由三部分组成：  \n- **任务**：Runnable或Callable  \n- **任务的执行**：ExecutorService接口及其实现。  \n- **异步计算的结果**：Future接口或其实现类FutureTask\n\n\n#### Executor的结构\n\n![image](http://osuskkx7k.bkt.clouddn.com/Executor1.png)\n\n\n\n#### **Executor接口**\n```\npublic interface Executor {\n        void execute(Runnable command);\n}\n```\n**Executor接口中只有一个execute()方法，用来执行已经提交的Runnable实例，可见即使是Callable实例，最后也会被封装成Runnable来执行。**\n\n\n\n\n#### **ExecutorService接口**\n\n\n```\npublic interface ExecutorService extends Executor {\n        void shutdown();\n        List<Runnable> shutdownNow();\n        <T> Future<T> submit(Callable<T> task);\n        <T> Future<T> submit(Runnable task, T result);\n        Future<?> submit(Runnable task);\n        ....\n    }\n```\n**ExecutorService扩展了Executor接口，添加了许多方法用于服务、管理和关闭线程池。**\nsubmit()方法最终执行时也是调用了execute()方法。\n\nExecutorService接口有两个实现类，ThreadPoolExecutor（核心）和ScheduledThreadPoolExecutor（定时执行）。\n\n\n#### **Executors工具类**\n\n**Executors工具类中包含了许多静态工厂方法。采用了多方法静态工厂模式。** 本质是根据不同的输入创建出不同类型的对象。\n\n\n\n通过Executors工具类可以创建3种类型的线程池，即3种ThreadPoolExecutor对象。实质是创建ThreadPoolExecutor时传入的参数不同。\n\n\n### 二、3种常用线程池\n\n#### FixedThreadPool\n**FixedThreadPool是固定大小的线程池。内部线程可重用。**  \nExecutors工具类中的静态方法：\n```\npublic static ExecutorService newFixedThreadPool(int nThreads) {\n        return new ThreadPoolExecutor(nThreads, nThreads,\n                                      0L, TimeUnit.MILLISECONDS,\n                                      new LinkedBlockingQueue<Runnable>());\n    }\n```\n\n**特点**：\n1. 参数corePoolSize和maximumPoolSize大小都是nThreads，说明最大线程数就是核心线程数，所以线程大小固定\n2. 参数keepAliveTime为0L，说明不会有空闲的线程\n3. 参数BlockingQueue是无界队列LinkedBlockingQueue，说明任务会一直放入，不会采用饱和策略。\n\n**应用场景**：需要限制线程数量，适用于负载较重的服务器\n\n![image](http://osuskkx7k.bkt.clouddn.com/fixed.png)\n\n**工作过程**：\n1. 当前线程数小于corePoolSize，创建新线程执行任务\n2. 当前线程数等于corePoolSize，任务加入阻塞队列\n3. 线程反复执行阻塞队列中的任务\n\n#### SingleThreadExecutor\n\n**SingleThreadExecutor是只有一个线程的线程池。**\n\n\n```\npublic static ExecutorService newSingleThreadExecutor() {\n        return new FinalizableDelegatedExecutorService\n            (new ThreadPoolExecutor(1, 1,\n                                    0L, TimeUnit.MILLISECONDS,\n                                    new LinkedBlockingQueue<Runnable>()));\n    }\n```\n**特点**：\n1. 参数corePoolSize和maximumPoolSize大小都是1，说明线程数固定为1\n2. 参数keepAliveTime为0L，说明不会有空闲的线程\n3. 参数BlockingQueue是无界队列LinkedBlockingQueue，说明任务会一直放入，不会采用饱和策略。\n\n**应用场景**：**适用于执行的任务需要保证顺序；并且在任意时间点，不会有多个线程是活动的场景。**\n\n![image](http://osuskkx7k.bkt.clouddn.com/single1.png)\n\n**工作过程**：\n1. 当前线程数小于1，创建一个唯一的线程执行任务\n2. 当前线程数等于1，任务加入阻塞队列\n3. 这个唯一的线程反复执行阻塞队列中的任务\n\n#### CachedThreadPool\n**CachedThreadPool是一个根据需要创建线程的线程池。**\n\n\n```\npublic static ExecutorService newCachedThreadPool() {\n        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                      60L, TimeUnit.SECONDS,\n                                      new SynchronousQueue<Runnable>());\n    }\n```\n**特点**：\n1. 参数corePoolSize为0，maximumPoolSize为Integer.MAX_VALUE（2147483647），说明可创建的线程数巨大，且都是可销毁的\n2. 参数keepAliveTime为60L，说明空闲的线程等待时间最长60s\n3. 参数BlockingQueue是一个没有容量的阻塞队列SynchronousQueue，说明任务会一直被线程执行。\n\n**应用场景**：**大小无界的线程池，适用于执行很多的短期异步任务的小程序，或者负载较轻的服务器。  \n注：使用时需控制并发的任务数，否则创建大量的线程可能导致严重的性能问题。**\n\n![image](http://osuskkx7k.bkt.clouddn.com/cached1.png)\n\n**工作过程**：\n1. 首先执行SynchronousQueue.offer()，如果有空闲的线程在执行SynchronousQueue.poll()，表示配对成功，任务交给空闲线程执行。\n2. 初始化时，如果没有空闲的线程，那么创建一个新的线程执行任务。\n3. 步骤2中的线程任务完成后，会执行SynchronousQueue.poll()等待60s，若没有任务提交，则该空闲线程销毁。\n \nSynchronousQueue队列的每个插入操作都要等待一个移除操作，因此是没有容量的队列。\n\n\n---\n\n除上述3种常用线程池外，Executors还可以创建以下几种线程池。\n\n\n**newScheduledThreadPool**：可以定时或周期性执行任务的线程池（线程数目指定）\n\n**newSingleThreadScheduledExecutor：** 可以定时或周期性执行任务的线程池。只有一个线程。\n","tags":["Executor框架"],"categories":["技术"]},{"title":"Java线程池的实现分析","url":"/2017/11/18/Java线程池的实现分析/","content":"### 一、线程池的介绍\n\n线程池是一种并发框架。\n\n优势：\n1. **降低资源消耗。**（重复利用线程，减少开销）\n2. **提高响应速度。**（任务到达可直接执行，不需要等待创建线程）\n3. **提高线程的可管理性**。（统一分配、监控、调优）\n\n**ThreadPoolExecutor是线程池的核心实现类**。可以通过ThreadPoolExecutor来创建一个线程池。\n\n\n### 二、线程池的实现分析\n\n线程池的实现是ThreadPoolExecutor类，因此重点描述ThreadPoolExecutor类的实现。  \n\n#### ThreadPoolExecutor的结构\n\nThreadPoolExecutor的构造方法\n```\npublic ThreadPoolExecutor(int corePoolSize,\n                              int maximumPoolSize,\n                              long keepAliveTime,\n                              TimeUnit unit,\n                              BlockingQueue<Runnable> workQueue,\n                              ThreadFactory threadFactory,\n                              RejectedExecutionHandler handler) {\n        ...(省略部分)\n        this.corePoolSize = corePoolSize;\n        this.maximumPoolSize = maximumPoolSize;\n        this.workQueue = workQueue;\n        this.keepAliveTime = unit.toNanos(keepAliveTime);\n        this.threadFactory = threadFactory;\n        this.handler = handler;\n    }\n```\n构造函数中省略了部分判断的代码。  \n主要有7个参数：  \n\n**corePoolSize**：核心线程池的大小  \n\n**maximumPoolSize**：线程池的大小  \n\n**keepAliveTime**：存活时间（超过核心数目的线程空闲后的存活时间）  \n\n**TimeUnit**：时间单位  \n\n**BlockingQueue<Runnable>**：任务队列（保存等待任务的阻塞队列）  \n\n**ThreadFactory**：创建线程的工厂类   \n\n**RejectedExecutionHandler** ：饱和策略（拒绝策略）\n\n\n![image](http://osuskkx7k.bkt.clouddn.com/%E7%BA%BF%E7%A8%8B%E6%B1%A0.png)\n\n\n#### 工作过程\n\n\n当提交一个新任务时，线程池的工作过程：\n1. **判断核心线程池（corePool）中的线程是否都在执行任务。如果不是，创建一个新的线程执行任务。核心线程池已满，进入2**；  \n \n2. **判断任务队列是否已满。未满，则将新的任务存入；满了，进入3；**\n3. **判断线程池（maximumPoolSize）里的线程是否都在工作。如果没有，创建一个新的线程执行任务；否则，交给饱和策略4**；\n4. **根据不同的饱和策略处理这个任务**。\n\n\n![image](http://osuskkx7k.bkt.clouddn.com/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B.png)\n\n饱和策略有4种：\n- **AbortPolicy（默认）**：直接抛出异常\n- **CallerRunsPolicy**：只用调用者所在线程来处理\n- **DiscardOldestPolicy**：丢弃任务队列中最后一个任务，执行当前任务\n- **DiscardPolicy**：不处理丢弃掉\n\n       \n     \n线程池回收线程时，对所谓的“核心线程”和“非核心线程”是一视同仁的，直到线程池中线程的数量等于corePoolSize参数时，回收过程才会停止。  \n如果设置的corePoolSize参数和maximumPoolSize参数一致时，线程池在任何情况下都不会回收空闲线程。keepAliveTime和timeUnit也就失去了意义。  \n可以调用以下方法回收核心线程。\n```\nthreadPoolExecutor.allowCoreThreadTimeOut(true);\n```\n\n\n\n\n\n#### 线程池处理任务\n线程池处理任务的方法主要有两种，execute()和submit()。\n\n**execute()**  \n\n**execute()方法用于提交不需要返回值的任务**，Runnable实例。所以无法判断任务是否被线程池执行成功。\n\n**submit()**  \n**submit()方法用于提交需要返回值的任务**。线程池会返回一个future类型的对象，通过这个对象可以判断任务是否执行成功。\n\nfuture的get()方法会阻塞当前线程直到任务完成，返回结果。\n\nsubmit()最终调用的也是execute(Runnable runable)，submit()只是将Callable或Runnable封装成一个FutureTask对象，因为FutureTask是个Runnable，所以调用的是execute()方法。\n\n#### 线程池的关闭\n线程池关闭的方法主要有两种，shutdown()和shutdownNow()。\n\n**原理**：遍历线程池中的工作线程，逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法停止。\n\n**区别**：  \n**shutdown()只是将线程池的状态设置成SHUTDOWN状态，然后中断没有在执行任务的线程。**\n\n**shutdownNow()首先将线程池的状态设置成STOP，然后尝试停止所有正在执行或暂停任务的线程，并返回等待执行任务的列表。**\n\n\n如果任务不一定要执行完，可以调用shutdownNow()方法。","tags":["Java线程池"],"categories":["技术"]},{"title":"ConcurrentHashMap在JDK1.8中的实现分析","url":"/2017/11/10/ConcurrentHashMap在JDK1.8中的实现分析/","content":"### 一、ConcurrentHashMap的介绍\n**ConcurrentHashMap在JDK8中进行了巨大改动，它舍弃了锁分段的技术，大量引入了CAS操作，以此来实现并发操作。**   \n\n回忆JDK1.7中的ConcurrentHashmap，当hash碰撞频繁时，链表长度会拉长，而链表的增改删查操作都会消耗很长的时间，影响性能，因此和JDK1.8中的HashMap一样，当链表过长时，将其结构转化为红黑树，由此提高性能。\n### 二、ConcurrentHashMap的实现原理\n\n**ConcurrentHashMap的结构图**\n\nConcurrentHashMap在JDK1.8的实现原理是“**数组+链表+红黑树**”。（与HashMap在1.8中的实现思想一致，但是**红黑树的节点不同**，HashMap是Node节点，ConcurrentHashMap是TreeBin对象）\n\n![image](http://osuskkx7k.bkt.clouddn.com/1.8hash.PNG)\n\n\n---\n\n下面介绍一下ConcurrentHashMap主要方法put()和get()的实现。\n#### put()方法\n\n\n```\nfinal V putVal(K key, V value, boolean onlyIfAbsent) {\n---第一部分\n        if (key == null || value == null) throw new NullPointerException();\n        //计算hash值\n        int hash = spread(key.hashCode());\n        int binCount = 0;\n        for (Node<K,V>[] tab = table;;) {\n            Node<K,V> f; int n, i, fh;\n            //如果tab为null，则初始化\n            if (tab == null || (n = tab.length) == 0)\n                tab = initTable();\n            //判断数组索引位置的元素是否为null\n            else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) {\n                //CAS操作设置该数组索引位置为新节点Node\n                if (casTabAt(tab, i, null,\n                             new Node<K,V>(hash, key, value, null)))\n                    break;                   // no lock when adding to empty bin\n            }\n            //f节点是MOVED节点，表示有其他线程在扩容，帮助一起扩容\n            else if ((fh = f.hash) == MOVED)\n                tab = helpTransfer(tab, f);\n                \n---第二部分-----\n            else {\n                V oldVal = null;\n                synchronized (f) {\n                    if (tabAt(tab, i) == f) {\n                        //表示是链表，还未转化成红黑树\n                        if (fh >= 0) {\n                            binCount = 1;\n                            for (Node<K,V> e = f;; ++binCount) {\n                                K ek;\n                                //如果key已存在，则替换value\n                                if (e.hash == hash &&\n                                    ((ek = e.key) == key ||\n                                     (ek != null && key.equals(ek)))) {\n                                    oldVal = e.val;\n                                    if (!onlyIfAbsent)\n                                        e.val = value;\n                                    break;\n                                }\n                                Node<K,V> pred = e;\n                                //将新的节点插入尾部\n                                if ((e = e.next) == null) {\n                                    pred.next = new Node<K,V>(hash, key,\n                                                              value, null);\n                                    break;\n                                }\n                            }\n                        }\n                        //节点f是TreeBin对象，表示链表转为了红黑树\n                        else if (f instanceof TreeBin) {\n                            Node<K,V> p;\n                            binCount = 2;\n                            if ((p = ((TreeBin<K,V>)f).putTreeVal(hash, key,\n                                                           value)) != null) {\n                                oldVal = p.val;\n                                if (!onlyIfAbsent)\n                                    p.val = value;\n                            }\n                        }\n                    }\n                }\n                if (binCount != 0) {\n                    //如果大于8，转化为红黑树\n                    if (binCount >= TREEIFY_THRESHOLD)\n                        treeifyBin(tab, i);\n                    if (oldVal != null)\n                        return oldVal;\n                    break;\n                }\n            }\n        }\n        addCount(1L, binCount);\n        return null;\n    }\n```\n由于整个put()方法较长，分成两部分来分析。  \n**第一部分：**\n1. 遍历数组tab，如果为null，初始化数组；\n2. **调用tabAt()方法查找数组索引i处的节点f，如果f为null，说明该位置还没有节点，调用casTabAt()利用CAS操作插入新的节点**\n- **CAS成功**：break跳出，直到最后的addCount(1L, binCount)方法，判断插入这一个节点后是否需要扩容; \n- **CAS失败**：说明有其它线程提前插入了节点，自旋重新尝试在这个位置插入节点；  \ntabAt()和casTabAt()方法源码如下：\n```\n private static final sun.misc.Unsafe U;\n \nstatic final <K,V> Node<K,V> tabAt(Node<K,V>[] tab, int i) {\n        return (Node<K,V>)U.getObjectVolatile(tab, ((long)i << ASHIFT) + ABASE);\n    }\nstatic final <K,V> boolean casTabAt(Node<K,V>[] tab, int i,\n                                        Node<K,V> c, Node<K,V> v) {\n        return U.compareAndSwapObject(tab, ((long)i << ASHIFT) + ABASE, c, v);\n    }\n```\n可以看到，都是**调用Unsafe类的方法（原子性），Unsafe.getObjectVolatile可以直接获取指定内存的数据，保证了每次拿到数据都是最新的。**\n3. **若前面的情况都不满足，判断f节点是否为MOVED节点，是则表示有其他线程在扩容，帮助一起扩容**；否则进入第二部分。  \n\n**第二部分：**  \n\n第二部分表示把新的节点Node插入链表或红黑树，可以看到使用了synchronized关键字实现同步。**但是注意，只在节点f上进行同步，表示只能有一个线程访问该节点。** 节点插入之前，再次利用 tabAt(tab, i) == f 判断头节点是否还是f，防止被其它线程修改。\n1. 如果f.hash >= 0，说明f是链表结构的头结点，遍历链表，如果key已存在，则修改value，否则在链表尾部插入节点。\n2. 如果f是TreeBin类型节点，说明链表变成红黑树，则在树结构上遍历元素，更新或增加节点。\n3. 最后判断链表中的节点数binCount >= 8，则转化为红黑树。\n\n---\n\n#### get()方法\n\n```\npublic V get(Object key) {\n        Node<K,V>[] tab; Node<K,V> e, p; int n, eh; K ek;\n        //获取key的hash值\n        int h = spread(key.hashCode());\n        if ((tab = table) != null && (n = tab.length) > 0 &&\n            (e = tabAt(tab, (n - 1) & h)) != null) {\n            if ((eh = e.hash) == h) {\n                if ((ek = e.key) == key || (ek != null && key.equals(ek)))\n                    return e.val;\n            }\n            else if (eh < 0)\n                return (p = e.find(h, key)) != null ? p.val : null;\n            //遍历    \n            while ((e = e.next) != null) {\n                if (e.hash == h &&\n                    ((ek = e.key) == key || (ek != null && key.equals(ek))))\n                    return e.val;\n            }\n        }\n        return null;\n    }\n```\n1. 如果table为null或者遍历之后没找到对应的value，返回null；\n2. 根据key的hash值找到table中指定的Node节点，遍历链表或红黑树找到对应的value值。\n#### 总结\n\n最后总结一下**ConcurrentHashMap从JDK1.7（1.6）到JDK1.8的变化**：\n1. **底层结构改变**，从“**数组+数组+链表**”到“**数组+链表+红黑树**”\n2. **锁方式改变，取消了Segment重入锁，变成CAS+Synchronized实现锁**\n3. **锁粒度变小**，**由Segment数组变成table的元素**。\n4. JDK1.8中size()实现更简单","tags":["JDK1.8"],"categories":["技术"]},{"title":"ConcurrentHashMap在JDK1.7中的实现分析","url":"/2017/11/06/ConcurrentHashMap在JDK1.7中的实现分析/","content":"### 一、ConcurrentHashMap的介绍\nConcurrentHashMap是线程安全且高效的HashMap，可以在多线程的环境下使用。  \n**ConcurrentHashMap允许多个线程并发访问，其关键在于使用了锁分段技术。**   \n锁分段：首先将数据分成一段一段地存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个数据段的时候，其他数据段也能被其他线程访问。\n\n### 二、ConcurrentHashMap的实现原理\n**ConcurrentHashMap的结构图**  \n\nConcurrentHashMap在JDK1.8之前的实现原理是“**数组+数组+链表**”。（可能描述不妥）\n![image](http://osuskkx7k.bkt.clouddn.com/concurrentHashmap.PNG)\n\n  \n第一个数组是Segment[ ]，每一个Segment类似于HashMap；  \n第二个数组是HashEntry[ ]，每个元素可能是一个链表；  \n链表是HashEntry形成的链表，HashEntry是一个节点。\n\n---\n\n#### HashEntry类\n```\nstatic final class HashEntry<K,V> {\n        final int hash;\n        final K key;\n        volatile V value;\n        volatile HashEntry<K,V> next;\n        ....\n        }\n```\nHashEntry类相当于HashMap中的Entry类（节点类），储存了key和value，并拥有指向下一个元素的引用next。  \n注：**value采用volatile修饰，保证了线程之间的可见性**。\n#### Segment类\n```\n static final class Segment<K,V> extends ReentrantLock implements Serializable {\n \n         transient volatile HashEntry<K,V>[] table;\n         transient int count;\n         transient int modCount;\n         transient int threshold;\n         final float loadFactor; \n         ....\n         }\n```\n每个Segment都拥有一个HashEntry[]数组，还有threshold和loadFactor分别表示极限容量和负载因子，count表示元素个数，modCount表示修改的记录。如此看来，**每个Segment就好比是一个缩小版的HashMap**，从上面ConcurrentHashMap结构图也可以看出来。\n\n**Segment继承自ReentrantLock重入锁，因此它支持一个线程重进入同一个Segment，访问其中的数据。**\n\n---\n下面介绍一下ConcurrentHashMap主要的几个方法的实现:put()方法、get()方法、size()方法\n#### put()方法\n\n```\npublic V put(K key, V value) {\n        Segment<K,V> s;\n        if (value == null)\n            throw new NullPointerException();\n        int hash = hash(key);\n        int j = (hash >>> segmentShift) & segmentMask;\n        if ((s = (Segment<K,V>)UNSAFE.getObject\n             (segments, (j << SSHIFT) + SBASE)) == null) \n            // 扩容 \n            s = ensureSegment(j);\n        return s.put(key, hash, value, false);\n    }\n```\n首先定位到相应的Segment。\n如果需要扩容则进入ensureSegment(j)方法，**注意ConcurrentHashMap不会对整个容器扩容，而只对当前的Segment进行扩容。**  扩容为原来的2倍。  \n如果不需要扩容，调用Segment中的put()方法：\n```\nfinal V put(K key, int hash, V value, boolean onlyIfAbsent) {\n            HashEntry<K,V> node = tryLock() ? null :\n                scanAndLockForPut(key, hash, value);\n            V oldValue;\n            try {\n                HashEntry<K,V>[] tab = table;\n                int index = (tab.length - 1) & hash;\n                //取出头节点\n                HashEntry<K,V> first = entryAt(tab, index);\n                //遍历链表\n                for (HashEntry<K,V> e = first;;) {\n                    if (e != null) {\n                        K k;\n                        //key已存在，替换value\n                        if ((k = e.key) == key ||\n                            (e.hash == hash && key.equals(k))) {\n                            oldValue = e.value;\n                            if (!onlyIfAbsent) {\n                                e.value = value;\n                                ++modCount;\n                            }\n                            break;\n                        }\n                        e = e.next;\n                    }\n                    else {\n                        //scanAndLockForPut()方法中已经返回了node，设置为first节点\n                        if (node != null)\n                            node.setNext(first);\n                        else\n                            //新建HashEntry节点作为头节点first\n                            node = new HashEntry<K,V>(hash, key, value, first);\n                        int c = count + 1;\n                        //判断是否扩容\n                        if (c > threshold && tab.length < MAXIMUM_CAPACITY)\n                            rehash(node);\n                        else\n                            setEntryAt(tab, index, node);\n                        ++modCount; //记录修改次数\n                        count = c;  //修改count值\n                        oldValue = null;\n                        break;\n                    }\n                }\n            } finally {\n                unlock();\n            }\n            return oldValue;\n        }\n\n```\n过程分析：  \n\n1. 首先调用tryLock()方法尝试获取锁，如果获取失败，则进入scanAndLockForPut()方法，该方法实际上是先自旋一定的次数等待其他线程释放锁。若自旋过程中，其他线程释放了锁，导致本线程直接获得了锁，就避免了本线程进入等待锁的场景，提高了效率。若自旋一定次数后，仍未获取锁，则调用lock方法进入等待锁的场景。（这是JDK1.7的实现，如果是1.6则没有自旋，直接获取锁）\n2. 获取锁成功，找到对应的链表作相应的操作。具体见代码注释。\n\n#### get()方法\nget()方法不需要锁。**因为value字段是volatile修饰，保证了线程之间的可见性，可以被多线程同时读，但只能被单线程写。一句话，get操作只需要读共享变量value，所以不用加锁。**\n\n```\npublic V get(Object key) {\n        Segment<K,V> s; // manually integrate access methods to reduce overhead\n        HashEntry<K,V>[] tab;\n        int h = hash(key); //第一次散列\n        //第二次散列\n        long u = (((h >>> segmentShift) & segmentMask) << SSHIFT) + SBASE;\n        if ((s = (Segment<K,V>)UNSAFE.getObjectVolatile(segments, u)) != null &&\n            (tab = s.table) != null) {\n            //第三次散列（for循环中）\n            //遍历链表\n            for (HashEntry<K,V> e = (HashEntry<K,V>) UNSAFE.getObjectVolatile\n                     (tab, ((long)(((tab.length - 1) & h)) << TSHIFT) + TBASE);\n                 e != null; e = e.next) {\n                K k;\n                if ((k = e.key) == key || (e.hash == h && key.equals(k)))\n                    return e.value;\n            }\n        }\n        return null;\n    }\n\n```\n（get()方法中用到了许多UNSAFE类的方法，这是在JDK1.6中没有的，主要是利用Native方法来快速的定位元素。）  \n\nget()的过程经过了三次散列：  \n\n**第一次：对key进行散列得到h  \n第二次：对h进行散列定位到哪个Segment  \n第三次：对h进行散列定位到哪个HashEntry** \n\n定位到HashEntry之后就对该链表遍历，查找key对应的value，若没有找到则返回null。  \n\n#### size()方法\n**size()方法需要跨Segment操作，因为要统计每个Segment中的count值。而count值是volatile变量，一般来说将所有的count变量相加就可以得到整个ConcurrentHashMap的大小。** 但可能在累加前使用的count发生了变化，那么结果就不正确。那么该如何统计呢？\n1. 第一种方法，将所有Segment的put、remove、clean方法都锁住，然后统计count值。做法可行，但是低效。\n2. **第二种方法，先尝试连续2次不通过锁住Segment的方式计算各个count值的和：**\n-  若没有发生变化，则作为size的大小。\n-  若发生变化说明有线程在操作元素，则锁住Segment统计所有的count值。\n\n\n**如何判断容器大小没有发生变化？**   \n\n**modCount变量。这个变量记录了每个Segment中put、remove、clean等操作的次数，因此在连续两次统计count的值时，比较modCount是否变化，就可得知容器大小是否变化。**","tags":["JDK1.7"],"categories":["技术"]},{"title":"HashMap引发的线程安全问题","url":"/2017/11/03/HashMap引发的线程安全问题/","content":"### 一、线程安全性\n我们知道，HashMap是非线程安全的，只能在单线程的情况下使用。那么为什么不能在并发的情况下使用呢？**因为在并发时，HashMap的扩容会产生错误而形成环形链表，导致读取数据时发生死循环**。\n\n回忆前面描述的扩容过程，调用了transfer()方法将旧链表转化为新链表：\n\n```\nvoid transfer(Entry[] newTable) {  \n    Entry[] src = table;  \n    int newCapacity = newTable.length;  \n    for (int j = 0; j < src.length; j++) {  \n        Entry<K,V> e = src[j];  \n        if (e != null) {  \n            src[j] = null;  \n            do {  \n                Entry<K,V> next = e.next;  \n                int i = indexFor(e.hash, newCapacity);  \n                e.next = newTable[i];  \n                newTable[i] = e;  \n                e = next;  \n            } while (e != null);  \n        }  \n    }  \n}\n```\n关键代码如下：\n\n```\n        do {  \n        Entry<K,V> next = e.next;  \n        int i = indexFor(e.hash, newCapacity);  \n        e.next = newTable[i];  \n        newTable[i] = e;  \n        e = next;  \n        } while (e != null);  \n```\n循环操作将旧链表中的节点放入新链表，直到下一个节点next为null。  \n分别在单线程和多线程的环境下描述扩容过程。\n#### 单线程扩容\n假设hash数组的大小为2，负载因子为1，即超过1×2=2个元素时扩容，添加3个元素5、7、3，数组大小扩大为4，扩容过程如下：\n    \n![image](http://osuskkx7k.bkt.clouddn.com/h1.png?imageView2/2/w/900/h/450)\n\n原链表中3个元素，循环3次，具体如下：\n```\n第一次循环\ne = 3,next = 7\n3.next = tab[i] = null  (此时数组tab[i]为空)\ntab[i] = 3\ne = 7 \n\n第二次循环\ne = 7,next = 5\n7.next = tab[i] = 3\ntab[i] = 7\ne = 5\n\n第三次循环\ne = 5,next = null\n5.next = tab[i2] = null  (此时数组tab[i2]为空)\ntab[i2] = 5\ne = null \n\n(停止循环)\n\n```\n\n\n#### 多线程扩容\n为什么多线程环境下扩容会形成环形链表呢？  \n还是刚刚的例子，两个线程并发执行，线程1在进入do循环的第一行挂起，线程2继续执行\n\n```\n    do {  \n        Entry<K,V> next = e.next;  //线程1在此处挂起\n        int i = indexFor(e.hash, newCapacity);  \n        e.next = newTable[i];  \n        newTable[i] = e;  \n        e = next;  \n        } while (e != null);\n```\n由前面单线程的情况可知，线程2此时成功扩容，结果如下：\n\n![image](http://osuskkx7k.bkt.clouddn.com/h2.png)\n\n线程1恢复执行，已知线程1的 e 指向了key(3)，而next指向了key(7)，扩容过程如下：\n\n```\n第一次循环\ne = 3,next = 7\n3.next = tab[i] = null  (此时数组tab[i]为空)\ntab[i] = 3\ne = 7 \n\n第二次循环\ne = 7,next = 3\n7.next = tab[i] = 3\ntab[i] = 7\ne = 3\n\n第三次循环\ne = 3,next = null\n3.next = tab[i] = 7\ntab[i] = 3\ne = null\n\n(停止循环)\n```\n第一次循环图：  \n\n![image](http://osuskkx7k.bkt.clouddn.com/h3.png)  \n\n第二次循环图：\n\n![image](http://osuskkx7k.bkt.clouddn.com/h22.png)\n\n第三次循环图：\n\n![image](http://osuskkx7k.bkt.clouddn.com/h4.png)\n\n在停止循环后，问题就出现了，如图所示，key(3)和key(7)构成了环形链表。  \n**于是，当我们调用HashMap的get方法时，由于查找链表节点时无法退出，就会产生无限循环。**\n### 二、解决方法\n\n解决方法就是采用同步的数据结构，主要有以下三种：\n1. **Hashtable**\n2. **Collections.synchronizedMap()**\n3. **ConcurrentHashMap**\n\n#### Hashtable\nHashtable是线程安全的。\n\n```\npublic synchronized V put(K key, V value) {...}\n\npublic synchronized V get(Object key) {...}\n```\n可以看到，**Hashtable是通过在方法上加上synchronized关键字来实现同步功能的**。当一个线程访问时，其他线程都被阻塞住，这种方式效率很低，目前几乎不被使用。\n\n#### Collections.synchronizedMap()\n调用Collections的synchronizedMap()方法，传入一个Map，可以得到一个线程安全的SynchronizedMap。\n\n```\nprivate static class SynchronizedMap<K,V>\n        implements Map<K,V>, Serializable {\n        private final Map<K,V> m;     \n        final Object      mutex;        // Object on which to synchronize\n\n        SynchronizedMap(Map<K,V> m) {\n            this.m = Objects.requireNonNull(m);\n            mutex = this;\n        }\n        ....\n        public V get(Object key) {\n            synchronized (mutex) {return m.get(key);}\n        }\n\n        public V put(K key, V value) {\n            synchronized (mutex) {return m.put(key, value);}\n        }\n```\n可以看到，**它同步的原理同样也是使用了Synchronized关键字，不同的是Synchronized修饰代码块，并且将自身（this）作为了锁对象（mutex）。**\n\n\n#### ConcurrentHashMap\nConcurrentHashMap是JDK1.5之后引入的，是为了替代上面提到的二者。\nConcurrentHashMap是线程安全且高效的HashMap，它使用了多个锁来控制对hash数组不同部分的修改。  \n\n关于它的实现原理可以查看[ConcurrentHashMap](https://youngforzy.github.io/2017/11/10/ConcurrentHashMap在JDK1.8中的实现分析/)这篇文章中的分析。\n","tags":["线程安全"],"categories":["技术"]},{"title":"HashMap 在JDK1.8中的实现（与JDK1.7对比）","url":"/2017/11/01/HashMap 在JDK1.8中的实现（与JDK1.7对比）/","content":"\n### HashMap的实现分析\n\n#### 介绍\n通过前面JDK1.7的分析，我们知道，当负载因子和Hash算法设计的很好时，可以降低hash碰撞的概率，但在数据量过大时也避免不了会出现链表变长的情况，一旦出现链表过长，查找元素变慢，则会严重影响HashMap的性能。  \n于是，在JDK1.8中，对数据结构做了进一步的优化，引入了红黑树。**而当链表长度太长（默认超过8）时，链表就转换为红黑树**，利用红黑树快速增删改查的特点提高HashMap的性能，其中会用到红黑树的插入、删除、查找等算法。\n\n\n\n#### 底层实现\nHashMap的底层实现是**数组+链表+红黑树**。\n\n![image](http://osuskkx7k.bkt.clouddn.com/1.8hash.PNG)\n\n#### 数组索引位置\n\n```\n//第一步\nstatic final int hash(Object key) {\n        int h;\n        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n    }\n\n//第二步，代码中：    \n    tab[i = (n - 1) & hash]   \n```\n确定数组索引的位置同样是两步法：  \n第一步计算hash，与JDK1.7中的计算方法不同；\n计算过程如下：  \n\n![image](http://osuskkx7k.bkt.clouddn.com/hash.png)  \n\n第二步确定索引，与JDK1.7中的相同，只是不作为一个独立的方法；\n#### put()、get()方法\n**put()方法**\n```\npublic V put(K key, V value) {\n        return putVal(hash(key), key, value, false, true);\n    }\n```\n调用了putVal()方法：\n```\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n                   boolean evict) {\n        Node<K,V>[] tab; Node<K,V> p; int n, i;\n        //如果tab为空或长度为0，则分配内存resize()\n        if ((tab = table) == null || (n = tab.length) == 0)\n            n = (tab = resize()).length;\n        //数组索引位置为null，直接put\n        //同时这一步p赋值为tab[i]\n        if ((p = tab[i = (n - 1) & hash]) == null)\n            tab[i] = newNode(hash, key, value, null);\n        else {\n            Node<K,V> e; K k;\n            //判断hash值和key是否都相同，都相同则后面替换value值\n            if (p.hash == hash &&\n                ((k = p.key) == key || (key != null && key.equals(k))))\n                e = p;\n            //红黑书处理冲突    \n            else if (p instanceof TreeNode)\n                e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n            //链表处理冲突\n            else {\n                for (int binCount = 0; ; ++binCount) {\n                    // 在链表尾部插入新结点\n                    if ((e = p.next) == null) {\n                        p.next = newNode(hash, key, value, null);\n                        //节点数 >= 7，转化为红黑树\n                        if (binCount >= TREEIFY_THRESHOLD - 1) \n                            treeifyBin(tab, hash);\n                        break;\n                    }\n                    //已经存在key，退出循环，后面替换value值\n                    if (e.hash == hash &&\n                        ((k = e.key) == key || (key != null && key.equals(k))))\n                        break;\n                    //与e = p.next组合，遍历链表\n                    p = e;\n                }\n            }\n            //已经存在key，替换value值\n            if (e != null) { // existing mapping for key\n                V oldValue = e.value;\n                if (!onlyIfAbsent || oldValue == null)\n                    e.value = value;\n                afterNodeAccess(e);\n                return oldValue;\n            }\n        }\n        ++modCount;\n        //扩容\n        if (++size > threshold)\n            resize();\n        afterNodeInsertion(evict);\n        return null;\n    }\n```\nput过程分析：\n1. 如果数组索引位置tab[i]为null，直接put；否则进入2；\n2. 与第一个节点hash值相同且key值也相同，则直接到后面替换value值，否则进入3；\n3. 判断链表是否形成红黑树，并根据结果进入不同的处理。\n\n---\n\n**get()方法**\n\n```\npublic V get(Object key) {\n        Node<K,V> e;\n        return (e = getNode(hash(key), key)) == null ? null : e.value;\n    }\n```\n调用getNode()方法：\n```\nfinal Node<K,V> getNode(int hash, Object key) {\n        Node<K,V>[] tab; Node<K,V> first, e; int n; K k;\n        if ((tab = table) != null && (n = tab.length) > 0 &&\n            (first = tab[(n - 1) & hash]) != null) {\n            //判断目标是不是first，是直接返回first\n            if (first.hash == hash && // always check first node\n                ((k = first.key) == key || (key != null && key.equals(k))))\n                return first;\n            //已经形成链表\n            if ((e = first.next) != null) {\n                //第一个节点是TreeNode，说明形成了红黑树\n                if (first instanceof TreeNode)\n                    return ((TreeNode<K,V>)first).getTreeNode(hash, key);\n                // 还未形成红黑树，按链表处理   \n                do {\n                    if (e.hash == hash &&\n                        ((k = e.key) == key || (key != null && key.equals(k))))\n                        return e;\n                } while ((e = e.next) != null);\n            }\n        }\n        return null;\n    }\n```\n方法分析：\n1. 首先判断第一个节点first是不是要寻找的节点，如果是直接返回；不是进入2；\n2. 判断第一个节点first是不是树节点，如果是说明形成红黑树，调用红黑树的查找方法；不是则进入3；\n3. 说明还是链表，未形成红黑树，调用链表查找方法。\n\n#### 扩容机制\n我们知道，当往HashMap中不断地添加元素时，它就会扩大数组的长度，把小的数组用大的数组来代替。\n**回忆JDK1.7中的扩容，对于链表中的每个元素都需要重新计算hash值，而在JDK1.8中，只需要看看原来的hash值新增的那个bit是1还是0就好了**，是0的话索引没变，是1的话索引变成“原索引+oldCap（原容量）”，工作过程如下图：\n\n数组由16扩大到32的过程中，索引位置为15的元素变化：\n![image](http://osuskkx7k.bkt.clouddn.com/1.8hahs%E6%89%A9%E5%AE%B9.png)\n\n**注：JDK1.7中旧链表的元素如果刚好又在新链表中，那么元素的顺序是倒置的，而JDK1.8不会倒置。**\n\n#### JDK1.8和JDK1.7的区别（HashMap）\n\n**相同点**\n1. **默认初始容量都是16，默认负载因子都是0.75。数组的长度length都是2的次幂，扩容时都是2倍**\n2. **通过hash计算索引的方法相同（hash & length-1）**\n3. **key为null的键值对都会放入table[0]中**\n4. **都是懒加载，初始时表为空，在插入第一个键值对时初始**化\n\n\n\n\n**不同点**\n1. **结构不同，JDK1.8增加了红黑树优化结构**\n2. **put方法的区别，JDK1.7中put时，添加到头节点；JDK1.8中添加到尾节点**\n3. **计算hash的方法不同，JDK1.8更优化**\n4. **JDK1.7新链表的顺序倒置，JDK1.8新链表顺序不倒置**","tags":["JDK1.8"],"categories":["技术"]},{"title":"HashMap 在JDK1.7中的实现原理分析","url":"/2017/10/30/HashMap 在JDK1.7中的实现原理分析/","content":"### 一、HashMap的介绍\nHashMap是存储键值对（key，value）的一种数据结构。  \n每一个元素都是一个key-value。  \nHashMap最多只允许一个key为null，允许多个key的value值为null。  \nHashMap是非线程安全的，只适用于单线程环境。  \nHashMap实现了Serializable、Cloneable接口，因此它支持序列化和克隆。\n\n\n### 二、HashMap的实现原理\n\n\n从**底层结构、put和get方法、hash数组索引、扩容机制**等几个方面来分析HashMap的实现原理：\n#### 1.底层结构\nHashMap的底层结构是由**数组+链表**构成的。  \n\n![image](http://osuskkx7k.bkt.clouddn.com/hash2.PNG)\n\n\n数组（紫色）：hash数组（桶），数组元素是每个链表的头节点  \n链表（绿色）：解决hash冲突，不同的key映射到了数组的同一索引处，则形成链表。\n\n**构成链表的节点类Node：** （jdk 1.7 中的源码）\n```\nstatic class Entry<K,V> implements Map.Entry<K,V> {\n        final K key;\n        V value;\n        Entry<K,V> next;\n        int hash;\n        ....\n}\n```\n可以看到，key和value都储存于节点之中，next表示下一个节点。\n\n#### 2.put、get方法\n**put()方法：**\n\n```\npublic V put(K key, V value) {  \n    // 若key为null，则将该键值对添加到table[0]中。  \n    if (key == null)  \n        return putForNullKey(value);  \n    // 若key不为null，则计算该key的hash值，然后将其添加到该哈希值对应的数组索引处的链表中。\n    int hash = hash(key.hashCode());  \n    int i = indexFor(hash, table.length);  \n    //遍历该数组索引位置处的链表\n    for (Entry<K,V> e = table[i]; e != null; e = e.next) {  \n        Object k;  \n        // 若该key对应的键值对已经存在，则用新的value替换旧的value，退出  \n        if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {  \n            V oldValue = e.value;  \n            e.value = value;  \n            e.recordAccess(this);  \n            return oldValue;  \n        }  \n    }  \n    modCount++;\n    // 若数组索引位置处table[i]没有链表，即没有元素\n    // 则将key-value添加到数组索引table[i]处，成为头节点\n    addEntry(hash, key, value, i);  \n    return null;  \n}\n```\nput()方法大概过程如下：\n1. **如果添加的key值为null，那么将该键值对添加到数组索引为0的链表中，不一定是链表的首节点。**\n2. **如果添加的key不为null，则根据key计算数组索引的位置**：  \n- **数组索引处存在链表**，则遍历该链表，如果发现key已经存在，那么将新的value值替换旧的value值\n- **数组索引处不存在链表**，将该key-value添加到此处，成为头节点\n\n**addEntry()方法如下：**\n\n```\nvoid addEntry(int hash, K key, V value, int bucketIndex) {  \n    // bucketIndex是数组位置索引，保存“bucketIndex”位置的值到“e”中  \n    Entry<K,V> e = table[bucketIndex];  \n    // 设置“bucketIndex”位置的元素为“新Entry”，设置“e”为“新Entry的下一个节点”  \n    table[bucketIndex] = new Entry<K,V>(hash, key, value, e);  \n    // size超过阈值，则调整HashMap的大小  \n    if (size++ >= threshold)  \n        resize(2 * table.length);  \n}\n```\n**将新的节点（假设为节点n）添加到数组索引位置处，将原来的节点e作为n的next节点，即下一个节点。**\n\n由此可知：**每一次添加的新节点总是作为头节点。**\n\n---\n\n**get()方法：**\n\n```\npublic V get(Object key) {  \n    if (key == null)  \n        return getForNullKey();  \n    // 获取key的hash值  \n    int hash = hash(key.hashCode());  \n    // 在“该hash值对应的链表”上查找“键值等于key”的元素  \n    for (Entry<K,V> e = table[indexFor(hash, table.length)];  \n         e != null;  \n         e = e.next) {  \n        Object k;  \n        //判断key是否相同\n        if (e.hash == hash && ((k = e.key) == key || key.equals(k)))  \n            return e.value;  \n    }\n    //没找到则返回null\n    return null;  \n}  \n \n// 获取“key为null”的元素的值  \n// HashMap将“key为null”的元素存储在table[0]位置，但不一定是该链表的第一个位置！  \nprivate V getForNullKey() {  \n    for (Entry<K,V> e = table[0]; e != null; e = e.next) {  \n        if (e.key == null)  \n            return e.value;  \n    }  \n    return null;  \n}\n```\nget()方法的大概过程：\n1. 如果key为null，那么在数组索引table[0]处的链表中遍历查找key为null的value\n2. 如果key不为null，根据key找到数组索引位置处的链表，遍历查找key的value，找到返回value，若没找到则返回null\n\n\n\n#### 3.hash数组索引位置\n\n前面多次提到了数组索引位置，那么这个位置该如何确定呢？  \n两步：\n1. 确定key的hash值\n2. 根据hash计算索引\n\n```\nstatic int hash(int h) {\n        h ^= (h >>> 20) ^ (h >>> 12);\n        return h ^ (h >>> 7) ^ (h >>> 4);\n    }\n    \nstatic int indexFor(int h, int length) {\n        return h & (length-1);\n    }\n```\n第一步：采用位操作计算hash值，这么做的**目的是为了下一步的索引值分布均匀，减少碰撞，提高效率。**  \n第二步：根据hash值计算索引的值，把hash值和数组长度-1做一个\"与\"操作，保留的值作为索引。\n\n**为什么是length-1？**  \n**这也是HashMap的数组长度要取2的整次幂的原因之一。  因为length为2的整数次幂时，（length-1）正好相当于一个“低位掩码”****。“与”操作的结果就可以保留低位作为数组索引。**  \n例如：length = 16和某个hash值进行 & 操作\n\n\n```\n某个hash           10110110 11100010 01000101\nlength-1=15    &   00000000 00000000 00001111\n           ---------------------------------\n                   00000000 00000000 00000101   //只保留末四位，索引值=5\n```\n**另一个原因**：HashMap的数组长度length为2的整次幂时，length-1为奇数（偶数-1），此时进行 & 操作时可保证最后一位可能是 0 或 1 ，保证了数组索引的均匀性；而如果length-1为偶数，那么 & 操作时最后一位只能是 0，也就是数组索引只能是偶数索引位置，这样就浪费了一半的空间，所以length为2的整次幂。  \n**综上，数组长度取2的整次幂，是为了减少hash碰撞的概率，使元素散列更加均匀。**\n#### 4.扩容机制\n\n先看一个例子，创建一个HashMap，初始容量默认为16，负载因子默认为0.75，那么什么时候它会扩容呢？\n来看以下公式：\n```\n实际容量 = 初始容量 × 负载因子\n```\n计算可知，16×0.75=12，也就是当实际容量超过12时，这个HashMap就会扩容。\n  \n**初始容量**  \n\n当构造一个hashmap时，初始容量设为不小于指定容量的2的次方的一个数（new HashMap(5)， 指定容量为5，那么实际初始容量为8，2^3=8>5），且最大值不能超过2的30次方。  \n\n**负载因子**  \n\n**负载因子是哈希数组在其容量自动增加之前可以达到多满的一种尺度。（时间与空间的折衷）** 当哈希数组中的条目数超出了加载因子与初始容量的乘积时，则要对该哈希数组进行扩容操作（即resize）。  \n**特点：**\n\n- **负载因子越小，容易扩容，浪费空间，但查找效率高**\n- **负载因子越大，不易扩容，对空间的利用更加充分，查找效率低（链表拉长）**\n\n**扩容过程**  \n\n HashMap在扩容时，**新数组的容量将是原来的2倍**，由于容量发生变化，原有的每个元素需要重新计算数组索引Index，再存放到新数组中去，这就是所谓的rehash。\n\n扩容代码：\n```\nvoid resize(int newCapacity) {  \n    Entry[] oldTable = table;  \n    int oldCapacity = oldTable.length;  \n    if (oldCapacity == MAXIMUM_CAPACITY) {  \n        threshold = Integer.MAX_VALUE;  \n        return;  \n    }  \n    // 新建一个HashMap，将“旧HashMap”的全部元素添加到“新HashMap”中\n    // 然后，将“新HashMap”赋值给“旧HashMap”。  \n    Entry[] newTable = new Entry[newCapacity];  \n    transfer(newTable);  \n    table = newTable;  \n    threshold = (int)(newCapacity * loadFactor);  \n}\n```\n调用transfer()方法\n```\nvoid transfer(Entry[] newTable) {  \n    Entry[] src = table;  \n    int newCapacity = newTable.length;  \n    for (int j = 0; j < src.length; j++) {  \n        Entry<K,V> e = src[j];  \n        if (e != null) {  \n            src[j] = null;  \n            do {  \n                Entry<K,V> next = e.next;  \n                int i = indexFor(e.hash, newCapacity);  \n                e.next = newTable[i];  \n                newTable[i] = e;  \n                e = next;  \n            } while (e != null);  \n        }  \n    }  \n}\n```\n第一步for循环遍历每一个数组元素（桶）；  \n第二步遍历每一个数组元素中的链表，将链表中的节点存入新数组指定的位置构成链表，注意此时新链表顺序反转。（原链表的头节点将变成新链表的尾节点）\n**注：原链表中的节点可能存到不同的新链表中，因为rehash重新计算了索引位置。**\n\n由此可知，**扩容操作是一个耗时耗性能的操作，因为它需要重新计算元素的位置，并进行复制操作。因此，在使用时提前预估HashMap的大小有助于提高性能。**\n\nHashMap未初始容量和初始容量的对比：\n\n```\nlong start1 = System.currentTimeMillis();\n\t\tHashMap map = new HashMap<>(); //未初始容量\n\t\tfor(int i=0;i<20000;i++){\n\t\t\tmap.put(i, \"I am zy\");\n\t\t}\n\t\tlong end1 = System.currentTimeMillis();\n\t\tSystem.out.println(\"不初始化时耗时：\"+(end1-start1)+ \"ms\");\n\t\t\n\t\tlong start2 = System.currentTimeMillis();\n\t\tHashMap map2 = new HashMap<>(32768); //初始容量\n\t\tfor(int i=0;i<20000;i++){\n\t\t\tmap2.put(i, \"I am zy\");\n\t\t}\n\t\tlong end2 = System.currentTimeMillis();\n\t\tSystem.out.println(\"初始化时耗时：\"+(end2-start2)+ \"ms\");\n```\n```\n不初始化时耗时：5ms\n初始化时耗时：1ms\n```\n可见初始化容量有助于提高性能，对于数据量大则越明显。\n\n","tags":["HashMap"],"categories":["技术"]},{"title":"ReentrantReadWriteLock可重入读写锁","url":"/2017/10/28/ReentrantReadWriteLock可重入读写锁/","content":"### 一、ReentrantReadWriteLock的概念\n#### 介绍\n前面提到的锁（独占锁、ReentrantLock）等都是排他锁，这些锁在同一时刻只允许一个线程访问。  \n而**读写锁在同一时刻可以允许多个读线程访问，但在写线程访问时，所有读线程和其他写线程都阻塞。**\n\n\nReadWriteLock并不是继承自Lock接口，而是一个单独的接口。\n\n```\npublic interface ReadWriteLock {\n    Lock readLock();\n    Lock writeLock();\n}\n```\nReentrantReadWriteLock则是这个接口的实现。通过readLock()和writeLock()方法可分别获得一个ReadLock实例和一个WriteLock实例，这两个实例实现了Lock接口。\n因此，我们可以调用Lock接口的相关方法来完成锁的语义。\n\n```\nReentrantReadWriteLock rw = new ReentrantReadWriteLock();\nLock r = rw.readLock();\nLock w = rw.writeLock();\n...\n```\n#### 特性：\n1. **公平性：同样有公平锁和非公平锁；**  \n\n2. **重入性：读锁和写锁都支持重入（最大65535）；**\n3. **锁降级：获取写锁之后，获取读锁，释放写锁，保留读锁；（按顺序）**\n\n### 二、ReentrantReadWriteLock的实现原理\n\nReentrantReadWriteLock与ReentrantLock一样，锁的语义的实现依旧是依靠Sync（继承自AQS），它的读锁、写锁的实现原理如下：\n- **读锁：AQS共享锁**\n- **写锁：AQS独占锁**\n\n\n#### 读写状态\n读写锁的实现同样是依赖AQS来实现同步功能。\n那么它的读写状态如何表示呢？\n同样是**使用一个int型的变量**表示，将这个变量“按位切割”成两部分，**高16位表示读，低16位表示写**。这样我们就能通过位运算确定它的读写状态。（如下图）  \n\n![（图）](http://osuskkx7k.bkt.clouddn.com/duxiesuo.jpg)  \n\n如果已知整体同步状态为S，那么：\n- **写状态：S & 0x0000FFFF**（将高16位变0，抹去）\n- **读状态：S>>>16** （无符号补0右移16位）  \n\n**注：当写状态为0，S不为0时，表示读状态不为0，读锁被获取。**\n\n\n\n#### 写锁的获取和释放\n\n写锁是独占锁，获取时调用Sync中的tryAcquire()方法：\n```\nprotected final boolean tryAcquire(int acquires) {\n            Thread current = Thread.currentThread();\n            //获取状态\n            int c = getState();\n            //获取写状态\n            int w = exclusiveCount(c);\n            if (c != 0) {\n                //写状态为0表示存在读线程，获取失败\n                //或当前线程不是获取写锁的线程，获取失败\n                if (w == 0 || current != getExclusiveOwnerThread())\n                    return false;\n                //超过写锁总数量\n                if (w + exclusiveCount(acquires) > MAX_COUNT)\n                    throw new Error(\"Maximum lock count exceeded\");\n                //当前线程是获取写锁的线程，重进入，获取成功\n                setState(c + acquires);\n                return true;\n            }\n            //是否需要阻塞\n            if (writerShouldBlock() ||\n                !compareAndSetState(c, c + acquires))\n                return false;\n            setExclusiveOwnerThread(current);\n            return true;\n        }\n```\n写锁的获取过程如代码中注释所示。\n只有在以下情况才能获取写锁：\n- **不存在读锁或当前线程是已经获取写锁的线程（可重入）**\n\n---\n写锁的释放调用的是Sync的tryRelease()方法：\n\n```\nprotected final boolean tryRelease(int releases) {\n            if (!isHeldExclusively())\n                throw new IllegalMonitorStateException();\n            int nextc = getState() - releases;\n            boolean free = exclusiveCount(nextc) == 0;\n            if (free)\n                setExclusiveOwnerThread(null);\n            setState(nextc);\n            return free;\n        }\n```\n写锁的释放与重入锁的释放过程类似，每次释放时将写状态减少，直到写锁状态为0时，表示写锁释放。\n\n---\n\n#### 读锁的获取和释放\n读锁是共享锁，调用的是Sync的tryAcquireShared()方法：\n\n```\nprotected final int tryAcquireShared(int unused) {\n            Thread current = Thread.currentThread();\n            int c = getState(); //获取状态\n            //写锁不为0  && 且获取写锁的线程不是当前线程\n            //直接失败\n            if (exclusiveCount(c) != 0 &&\n                getExclusiveOwnerThread() != current) \n                return -1;\n            //获取读锁\n            int r = sharedCount(c);\n            //readerShouldBlock()：读锁是否要等待（公平or非公平）\n            // r < MAX_COUNT：读锁小于最大值（65535）\n            //compareAndSetState(c, c + SHARED_UNIT))：CAS操作成功\n            if (!readerShouldBlock() &&\n                r < MAX_COUNT &&\n                compareAndSetState(c, c + SHARED_UNIT)) {\n                //r == 0：只有一个读锁（A），计数+1\n                if (r == 0) {\n                    firstReader = current;\n                    firstReaderHoldCount = 1;\n                //持有读锁的线程（A）重进入，计数++\n                } else if (firstReader == current) {\n                    firstReaderHoldCount++;\n                } else {\n                //另一个线程（B）进入，此时找到缓存的rh，将计数++；\n                    HoldCounter rh = cachedHoldCounter;\n                    if (rh == null || rh.tid != getThreadId(current))\n                        cachedHoldCounter = rh = readHolds.get();\n                    else if (rh.count == 0)\n                        readHolds.set(rh);\n                    rh.count++;\n                }\n                return 1;\n            }\n            //循环尝试\n            return fullTryAcquireShared(current);\n        }\n```\n获取锁的过程如注释所示。  \n如果不满足第二个if语句中的判断，比如读锁需要阻塞，则会进入fullTryAcquireShared（current）方法，**该方法循环不断尝试修改状态直到成功或被写入锁占有。**\n    \n\n```\nfinal int fullTryAcquireShared(Thread current) {\n            HoldCounter rh = null;\n            for (;;) {\n                int c = getState();\n                //写锁存在但不是当前线程，直接失败\n                if (exclusiveCount(c) != 0) {\n                    if (getExclusiveOwnerThread() != current)\n                        return -1;\n                //读锁是否要阻塞（公平 or 非公平）\n                } else if (readerShouldBlock()) {\n                    if (firstReader == current) {\n                    } else {\n                        if (rh == null) {\n                            rh = cachedHoldCounter;\n                            if (rh == null || rh.tid != getThreadId(current)) {\n                                rh = readHolds.get();\n                                if (rh.count == 0)\n                                    readHolds.remove();\n                            }\n                        }\n                        if (rh.count == 0)\n                            return -1;\n                    }\n                }\n                //读锁达到最大值，不能再获取\n                if (sharedCount(c) == MAX_COUNT)\n                    throw new Error(\"Maximum lock count exceeded\");\n                //CAS操作\n                if (compareAndSetState(c, c + SHARED_UNIT)) {\n                    if (sharedCount(c) == 0) {\n                        firstReader = current;\n                        firstReaderHoldCount = 1;\n                    } else if (firstReader == current) {\n                        firstReaderHoldCount++;\n                    } else {\n                        if (rh == null)\n                            rh = cachedHoldCounter;\n                        if (rh == null || rh.tid != getThreadId(current))\n                            rh = readHolds.get();\n                        else if (rh.count == 0)\n                            readHolds.set(rh);\n                        rh.count++;\n                        cachedHoldCounter = rh; \n                    }\n                    return 1;\n                }\n            }\n        }\n```\n以上的代码中多次出现了一个rh变量（HoldCounter），我们知道重入锁的原理就是计数器，同理这个rh变量也相当于一个计数器，记录线程获取读锁的次数。来看它的定义：\n\n```\n//HoldCounter类\nstatic final class HoldCounter {\n            int count = 0;\n            final long tid = getThreadId(Thread.currentThread());\n        }\n//继承ThreadLocal类        \nstatic final class ThreadLocalHoldCounter\n            extends ThreadLocal<HoldCounter> {\n            public HoldCounter initialValue() {\n                return new HoldCounter();\n            }\n        }\n```\nHoldCounter的定义只包含一个计数器和当前线程的Id，它的作用就是记录该线程获取读锁的次数，那么它是如何与线程绑定的呢？我们知道ThreadLocal类是线程维护的私有变量，利用它就可以和线程绑定。  \n\n注：（需要说明的是这样**HoldCounter绑定线程id而不绑定线程对象的原因是****避免HoldCounter和ThreadLocal互相绑定而GC难以释放它们**，所以其实这样做只是为了帮助GC快速回收对象而已。）\n\n---\n\n当读锁释放时，调用的是Sync的tryReleaseShared()方法：\n\n```\nprotected final boolean tryReleaseShared(int unused) {\n            Thread current = Thread.currentThread();\n            if (firstReader == current) {\n                if (firstReaderHoldCount == 1)\n                    firstReader = null;\n                else\n                    firstReaderHoldCount--;\n            } else {\n                HoldCounter rh = cachedHoldCounter;\n                if (rh == null || rh.tid != getThreadId(current))\n                    rh = readHolds.get();\n                int count = rh.count;\n                if (count <= 1) {\n                    readHolds.remove();\n                    if (count <= 0)\n                        throw unmatchedUnlockException();\n                }\n                --rh.count;\n            }\n            for (;;) {\n                int c = getState();\n                int nextc = c - SHARED_UNIT;\n                if (compareAndSetState(c, nextc))\n                    return nextc == 0;\n            }\n        }\n```\n循环CAS操作直到读锁的状态为0。\n#### 锁降级\n前面提到，读写锁有个特性是锁降级。  \n锁降级指的是：**写锁降级为读锁**。\n\n具体过程：**获取写锁的线程把持住写锁，然后获取读锁，再释放写锁。**  \n\n**目的：保证写锁修改的数据可以被其他线程看见，保证了数据的可见性。** \n\n\n锁降级中读锁的获取是否为必要？肯定是必要的。试想，假如当前线程A不获取读锁而是直接释放了写锁，这个时候另外一个线程B获取了写锁，那么这个线程B对数据的修改是不会对当前线程A可见的。   如果获取了读锁，则线程B在获取写锁过程中判断如果有读锁还没有释放则会被阻塞，只有当前线程A释放读锁后，线程B才会获取写锁成功。\n","tags":["可重入读写锁"],"categories":["技术"]},{"title":"JVM之对象创建过程","url":"/2017/10/26/JVM之对象创建过程/","content":"\n### 一、Java对象的创建过程\n\n在Java程序中，通常都是通过 new 关键字来创建对象，那么在虚拟机中对象是如何创建的？  \n（普通Java对象，不包含数组和Class对象）\n\n虚拟机创建对象主要经历5个步骤：**类加载检查、为对象分配内存、内存空间初始化、对象设置、执行对象<init>方法。**\n#### 1 类加载检查\n当虚拟机遇到 new 指令时，首先会去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且**检查这个符号引用代表的类是否已被加载、解析和初始化过**。如果没有，先执行类加载过程。\n#### 2 为对象分配内存\n对象所需的内存大小在类加载完成时已经确定，因此**为对象分配内存等同于在Java堆中划分一块大小确定的内存空间**。  \n##### 两种分配方式：\n- **指针碰撞**：Java堆中的内存是完整的，将指针往空闲空间挪动一段与对象大小相等的距离\n- **空闲列表**：Java堆中的内存不是完整的，JVM维护了一个记录可用内存的列表，分配时将列表中足够大的空间划分给对象，并更新列表\n\n因此选择何种分配方式由Java堆是否完整决定，而这又由垃圾收集器是否带有压缩整理功能决定。如：\n\n- **Serial、ParNew等采用指针碰撞**\n- **CMS基于“标记-清除”采用空闲列表**\n\n##### 线程安全问题\n当处于并发情况下时，还要考虑线程安全问题。\n两种解决方案：\n- **对分配内存的动作进行同步处理**。JVM采用CAS加失败重试的方式保证原子性\n- **把内存分配的动作按照线程划分在不同的空间进行**。每个线程在Java堆中预先分配一小块内存（本地线程分配缓冲TLAB），只有TLAB用完重新分配时才同步锁定。\n#### 3 内存空间初始化\nJVM将分配到的内存空间都初始化为零值（不包括对象头）；若使用TLAB，则提前至TLAB分配时执行。\n\n这一步**保证了对象实例字段在Java代码中可以不赋初值就直接使用**，程序能访问到这些字段的数据类型所对应的零值。\n\n#### 4 对象设置\nJVM设置对象头信息，如类元数据信息、对象的哈希码、对象的GC分代年龄信息等。还有是否启用偏向锁。\n#### 5 执行对象<init>方法\n此时，对于JVM来说，对象已经产生；  \n对于Java程序来说，才刚刚开始，执行<init>方法进行初始化，一个对象才算真正创建完成。\n\n\n### 二、Java对象的初始化\n\n在Java对象初始化过程中，主要涉及三种执行对象初始化的结构，分别是 **实例变量初始化、实例代码块初始化** 以及 **构造函数初始化**。 \n\n#### 实例变量初始化与实例代码块初始化\n在定义（声明）实例变量的同时，还可以直接对实例变量进行赋值或者使用实例代码块对其进行赋值。  \n如果我们**以这两种方式为实例变量进行初始化，那么它们将在构造函数执行之前完成这些初始化操作。** 实际上，如果我们对实例变量直接赋值或者使用实例代码块赋值，那么编译器会将其中的代码放到类的构造函数中去，并且这些代码会被放在对超类构造函数的调用语句之后(Super())，构造函数本身的代码之前。\n```\npublic class Tdemo2 {\n\t//成员变量\n\tprivate int i = 1;\n\tprivate int j = 1;\n\tpublic  Tdemo2(int c){\n\t\tSystem.out.println(i);\n\t\tSystem.out.println(j);\n\t\tthis.i = c;\n\t\tSystem.out.println(i);\n\t}\n\t//代码块\n\t{\n\t\tj = j+1;\n\t}\n\t//静态代码块\n\tstatic{\n\t\tint a = 5;\n\t\tSystem.out.println(a);\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Tdemo2(3);\n\t}\n}\n```\n输出：\n```\n5\n1\n2\n3\n```\n可见执行顺序是static代码块、成员变量赋值、代码块、构造函数。\n#### 构造函数初始化\n\n**Java要求在实例化类之前，必须先实例化其超类，以保证所创建实例的完整性。**\nJava强制要求Object对象(Object是Java的顶层对象，没有超类)之外的所有对象构造函数的第一条语句必须是超类构造函数的调用语句或者是类中定义的其他的构造函数，如果我们既没有调用其他的构造函数，也没有显式调用超类的构造函数，那么编译器会为我们自动生成一个对超类构造函数的调用。\n\n实际上，实例化一个类的对象的过程是一个典型的递归过程。\n\n![image](http://osuskkx7k.bkt.clouddn.com/%E5%AE%9E%E4%BE%8B%E5%8C%96%E9%80%92%E5%BD%92%E8%BF%87%E7%A8%8B.png)\n\n\n在准备实例化一个类的对象前，首先准备实例化该类的父类，如果该类的父类还有父类，那么准备实例化该类的父类的父类，依次递归直到递归到Object类。\n\n**注意：实例初始化不一定要在类初始化结束之后才开始初始化。**\n\n\n回忆一下Java中赋值顺序： \n1. 父类的静态变量赋值 \n2. 自身的静态变量赋值 \n3. 父类成员变量赋值和父类代码块赋值 \n4. 父类构造函数赋值 \n5. 自身成员变量赋值和自身块代码赋值 \n6. 自身构造函数赋值\n\n\n### 三、Java对象的创建方式\n\nJava对象的创建方式有 5 种：\n1. new 关键字\n```\nPerson p = new Person();\n```\n2. Class类的newInstance()（反射）\n```\nPerson p2 = Person.class.newInstance();\n```\n3. Constructor类的newInstance方法（反射）\n```\nConstructor c = Person.class.getConstructor();\nPerson p3 = (Person) c.newInstance();\n```\n4. clone方法（实现Cloneable接口）\n```\nPerson p4 = (Person) p3.clone();\n```\n5. 反序列化（实现Serializable接口）\n```\n//写对象\nObjectOutputStream output = new ObjectOutputStream(new FileOutputStream(\"person.txt\"));\noutput.writeObject(p);\noutput.close();\n\n//读对象\nObjectInputStream input = new ObjectInputStream(new FileInputStream(\"person.txt\"));\nPerson p5 = (Person) input.readObject();\n```\n\n\n\n","tags":["对象创建过程"],"categories":["技术"]},{"title":"JVM之类加载机制","url":"/2017/10/24/JVM之类加载机制/","content":"\n### 一、类加载机制\n\n虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被JVM直接使用的Java类型，这就是虚拟机的**类加载机制**。\n\n#### 类加载的时机\n那么类到底什么时候会加载呢？（初始化）  \n**当对一个类进行主动引用的时候**。\n##### 主动引用\n主动引用有5种情况：\n1. new实例化对象、读取或设置一个类的静态字段时、调用一个类的静态方法时\n2. 使用java.lang.reflect包的方法对类进行反射调用时\n3. 初始化一个类时，父类还没初始化，则先触发父类的初始化\n4. 虚拟机启动时，初始化包含main()方法的主类\n5. 使用JDK1.7的动态语言支持的时候，如java.lang.invoke.MethodHandle实例\n\n##### 被动引用\n被动引用有以下几种情况：\n1. 子类调用父类的静态变量，子类不会被初始化，只有父类会被初始化。（只有定义静态字段的类才会被初始化）\n2. 通过数组来定义引用类，不会初始化\n3. 访问类的final常量(编译期静态常量)，不会初始化\n4. 通过类名获取Class对象，不会触发类的初始化(其余两种getClass()和Class.forName()会)\n```\n//类名.class获取Class对象\nClass clazz = A.class;\n```\n\n### 二、类加载过程\n\n#### 类的生命周期 \n\n![image](http://osuskkx7k.bkt.clouddn.com/%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F2.jpg.png)\n\n\n**类的生命周期包括：加载、验证、准备、解析、初始化、使用和卸载7个阶段。** 验证、准备、解析这三个阶段称为连接。\n解析阶段的顺序不是确定的，可以在初始化之后开始。\n\n**类加载过程**包括**加载、验证、准备、解析、初始化**。\n#### 加载  \nJVM完成以下3件事：\n1. 通过一个类的全限定名来获取定义此类的二进制字节流（不一定是Class文件）。\n2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。\n3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。\n\n\n注：\n- 数组类本身不通过类加载器创建，由虚拟机直接创建\n- 内存中实例化的Class对象并不是在堆中，存放于方法区（HotSpot虚拟机）\n#### 验证  \n验证的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求。\n主要完成以下4个检验动作：\n1. 文件格式验证：如魔数、版本号、常量类型....\n2. 元数据验证：这个类是否有父类？是不是抽象类？是否继承了不允许被继承的类？\n3. 字节码验证：对类的方法体进行校验分析，确定程序语义是合法、符合逻辑的。\n4. 符号引用验证：（发生在解析阶段）符号引用中通过字符串描述的全限定名是否能找到对应的类？...\n\n验证阶段是一个很重要但不一定是必要的阶段。\n\n#### 准备  \n**准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。**（这里的类变量仅为Static修饰的变量，不包括实例变量，实例变量是在对象实例化时随着对象分配在堆中）\n\n假设一个类变量定义为：\n```\npublic static int value = 666;\n```\n那么在准备阶段过后，初始值为0，而不是666，因为把value赋值为666的动作在初始化阶段才会执行。\n\n但是下面这种情况除外：\n\n```\npublic static final int value = 666;\n```\n当用final修饰时，会在准备阶段赋值为666。\n\n#### 解析\n**解析阶段是虚拟机将常量池中的符号引用替换为直接引用的过程。**  \n\n**符号引用**：定义在Java虚拟机规范的Class文件格式中（与虚拟机内存布局无关）  \n**直接引用**：直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。（与虚拟机内存布局相关）\n\n#### 初始化\n类初始化阶段是类加载过程的最后一步。**初始化阶段才真正开始执行类中定义的Java程序代码。**\n\n在准备阶段，类变量被赋了初始值，在初始化阶段才会真正赋值。或者说，初始化阶段是执行类构造器<clinit>()方法的过程。\n\n##### <clinit>()方法\n- <clinit>()方法是编译器自动收集类中的所有变量的赋值动作和静态语句块（static{}）中的语句合并产生的，顺序由源文件顺序决定。\n- <clinit>()方法与类的构造函数不同（实例构造器<init>()），它不需要显示地调用父类构造器，虚拟机保证子类<clinit>()方法执行之前，父类<clinit>()方法已经执行完毕。因此，JVM中第一个执行的<clinit>()方法的类是java.lang.Object。\n- <clinit>()方法对于类或接口来说不是必须的，一个类没有静态语句块或者没有对变量的赋值操作，可以没有<clinit>()方法\n- 接口中有变量初始化赋值的操作时，会生成<clinit>()方法。但接口不需要执行父接口的<clinit>()方法。接口的实现类在初始化时也不要=会执行接口的<clinit>()方法。\n- 虚拟机保证一个类的<clinit>()方法会在多线程情况下加锁、同步。只有一个线程会执行<clinit>()方法成功。\n\n### 三、类加载器\n\n在加载阶段中，**“通过一个类的全限定名来获取定义此类的二进制字节流”这个动作的实现是由类加载器来完成的。**\n这个动作在JVM外部实现，以便让应用程序自己决定如何去获取所需要的类。\n\n**简而言之，类加载器用于实现类的加载动作。**\n\n只有由同一个类加载器加载的两个类才相等。若同一个Class文件由不同的类加载器加载，则不相等。\n\n\n#### 3种类加载器\n\n![image](http://osuskkx7k.bkt.clouddn.com/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8.png)\n\n- **启动类加载器（Bootstrap ClassLoader）**：负责加载<JAVA_HOME>\\lib目录中，或者被-Xbootclasspath参数所指定的路径中，并且被虚拟机识别的如rt.jar等类库\n- **扩展类加载器（Extension ClassLoader）**：加载<JAVA_HOME>\\lib\\ext目录中的，或通过java.ext.dirs系统变量指定路径中的类库\n- **应用程序类加载器（Application ClassLoader**）：加载用户类路径（ClassPath）上指定的类库，也叫系统类加载器，程序默认的类加载器\n\n#### 双亲委派模型\n\n工作过程：**如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此。因此所有的加载请求最终都会传送到顶层的启动类加载器中，只有当父加载器无法完成这个加载请求时，子加载器才会自己去加载。**\n\n\n双亲委派模型有什么好处？  \n\n保证了Java程序的稳定运行。\n例如，java.lang.Object存放在rt.jar中，无论哪一个类加载器加载这个类，最终都会委派给启动类加载器进行加载，**因此Object类在程序的各种类加载器环境中都是同一个类。**\n\n\n\n\n","tags":["类加载机制"],"categories":["技术"]},{"title":"JVM之垃圾收集器","url":"/2017/10/23/JVM之垃圾收集器/","content":"### 一、垃圾收集器概述\n\n**垃圾收集器是内存垃圾回收算法的具体实现。**  \nJava虚拟机规范中对垃圾收集器应该如何实现并没有任何规定，因此出现了7种收集器：Serial、ParNew、Parallel Scavenge、Serial Old、Parallel Old、CMS、G1。  \n它们以组合的形式配合工作来完成不同分代的垃圾收集工作。\n\n**常用组合**：\n1. Serial/Serial Old\n2. ParNew/Serial Old\n3. ParNew/CMS\n4. Parallel Scavenge/Parallel Old\n5. G1\n\n![image](http://osuskkx7k.bkt.clouddn.com/JVMtool2.png)\n\n#### Minor GC和Full GC\nMinor GC（新生代GC）：发生在新生代的GC动作，频率高，回收速度块。\n\nFull GC（老年代GC）：发生在老年代的GC动作，老年代满了后才进行，一般伴随至少一次Minor GC，频率低，回收速度慢。\n\n#### 垃圾收集器种类\n目前的收集器主要有以下三种：  \n\n**串行收集器：** 只有一条垃圾收集线程工作  \n\n**并行收集器：** 多条垃圾收集线程并行工作，用户线程等待\n\n\n**并发收集器：** 垃圾收集线程与用户线程同时执行（不一定并行，可能交替执行）\n\n### 二、垃圾收集器详述\n\n#### 新生代收集器（3种）\n##### Serial 收集器（串行）\nSerial收集器是一个单线程的收集器。  \n“单线程”：不仅只是有一条收集线程，而且必须暂停用户工作线程。 \n\n工作过程：  \n\n![image](http://osuskkx7k.bkt.clouddn.com/seria.png)\n\n**特点：** 单线程，无线程切换，简单高效，（管理内存小，停顿可以接受）  \n**缺点：**  暂停工作线程    \n**应用场景：** 适用于运行在Client模式下的虚拟机\n\n\n##### ParNew 收集器（并行）\nParNew收集器是Serial收集器的多线程版本。\n\n工作过程：  \n\n![image](http://osuskkx7k.bkt.clouddn.com/ParNew.png)\n\n**特点：** 多线程，除Serial外唯一能和CMS收集器配合  \n**缺点：**  暂停工作线程，单线程下不如Serial    \n**应用场景：** 适用于运行在Server模式下的虚拟机\n\n##### Parallel Scavenge 收集器（并行）\n\nParallel Scavenge收集器被称为“吞吐量优先”收集器。\n\n工作过程：  \n\n![image](http://osuskkx7k.bkt.clouddn.com/parallel%20scavenge.png)\n\n**特点：** \n- **可控制吞吐量。**  \n吞吐量 = 用户代码时间/（用户代码时间+垃圾收集时间）  \n吞吐量越高，表示越高效地利用CPU，适合后台运算任务。  \n- **GC 自适应调节策略**  \n  JVM可以根据当前系统的运行情况自适应调节参数，以提供最合适的停顿时间和最大的吞吐量。\n\n**缺点：** 相比停顿时间更注重吞吐量    \n**应用场景：** 主要用于后台计算，不需要与用户进行太多交互，对暂停时间没有特别高的要求等场景，如批量处理；\n\n#### 老年代收集器（3种）\n\n##### Serial Old 收集器（串行）\nSerial Old是Serial的老年代版本，同样是一个单线程收集器。  \n\n工作过程：  \n\n![image](http://osuskkx7k.bkt.clouddn.com/seria.png)\n\n**特点：** 单线程，“标记-整理”算法  \n**缺点：**  暂停工作线程    \n**应用场景：** 适用于运行在Client模式下的虚拟机\n\n##### Parallel Old 收集器（并行）\n\nParallel Old是Parallel Scavenge收集器的老年代版本，多线程收集器。（JDK1.6之后出现）\n\n工作过程：  \n\n![image](http://osuskkx7k.bkt.clouddn.com/parallel%20old.png)\n\n**特点：** 多线程，“标记-整理”算法，唯一能和Parallel Scavenge收集器配合  \n**缺点：**  暂停工作线程   \n**应用场景：** 适用于注重吞吐量及CPU资源敏感的场合\n\n##### CMS 收集器（并发）\n\n**CMS（Concurrent Mark Sweep）是一种以获取最短回收停顿时间为目标的收集器。  \n第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。**  \n\n工作过程分为**4个步骤**：  \n1. **初始标记**：标记“GC-Roots”关联的对象（Stop the World）\n2. **并发标记**： 进行GC-Roots Tracing的过程，在刚才产生的集合中标记出存活对象；\n3. **重新标记**：修正并发标记期间因用户程序继续运作而导致标记变动的那一部分对象的标记记录（Stop the World）\n4. **并发清除**：回收所有垃圾对象\n\n所以，**在初始标记和重新标记阶段，还是只有垃圾收集线程工作；并发标记和并发清除阶段是和用户线程并发执行的**。\n\n![image](http://osuskkx7k.bkt.clouddn.com/CMS.png)\n\n**特点：** 多线程并发执行，停顿时间短  \n**缺点：**  \n- 对CPU资源十分敏感\n- 无法处理浮动垃圾\n- 产生大量空间碎片（由于是“标记-清除”算法）  \n\n**应用场景：** 适用于大型网站或B/S的服务端，注重响应速度和用户体验。\n\n#### 通用收集器\n##### G1 收集器（并发）\nG1是目前最前沿的收集器，可处理整个GC堆，JDK1.7之后出现。  \n\n**G1是如何处理整个堆**？  \nG1将整个堆划分为多个大小相等的独立区域Region（不再是新生代老年代），然后跟踪各个Region获得其垃圾收集价值大小，并在后台维护一个优先列表，根据允许的收集时间，优先回收价值最大的Region（名称Garbage-First的由来）。这个过程保证了在有限的时间内可以回收更多的垃圾。\n\n\n工作过程分为**4个步骤**： \n1. **初始标记**：标记“GC-Roots”关联的对象，并修改TAMS的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象\n2. **并发标记**：根据GC-Roots进行可达性分析，找出存活对象\n3. **最终标记**：为了修正并发标记期间由于用户程序继续运作而导致标记产生变动的那一部分对象的标示记录\n4. **筛选回收**：根据各个Region的价值回收\n\n\n![image](http://osuskkx7k.bkt.clouddn.com/G1.png)\n\n**特点：** \n- 并行且并发  \n- 独立处理整个GC堆，不需要配合其他收集器\n- 可预测停顿时间\n- 不产生空间碎片\n\n\n**应用场景：** 面向服务器，适用于多CPU及大容量内存的机器。\n\n\n### 三、常见的参数配置\n\n- **Xms**：堆的最小值（初始）\n- **Xmx**：堆的最大值  \n（Xms、Xmx二者一样时，可避免自动扩展）\n- **Xmn**：堆中新生代的大小\n- **Xss**：每个线程的堆栈大小\n- **XX:PermSize**：永久代的大小（初始）\n- **XX:MaxPermSize**：永久代的最大值\n- **XX:NewRatio**：年轻代（包括Eden和两个Survivor区）与年老代的比值，设置为3，则年轻代与年老代所占比值为1：3，年轻代占整个堆栈的1/4\n\n- **XX:SurvivorRatio**：年轻代中Eden区与Survivor区的大小比值。设置为4，则两个Survivor区与一个Eden区的比值为2:4，一个Survivor区占整个年轻代的1/6\n\n\n\n\n\n","tags":["垃圾收集器"],"categories":["技术"]},{"title":"JVM之垃圾收集算法","url":"/2017/10/21/JVM之垃圾收集算法/","content":"### 一、对象的死亡判定\n\n**JVM垃圾回收针对哪些区域？回收的是什么？**  \n**答：**   \n**1. 主要针对Java堆。**  \n**2. 回收“死亡”的对象，即没有引用的对象。**\n\n\n那么如何判断对象是否“死亡”呢？  \n两种方法，引用计数法和可达性分析算法。\n\n#### 引用计数法\n**原理：给每个对象添加一个引用计数器。**\n\n- 每当有一个地方引用它，引用计数器+1；\n- 每当一个引用失效，引用计数器-1；\n- 当引用计数器为0时，表示该对象无引用，即可回收。\n\n缺点：无法解决对象之间循环引用的问题。\n\n```\nGCobject A = new GCobject();\nGCobject B = new GCobject();\nA.instance = B;\nB.instance = A;\n...\nA = null;\nB = null;\n\n```\n可以看到，A、B对象都为null，已经不可能再访问，但由于A、B都有字段引用着对方，引用计数器不为0，因此不会被回收。\n\n#### 可达性分析算法\n\n**原理：通过一系列称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为“引用链”，当一个对象到 GC Roots没有任何引用链相连时, 则说明此对象是不可用的。**  \n\n![image](http://osuskkx7k.bkt.clouddn.com/gc1.jpg.png)\n\n如图，Object5、Object6、Object7这三个对象就是不可用的。\n\n**“GC Roots”对象：**\n\n- 虚拟机栈(栈帧中的本地变量表)中引用的对象；\n- 方法区中类静态引用的对象；\n- 方法区中常量引用的对象；\n- 本地方法栈中JNI（Native方法）引用的对象；\n\n\n---\n\n然而，在可达性分析算法中不可达的对象，也并不是“非死不可”。**一个对象真正死亡，至少要经历两次标记过程：**\n1.  **第一次标记：** 对象无GC Roots的引用链，筛选是否执行finalize()方法：  \n\n- 对象没有覆盖finalize()或finalize()被JVM调用过，则不需要执行；\n- 若执行finalize()，则将对象放入F-Queue队列中，会由JVM自动建立的线程执行该方法；\n\n\n2. **第二次标记**：对F-Queue队列中的对象进行小规模的标记：\n- 对象在finalize()中拯救自己（重新与引用链相连），则不会回收；\n- 对象没有在finalize()中逃脱；\n\n**注：任何一个对象的finalize()方法只能被调用一次。**\n\n### 二、垃圾收集算法\n主要有4种垃圾收集算法。  \n**Java堆从GC的角度可以细分为: 新生代(Eden区、From Survivor区和To Survivor区)和老年代。**\n#### 标记-清除算法（老年代）\n它是最基础的收集算法，**算法分为标记和清除两个阶段：**\n1. 首先标记出所有可回收的对象\n2. 统一回收被标记对象\n\n![image](http://osuskkx7k.bkt.clouddn.com/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4.jpg)  \n\n不足：\n1. 效率问题，标记和清除的效率不高；\n2. 空间问题，标记清除后容易产生不连续的空间碎片（不利于大对象的内存分配）\n\n\n#### 复制算法（新生代）\n**算法的核心是将可用内存按容量划分为大小相等的两块，每次只用其中一块，当这一块的内存用完，就将还存活的对象复制到另外一块上面，然后把已使用过的内存空间一次清理掉。**（如图）\n\n\n![image](http://osuskkx7k.bkt.clouddn.com/%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.jpg)\n\n优点：无内存碎片；  \n不足：可用内存减小；  \n\n针对以上不足，就有了**现代复制算法**：  \n不需完全按照1∶1的比例划分新生代空间，\n将**新生代划分为一块较大的Eden区和两块较小的Survivor区(from和to)**(HotSpot默认Eden和Survivor的大小为8∶1)，每次只用Eden和其中一块Survivor（from）。\n- 当发生MinorGC时, 将Eden和Survivor(from)中还存活着的对象一次性地拷贝到另外一块Survivor(to)上，最后清理掉Eden和刚才用过的Survivor(from)空间。\n- 当Survivor(to)空间不够用(不足以保存尚存活的对象)时, 需要依赖老年代进行空间分配担保机制，这部分内存直接进入老年代。\n\n**注：现代的商业虚拟机都是采用这种收集算法回收新生代。**\n\n\n#### 标记-整理算法（老年代）\n标记-清除算法会产生内存碎片问题，而复制算法需要有额外的内存担保空间，于是针对老年代的特点，又有了标记整理算法。  \n**标记整理算法：标记过程与标记-清除算法相同， 但后续步骤不再对可回收对象直接清理， 而是让所有存活的对象都向一端移动，然后清理掉端边界以外的内存。** （如图）  \n\n![image](http://osuskkx7k.bkt.clouddn.com/%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86.jpg)\n\n\n\n#### 分代收集算法\n当前主流JVM垃圾收集都采用”分代收集”(Generational Collection)算法。 这种算法会根据对象存活周期的不同将内存划分为几块， 如JVM中的**新生代、老年代、永久代**。 这样就可以根据各年代特点分别采用最适当的GC算法：\n\n- **新生代**：每次垃圾收集都能发现大批对象已死， 只有少量存活。因此选用**复制算法**，只需要付出少量存活对象的复制成本就可以完成收集。\n- **老年代**：因为对象存活率高、没有额外空间对它进行分配担保，就必须采用“**标记—清理”或“标记—整理**”算法来进行回收，不必进行内存复制，且直接腾出空闲内存。\n\n\n\n\n\n","tags":["垃圾收集算法"],"categories":["技术"]},{"title":"ReentrantLock重入锁","url":"/2017/10/20/ReentrantLock重入锁/","content":"### 一、ReentrantLock概念\n#### 重入锁概念\n什么是重入锁？   顾名思义，就是支持重复进入的锁。  \n**定义：支持一个线程对资源的重复加锁。（注意是一个线程）**\n\n回忆前面有关AQS实现的文章，关于独占锁，当一个线程获取锁后，如果该线程再次调用lock()方法，那么该线程会被自己阻塞。  \n原因是在实现tryAcquire()时没有考虑占有锁的线程再次获取锁的场景。因此这个锁是不支持重入的锁。  \n\n回顾synchronized的实现原理，我们知道它也是支持重进入的锁，即可以多次获取锁。\n\n那么Lock能不能实现这个功能呢？当然是可以的。  \nReentrantLock就是一个支持重进入的锁：**在调用lock()方法时，已经获取到锁的线程，可以再次调用lock()方法获取锁而不被阻塞。**\n#### 公平与非公平\n关于锁的获取，还有一个公平性的问题，于是就有了公平锁与非公平锁：  \n\n-   **公平锁：获取锁是顺序的。先对锁请求的线程先获取；**  \n-   **非公平锁：获取锁是无序的。任意线程都可以获取，无关请求先后；**\n\n来看看ReentrantLock的构造函数：\n\n```\npublic ReentrantLock() {\n        sync = new NonfairSync();\n    }\npublic ReentrantLock(boolean fair) {\n        sync = fair ? new FairSync() : new NonfairSync();\n    }\n```\n\n\n可以看到，ReentrantLock默认构造函数是非公平锁，另一个构造函数：  \n-   传入true：公平锁  \n-   传入false：非公平锁\n\n\n\n### 二、ReentrantLock的实现原理\n#### 重进入\n\n**重进入的实现原理是定义了一个获取锁的计数器**。 涉及到以下两个问题：  \n\n1. **线程再次获取锁。**  \n锁需要识别获取锁的线程是否为当前占据锁的线程，如果是，则再次获取锁成功，计数器+1。\n2. **锁的最终释放。**  \n线程重复n次获取了锁，在第n次释放锁后，其他线程能够获取到锁。释放锁时，计数器-1，计数器为0时表示锁释放成功。\n\n---\n\n**ReentrantLock**\n```\npublic class ReentrantLock implements Lock, java.io.Serializable {\nprivate final Sync sync;\n//AQS\nabstract static class Sync extends AbstractQueuedSynchronizer {...};\n//非公平锁\nstatic final class NonfairSync extends Sync {...};\n//公平锁\nstatic final class FairSync extends Sync {...};\n\n....(省略)\n}\n```\n从源码可以看到，**ReentrantLock的实现依旧是依靠队列同步器AQS（Sync继承自AQS），不同的是这里有两个AQS的实现类，NonfairSync和FairSync，分别实现非公平锁和公平锁的功能。**\n\n\n#### 非公平锁的实现\n\n非公平锁获取锁的方法：\n```\nfinal boolean nonfairTryAcquire(int acquires) {\n            final Thread current = Thread.currentThread();\n            int c = getState();\n            if (c == 0) {\n                if (compareAndSetState(0, acquires)) {\n                    setExclusiveOwnerThread(current);\n                    return true;\n                }\n            }\n            else if (current == getExclusiveOwnerThread()) {  //判断\n                int nextc = c + acquires;\n                if (nextc < 0) // overflow\n                    throw new Error(\"Maximum lock count exceeded\");\n                setState(nextc);\n                return true;\n            }\n            return false;\n        }\n```\n该方法是Sync中的方法，NonfairSync通过重写tryAcquire()调用。  \n可以看到，该方法增加了一个判断：如果当前线程是已经获取锁的线程，那么将同步状态值State增加 **（这里不需要CAS操作，因为该线程已经获取了锁，没有竞争——相当于偏向锁）**，并返回true，表示同步状态获取成功。\n\n\n非公平锁释放锁的方法：\n\n```\nprotected final boolean tryRelease(int releases) {\n            int c = getState() - releases;\n            if (Thread.currentThread() != getExclusiveOwnerThread())\n                throw new IllegalMonitorStateException();\n            boolean free = false;\n            if (c == 0) {\n                free = true;\n                setExclusiveOwnerThread(null);\n            }\n            setState(c);\n            return free;\n        }\n```\n该方法也是由Sync实现。\n\n既然获取锁的时候增加了同步状态值，那么释放时自然要减少。\n可以看到，只有当State值减为0的时候，才返回true，表示释放锁成功，并将占有线程设置为null。\n\n\n#### 公平锁的实现\n\n公平锁获取锁的方法：\n\n```\nprotected final boolean tryAcquire(int acquires) {\n            final Thread current = Thread.currentThread();\n            int c = getState();\n            if (c == 0) {\n                if (!hasQueuedPredecessors() &&\n                    compareAndSetState(0, acquires)) {\n                    setExclusiveOwnerThread(current);\n                    return true;\n                }\n            }\n            else if (current == getExclusiveOwnerThread()) {\n                int nextc = c + acquires;\n                if (nextc < 0)\n                    throw new Error(\"Maximum lock count exceeded\");\n                setState(nextc);\n                return true;\n            }\n            return false;\n        }\n    }\n```\n该方法是FairSync重写的tryAcquire()方法。  \n对比非公平锁的获取，**唯一不同的是该方法在判断时增加了一个条件——hasQueuedPredecessors()方法，该方法判断同步队列中当前节点是否有前驱节点，如果有，表示有线程比当前线程更早请求，则需要等待前面的线程获取释放锁之后才能获取锁。**\n\n    \n公平锁释放锁的方法：  \n\n同样也是调用Sync中的tryRelease()方法，这里不再赘述。\n\n\n#### 公平锁与非公平锁的对比\n\n**公平锁：**\n- 保证了锁的获取顺序，FIFO原则\n- 不足是需要进行大量的线程切换\n\n**非公平锁**：  \n\n- 保证了更大的吞吐量（极少的线程切换）\n- 不足是可能造成线程“饥饿”（等待很久）\n\n**频繁的线程切换对性能有很大的影响，因此ReentrantLock的默认实现是非公平锁。**","tags":["重入锁"],"categories":["技术"]},{"title":"AQS共享锁的实现原理","url":"/2017/10/19/AQS共享锁的实现原理/","content":"### 一、AQS共享锁的实现原理\n\n前面的文章Lock的实现中分析了AQS独占锁的实现原理，那么接下来就分析下AQS是如何实现共享锁的。\n\n#### 共享锁的介绍\n**共享锁：同一时刻有多个线程能够获取到同步状态。**\n\n那么它是如何做到让多个线程获取到同步状态呢？  \n来看一下获取共享锁的过程：\n1.  线程调用AQS的acquireShared()申请获取锁（可有多个线程获取到，根据重写的tryAcquireShared()方法决定），如果成功则进入临界区。\n2.  如果失败，创建一个共享型的节点进入FIFO等待队列，阻塞然后等待唤醒。\n3.  等待队列中的线程被唤醒重新尝试获取锁，**获取成功后根据state变量值决定是否继续唤醒后续节点（如果state值为0，表示没有可用的锁，不唤醒后继节点；如果state的值>0，表示有可用的锁，唤醒后继节点）**，获取失败则继续等待，直到成功。\n\n释放共享锁的过程：\n1. 线程调用releaseShared()进行锁资源释放，如果释放成功则唤醒队列中等待的节点（如果有）。\n\n#### 共享式获取锁\n\n线程调用acquireShared()方法获取锁：\n```\npublic final void acquireShared(int arg) {\n        if (tryAcquireShared(arg) < 0)\n            doAcquireShared(arg); //获取失败进入该方法\n    }\n```\n分析如下：\n- 当tryAcquireShared(arg)返回值>=0时（可以在重写该方法时自定义锁的数量），表示获取锁成功，不会进入doAcquireShared。\n- 当tryAcquireShared(arg)返回值<0时,进入doAcquireShared(arg)方法，可以猜想这里应该是构造节点放入等待队列，看如下代码：\n\n```\nprivate void doAcquireShared(int arg) {\n        final Node node = addWaiter(Node.SHARED);  //构造等待队列，和独占锁类似\n        boolean failed = true;\n        try {\n            boolean interrupted = false;\n            for (;;) {       //自旋\n                final Node p = node.predecessor(); //获取前驱节点\n                if (p == head) {\n                    int r = tryAcquireShared(arg); //再次尝试获取\n                    if (r >= 0) {\n                        setHeadAndPropagate(node, r);\n                        p.next = null; // help GC\n                        if (interrupted)\n                            selfInterrupt();\n                        failed = false;\n                        return;\n                    }\n                }\n                if (shouldParkAfterFailedAcquire(p, node) &&\n                    parkAndCheckInterrupt())\n                    interrupted = true;\n            }\n        } finally {\n            if (failed)\n                cancelAcquire(node);\n        }\n    }\n```\n可以看到，当前驱节点是头节点head时，线程尝试获取锁，此时注意返回值r，有以下三种可能：\n\n- r<0，表示获取锁失败，继续自旋直到r>=0；\n- r=0，表示获取锁成功，但刚好是最后一把锁，不会唤醒后继节点，在setHeadAndPropagate(node, r)方法中可以体现出来，后面会分析到；\n- r>0，表示获取锁成功，而且还有锁资源，会唤醒后继节点，同样在setHeadAndPropagate(node, r)方法中可以体现。  \n\n那么就来看一下setHeadAndPropagate(node, r)这个方法：\n\n```\nprivate void setHeadAndPropagate(Node node, int propagate) {\n        Node h = head; // 记录原来的头节点\n        setHead(node);  // 将当前节点设置为头节点\n        if (propagate > 0 || h == null || h.waitStatus < 0 ||\n        (h = head) == null || h.waitStatus < 0) {\n            Node s = node.next;\n            if (s == null || s.isShared())\n                doReleaseShared();\n        }\n    }\n```\n注意这里propagate的值就是上一个方法中的r，首先将当前节点设置为头节点，然后if中的判断表示以下两种情况需要执行唤醒操作：\n\n1.  根据r的值判断，r>0时，表示可以唤醒后继节点，执行doReleaseShared()方法；而当r=0时，不会直接执行doReleaseShared()方法，而是进入第二种情况继续判断；\n2.  头节点后面的节点需要被唤醒（waitStatus<0），不论是老的头结点还是新的头结点\n\n接下来看看doReleaseShared()这个方法：\n\n```\nprivate void doReleaseShared() {\n        for (;;) { //自旋\n            Node h = head;\n            if (h != null && h != tail) {\n                int ws = h.waitStatus;\n                if (ws == Node.SIGNAL) { //表示后继节点需要被唤醒\n                    if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))\n                        continue;            // loop to recheck cases\n                    unparkSuccessor(h); //唤醒\n                }\n                else if (ws == 0 &&\n                         !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))\n                    continue;    //如果后继节点暂时不需要唤醒，则把当前节点状态设置为PROPAGATE确保以后可以传递下去\n            }\n            if (h == head)                   // loop if head changed\n                break;\n        }\n    }\n```\n这里有两个入口可以进入该方法，一个是直接释放锁releaseShared()一个是上述setHeadAndPropagate()方法，因此在释放锁的过程中需要使用CAS操作保证线程安全。\n1. 进入第一个if语句，表示后继节点需要被唤醒，采用CAS循环操作直到成功；\n2. 进入else if语句，表示暂时不需要唤醒，将状态传递；\n3. 最后判断头节点是否变化，没有变化则退出循环；如果头结点发生变化，比如说其他线程获取到了锁，为了使自己的唤醒动作可以传递，必须进行重试\n\n以上就是获取共享锁的大致过程。\n\n\n#### 共享式释放锁\n\n调用releaseShared()方法主动释放锁：\n```\npublic final boolean releaseShared(int arg) {\n        if (tryReleaseShared(arg)) {\n            doReleaseShared();\n            return true;\n        }\n        return false;\n    }\n```\n可以看到，当重写的tryReleaseShared(arg)方法返回true,成功释放锁资源，进入doReleaseShared()唤醒等待的线程，这个方法上面已经分析过，这里不再赘述。\n\n\n\n### 二、AQS共享锁与独占锁的对比\n共享锁的实现稍比独占锁复杂，但大同小异。二者对比如下：\n- **独占锁：**  \n1. 独占锁是只有头节点获取锁，其余节点的线程继续等待，等待锁被释放后，才会唤醒下一个节点的线程；\n\n2. 同步状态state值在0和1之间切换，保证同一时间只能有一个线程是处于活动的，其他线程都被阻塞，参考ReentranLock。\n3. 独占锁是一种悲观锁。 \n- **共享锁：**  \n1. 共享锁是只要头节点获取锁成功，就在唤醒自身节点对应的线程的同时，继续唤醒AQS队列中的下一个节点的线程，每个节点在唤醒自身的同时还会唤醒下一个节点对应的线程，以实现共享状态的“向后传播”，从而实现共享功能。\n2. 同步状态state值在整数区间内（自定义实现），如果state值<0则阻塞，否则不阻塞。参考ReadWriteLock、Semphore、CountDownLautch等。\n3. 共享锁是一种乐观锁，允许多个线程同时访问共享资源。","tags":["共享锁"],"categories":["技术"]},{"title":"Lock实现之AQS——AbstractQueuedSynchronizer","url":"/2017/10/18/Lock实现之AQS——AbstractQueuedSynchronizer/","content":"### 一、AQS的介绍\n**队列同步器AbstractQueuedSynchronizer（AQS）是构建锁或者其他同步组件的基础框架，是实现Lock的基础。它使用了一个volatile修饰的int变量来表示同步状态，并维护了一个FIFO队列来完成资源获取线程的排队。**\n\n\n```\npublic abstract class AbstractQueuedSynchronizer extends AbstractOwnableSynchronizer \nimplements java.io.Serializable {\n \n private transient volatile Node head;//头节点\n private transient volatile Node tail;//尾节点\n private volatile int state;          //同步状态\n protected final int getState() {\n      return state;\n }\nprotected final void setState(int newState) {\n    state = newState;\n}\nprotected final boolean compareAndSetState(int expect, int update) {\n   return unsafe.compareAndSwapInt(this, stateOffset, expect, update);\n}\n...\n```\n从上面AQS的部分代码可以看到，AQS是一个类，它包含了表示同步状态的state变量（volatile修饰）；维护队列的两个引用头节点head和尾节点tail（volatile修饰）；以及提供了三个主要方法，用来保证同步状态的改变是线程安全的；省略了其他方法。\n\n那么AQS是如何实现锁的呢？  \n**当我们需要实现锁的时候，首先继承AQS并重写指定的方法，然后将AQS子类组合在自定义组件（锁）的实现中，并调用AQS的模板方法，而这些模板方法将会调用我们重写的方法（模板方法模式）**，这就可以达到我们想要的效果。  \n**注：重写指定的方法时需要用到AQS中的三个主要方法来对同步状态进行访问或修改。**\n\nAQS中可重写的方法如下：\n```\nprotected boolean tryAcquire(int arg) {} //独占式获取\nprotected boolean tryRelease(int arg) {} //独占式释放\nprotected int tryAcquireShared(int arg) {} //共享式获取\nprotected boolean tryReleaseShared(int arg) {} //共享式释放\nprotected boolean isHeldExclusively() {} //判断AQS是否被该线程独占\n```\n来看一个独占锁的示例。\n\n```\nclass Mutex implements Lock, java.io.Serializable {\n   // 内部类，自定义同步器，继承AQS\n   private static class Sync extends AbstractQueuedSynchronizer {\n     // 重写方法——是否处于占用状态\n     protected boolean isHeldExclusively() {\n       return getState() == 1;\n     }\n     // 重写方法——当状态为0的时候获取锁\n     public boolean tryAcquire(int acquires) {\n       assert acquires == 1; // Otherwise unused\n       if (compareAndSetState(0, 1)) {\n         setExclusiveOwnerThread(Thread.currentThread());\n         return true;\n       }\n       return false;\n     }\n     // 重写方法——释放锁，将状态设置为0\n     protected boolean tryRelease(int releases) {\n       assert releases == 1; // Otherwise unused\n       if (getState() == 0) throw new IllegalMonitorStateException();\n       setExclusiveOwnerThread(null);\n       setState(0);\n       return true;\n     }\n     // 返回一个Condition，每个condition都包含了一个condition队列\n     Condition newCondition() { return new ConditionObject(); }\n   }\n   // 仅需要将操作代理到Sync上即可\n   private final Sync sync = new Sync();\n   public void lock()                { sync.acquire(1); }\n   public boolean tryLock()          { return sync.tryAcquire(1); }\n   public void unlock()              { sync.release(1); }\n   public Condition newCondition()   { return sync.newCondition(); }\n   public boolean isLocked()         { return sync.isHeldExclusively(); }\n   public boolean hasQueuedThreads() { return sync.hasQueuedThreads(); }\n   public void lockInterruptibly() throws InterruptedException {\n     sync.acquireInterruptibly(1);\n   }\n   public boolean tryLock(long timeout, TimeUnit unit)\n       throws InterruptedException {\n     return sync.tryAcquireNanos(1, unit.toNanos(timeout));\n   }\n }\n```\n以上就是利用AQS来实现一个独占锁的示例。  \nMutex是一个自定义的Lock，它在同一时刻只允许一个线程占有锁。**它定义了一个静态内部类继承自AQS，并重写了相应的方法，实现了独占式的获取释放锁。**  \n在重写的tryAcquire方法中，**调用CAS方法改变同步状态，因为是原子操作只有一个线程能完成**；在重写的tryRelease方法中将同步状态设为0。  \n在使用这个Lock时，我们只要调用Mutex的方法，有关同步的细节都由同步器完成。大大降低了自定义并发组件的门槛。\n\n### 二、AQS的实现原理分析\n知道了AQS的用法，那么就来分析下它的实现原理。\n**同步器可分为独占式和共享式。** 一般只实现其中一种。这里主要分析独占锁的实现。\n\n#### 同步队列\nAQS是依靠内部的同步队列来完成同步状态的管理，当前线程获取同步状态失败时，会将当前线程以及等待状态等信息构造成一个节点（node）加入同步队列，并阻塞当前线程。当同步状态释放时，会把首节点中的线程唤醒，使其尝试获取同步状态。\n\n##### Node类\n\n```\nstatic final class Node {\n        static final Node SHARED = new Node();\n        static final Node EXCLUSIVE = null;\n        static final int CANCELLED =  1;\n        static final int SIGNAL    = -1;\n        static final int CONDITION = -2;\n        static final int PROPAGATE = -3;\n        volatile int waitStatus; //线程的等待状态（上述）\n        volatile Node prev; //前驱节点\n        volatile Node next; //后继节点\n        volatile Thread thread; //线程引用\n        Node nextWaiter; //等待队列中的后继节点\n        ...\n        }\n```\nNode是AQS维护的静态内部类。用来保存线程引用（失败）、等待状态和前后节点。  \n节点是构成同步队列的基础，同步器拥有首节点（head）和尾节点（tail），获取同步状态失败的线程会成为节点加入队列的尾部。同步器结构如下： \n![image](http://osuskkx7k.bkt.clouddn.com/AQS2.png?imageView2/2/w/500/h/300)\n\n\n**注：构造节点的过程必须保证线程安全，因为会有多个线程失败。那么它是如何做到的？AQS提供了一个基于CAS的构造尾节点的方法compareAndSetTail，它可以保证节点被正确地加入到队列中。**\n\n#### 独占式获取锁\n来看一看获取锁的流程。  \n调用AQS的acquire（int args）方法获取同步状态。\n\n```\npublic final void acquire(int arg) {\n    if (!tryAcquire(arg) &&acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n            selfInterrupt();\n    }\n```\n**&&：** 短路与，当第一个为false时不再判断后面条件；第一个为true时还会判断第二个条件；  \n**&:**     当第一个为false时，还会判断后面的条件；\n- \n  当成功获取锁，即tryAcquire(arg)为true时，!tryAcquire(arg) 为false，跳出if，此时执行selfInterrupt()；\n-   当没有成功获取锁，即tryAcquire(arg)为false时，!tryAcquire(arg) 为true时，接着判断第二个条件，两个步骤： \n\n步骤一：  addWaiter(Node.EXCLUSIVE)：将该节点加入同步队列的尾部,返回该节点；  \n步骤二： acquireQueued(Node node, arg))：使该节点以\"死循环\"的方式获取同步状态；若获取不到则阻塞节点中的线程，被阻塞的线程的唤醒主要依靠前驱节点的出队或阻塞线程被中断来实现。\n\n**分析步骤一：addWaiter方法**\n\n```\nprivate Node addWaiter(Node mode) {\n        Node node = new Node(Thread.currentThread(), mode);\n        Node pred = tail;\n        if (pred != null) { //如果有尾节点，快速尝试在尾部添加，减少开销\n            node.prev = pred;\n            if (compareAndSetTail(pred, node)) {\n                pred.next = node;\n                return node;                  //如果已经有尾节点，利用CAS将自己添加为尾节点之后返回\n            }\n        }\n        enq(node);          //如果没有尾节点，那么进入enq方法\n        return node;\n    }\nprivate Node enq(final Node node) {\n        for (;;) {\n            Node t = tail;\n            if (t == null) {        \n                if (compareAndSetHead(new Node()))    //初始化头节点\n                    tail = head;\n            } else {\n                node.prev = t;\n                if (compareAndSetTail(t, node)) {   //CAS添加node为尾节点\n                    t.next = node;\n                    return t;\n                }\n            }\n        }\n```\n\n可以看到，若队列还未生成即没有尾节点，则进入enq方法中，先创造一个头节点，然后通过死循环**for(;;)** 来保证节点的正确添加，再通过**compareAndSetTail（CAS）** 这个方法确保节点能够被线程安全地添加（可以想象多个线程获取同步失败后，如果不保证线程安全添加，将导致顺序混乱，可能丢失线程），只有从CAS返回后，线程才能返回，否则将不断尝试。\n这个enq方法将并发的添加节点的请求通过CAS变得串行化了。\n\n**分析步骤二：acquireQueued方法**  \n节点进入同步队列后，就进入了一个自旋的过程，每个节点（或线程）都在自省的观察，当获取到同步状态就可以从自旋中退出，否则依旧自旋。\n\n```\nfinal boolean acquireQueued(final Node node, int arg) {\n        boolean failed = true;\n        try {\n            boolean interrupted = false;\n            for (;;) {\n                final Node p = node.predecessor();     //获得前驱节点\n                if (p == head && tryAcquire(arg)) {  //只有前驱节点是头节点才尝试获取锁，false直接跳出if\n                    setHead(node);        //获取成功，将自己设置为头节点\n                    p.next = null;           // help GC\n                    failed = false;\n                    return interrupted;       //返回false，回到acquire方法中，不执行selfInterrupt();\n                }\n                if (shouldParkAfterFailedAcquire(p, node) &&\n                    parkAndCheckInterrupt())\n                    interrupted = true;\n            }\n        } finally {\n            if (failed)\n                cancelAcquire(node);\n        }\n    }\n```\n\n```\nprivate void setHead(Node node) {\n        head = node;\n        node.thread = null;\n        node.prev = null;\n    }\n```\n这段代码主要做了2件事：\n\n  1. 判断当前节点的前驱节点是否为头节点并尝试tryAcquire，只有当前驱节点是head的节点才会尝试tryAcquire，如果节点尝试tryAcquire成功，执行setHead方法将当前节点作为head、将当前节点中的thread设置为null、将当前节点的prev设置为null，这保证了链表中头结点永远是一个不带Thread的空节点；\n\n  2. 如果当前节点的前驱节点不是头节点或者tryAcquire失败，那么执行第13行~第15行的代码，做了两步操作，首先判断在acquie失败后是否应该park（阻塞），其次park并检查中断状态；  \n  \n分析下第2件事：\n```\nprivate static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {\n        int ws = pred.waitStatus;\n        if (ws == Node.SIGNAL)     //ws=SIGNAL= -1\n            return true;\n        if (ws > 0) {             //ws=CANCELLED= 1\n            do {\n                node.prev = pred = pred.prev;\n            } while (pred.waitStatus > 0);\n            pred.next = node;\n        } else {                 //ws=CONDITION= -2 or PROPAGATE= -3\n            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);\n        }\n        return false;\n    }\n```\n­这个方法做了以下工作，\n­每个节点判断它前驱节点的状态：  \n1. 它的前驱节点是SIGNAL状态的，返回true，表示当前节点应当park(阻塞)，执行parkAndCheckInterrupt()，­该方法利用LockSupport的park方法让当前线程阻塞，如下。 \n\n```\nprivate final boolean parkAndCheckInterrupt() {\n        LockSupport.park(this);\n        return Thread.interrupted();\n    }\n```\n\n2. 它的前驱节点的waitStatus>0，即CANCELLED，那么CANCELLED的节点作废，当前节点不断向前找并重新连接为双向队列，直到找到一个前驱节点的waitStats不是CANCELLED的为止。\n3. 它的前驱节点不是SIGNAL状态且waitStatus<=0，即CONDITION或PROPAGATE，此时执行第11行代码，利用CAS机制，将前驱节点的状态更新为SIGNAL状态。\n****\n\n\n\n#### 独占式释放锁\n调用AQS的release方法可以释放同步状态，唤醒后继节点。\n\n```\npublic final boolean release(int arg) {\n        if (tryRelease(arg)) {       \n            Node h = head;\n            if (h != null && h.waitStatus != 0)\n                unparkSuccessor(h);  //调用LockSupport来唤醒处于等待状态的线程\n            return true;\n        }\n        return false;\n    }\n```\ntryRelease释放成功，获取到head节点，如果head节点的waitStatus不为0的话，执行unparkSuccessor方法。\n\n```\nprivate void unparkSuccessor(Node node) {\n        int ws = node.waitStatus;\n        if (ws < 0)\n            compareAndSetWaitStatus(node, ws, 0);\n        Node s = node.next;\n        if (s == null || s.waitStatus > 0) {\n            s = null;\n            for (Node t = tail; t != null && t != node; t = t.prev)\n                if (t.waitStatus <= 0)\n                    s = t;\n        }\n        if (s != null)\n            LockSupport.unpark(s.thread);\n    }\n```\n这个方法做了以下工作：  \n1. 头节点的waitStatus<0，将头节点的waitStatus设置为0；\n2. 拿到头节点的下一个节点s，如果s==null或者s的waitStatus>0（被取消了），那么从队列尾巴开始向前寻找一个waitStatus<=0的节点作为后继要唤醒的节点；\n3. 如果拿到了一个不等于null的节点s，就利用LockSupport的unpark方法让它取消阻塞。\n#### 总结： \n获取同步状态时，AQS维护一个同步队列，获取状态失败的线程都会加入到队列中并在队列中进行自旋；移出队列的条件是前驱节点为头节点且获取同步状态成功。  \n释放同步状态时，头节点唤醒它的后继节点。","tags":["Lock"],"categories":["技术"]},{"title":"Lock接口的介绍及使用","url":"/2017/10/17/Lock接口的介绍及使用/","content":"### 一、Lock的介绍\n\n我们知道，在Java中锁的实现可以由synchronized关键字来完成，但在Java5之后，出现了一种新的方式来实现——Lock接口。\n\n那么为什么提出这种新的方式呢？  \n在多线程的情况下，当一段代码被synchronized修饰之后，同一时刻只能被一个线程访问，其他线程都必须等到该线程释放锁之后才能有机会获取锁访问这段代码，占用锁的线程只有在两种情况下才能释放锁：  \n\n1. 线程执行完了这段代码，释放锁；\n2. 线程执行发生异常，释放锁；  \n\n考虑一下，如果该线程由于IO操作或者其他原因（调用Sleep方法）被阻塞了，那么其他线程就会一直无期限地等待下去，后果可想而知。  \n那么能否用一种方式来防止等待的线程无限等待呢？（等待一段时间或者响应中断）通过Lock就可以实现。\n\n再如：当用多线程对文件进行读写时，读与写是互斥的，写与写是互斥的，但读与读却不是互斥的。如果用synchronized来实现同步，就会有这样的问题：多个线程都只需要读操作，但只能有一个线程进行读操作，其他线程只能等待。  \n那么能不能让线程不用等待，多线程都能进行读操作呢？通过Lock就可以实现。\n\n\n\n\n### 二、Lock的用法\n\nLock是一个接口，包含以下方法：\n```\npublic interface Lock {\nvoid lock();      //获取锁\nvoid lockInterruptibly() throws InterruptedException; //可中断的获取锁\nboolean tryLock(); //尝试非阻塞的获取锁\nboolean tryLock(long time, TimeUnit unit) throws InterruptedException; //超时获取锁\nvoid unlock(); //释放锁\nCondition newCondition(); //获取等待通知组件，和当前的锁绑定\n}\n```\n可以看到当使用Lock时，获取锁和释放锁都是主动调用执行的，而synchronized则是系统自动释放锁的。  \n前四个方法都是用来获取锁的，但各有区别：  \n- **lock()**：是最常用的获取锁的方法，若锁被其他线程获取，则等待（阻塞）。\n- **tryLock()**：尝试非阻塞地获取锁，立即返回。获取成功返回true；获取失败返回false，但不会阻塞。\n- **tryLock(long time, TimeUnit unit)**：与tryLock()相似，但是会超时等待一段时间，如果未获取到返回false。\n- **lockInterruptibly()**：可中断地获取锁，该方法会响应中断，在锁的获取过程中可以中断当前线程。  \n\n**注：当使用synchronized关键字时，一个线程在等待获取锁的过程中是无法中断的。而使用lockInterruptibly()方法获取某个锁时，如果不能获取到，在进行等待的情况下是可以响应中断的。**\n\n\n\n\nLock的使用：\n\n```\nLock lock = new ReentrantLock(); //可重入锁（Lock的一种实现）\nlock.lock();\ntry{\n    dosomething();\n}finally{\n    lock.unlock();\n}\n```\n**在finally块中释放锁的目的是保证获取锁之后，最终能被释放。**  \n不要将获取锁——lock()放在try中，如果在获取锁时发生了异常，异常抛出的同时，也会导致锁的无故释放（需要主动释放）。\n\n\n\n\n\n### 三、与synchronized的区别\nLock与synchronized的区别：  \n\n1. Lock是一个接口，是代码层面的实现；synchronized是关键字，是内置的语言实现（JVM层面）。\n2. Lock是显示地获取释放锁，扩展性更强；synchronized是隐式地获取释放锁，更简捷。\n2. Lock在发生异常时，如果没有主动通过unlock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生。\n3. Lock可以让等待锁的线程响应中断；而使用synchronized时等待锁的线程会一直等待下去，不能响应中断；\n4. Lock可以尝试非阻塞、可中断、超时地获取锁；synchronized不可以。\n4. Lock可以知道是否成功获取锁；synchronized无法知道。  \n\n\n\n总结：在资源竞争不是很激烈的情况下，Synchronized的性能要优于Lock；但是在资源竞争很激烈的情况下，Synchronized的性能会下降几十倍，Lock的性能更优；","tags":["Lock"],"categories":["技术"]},{"title":"深入理解synchronized关键字","url":"/2017/10/14/深入理解synchronized/","content":"## 一、synchronized的基本介绍\n\n谈到synchronized关键字，想必大家都不陌生，对它的初次印象如果用两个字来概括，无非就是 **“同步”** 。小小的一个词，蕴含了大道理，那么就让我们来探索一下。  \n### 1.简介\n**synchronized实现同步的基础是：java中的任何一个对象都可以作为锁。**  \n\n它有三种用法：  \n\n **1. 修饰普通同步方法，锁是当前实例对象**  \n \n**2. 修饰静态同步方法，锁是当前类的class对象（唯一）**\n\n**3. 修饰同步代码块，锁是括号中的对象**  \n\n### 2.使用\n来看以下几段代码  \n（1）不使用synchronized\n```\npublic class SynTest {\n\t\n\tpublic void method1(){\n\t\tSystem.out.println(\"method 1 start\");\n\t\ttry {\n\t\t\tSystem.out.println(\"method 1 execute\");\n\t\t\tThread.sleep(2000);\n\t\t} catch (InterruptedException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tSystem.out.println(\"method 1 end\");\n\t}\n\t\n\tpublic void method2(){\n\t\tSystem.out.println(\"method 2 start\");\n\t\ttry {\n\t\t\tSystem.out.println(\"method 2 execute\");\n\t\t\tThread.sleep(1000);\n\t\t} catch (InterruptedException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tSystem.out.println(\"method 2 end\");\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tSynTest test = new SynTest();\n\t\t//线程1---method1\n\t\tnew Thread(new Runnable() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\ttest.method1();\n\t\t\t}\n\t\t}).start();\n\t\t//线程2---method2\n\t\tnew Thread(new Runnable() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\ttest.method2();\n\t\t\t}\n\t\t}).start();\n\t}\n}\n```\n```\nmethod 1 start\nmethod 2 start\nmethod 2 execute\nmethod 1 execute\nmethod 2 end\nmethod 1 end\n```\n可以看出，在不加synchronized修饰时，两个线程同时执行，互不冲突，线程2比线程1执行的快，因此先执行完毕。  \n（2）synchronized修饰普通方法\n\n```\npublic class SynTest {\n\t\n\tpublic synchronized void  method1(){\n\t\tSystem.out.println(\"method 1 start\");\n\t\t\n\t\ttry {\n\t\t\tSystem.out.println(\"method 1 execute\");\n\t\t\tThread.sleep(2000);\n\t\t} catch (InterruptedException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tSystem.out.println(\"method 1 end\");\n\t}\n\tpublic synchronized void method2(){\n\t\tSystem.out.println(\"method 2 start\");\n\t\t\n\t\ttry {\n\t\t\tSystem.out.println(\"method 2 execute\");\n\t\t\tThread.sleep(1000);\n\t\t} catch (InterruptedException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tSystem.out.println(\"method 2 end\");\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tSynTest test = new SynTest();\n\t\t//线程1---method1\n\t\tnew Thread(new Runnable() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\ttest.method1();\n\t\t\t}\n\t\t}).start();\n\t\t//线程2---method2\n\t\tnew Thread(new Runnable() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\ttest.method2();\n\t\t\t}\n\t\t}).start();\n\t}\n}\n```\n\n```\nmethod 1 start\nmethod 1 execute\nmethod 1 end\nmethod 2 start\nmethod 2 execute\nmethod 2 end\n```\n可以看出，线程2在线程1执行完成后才开始执行，达到了同步的效果。**这是因为两个线程需要获取同一把锁（即test对象）**，线程1先拿到锁，线程2只能等待直到线程1释放锁，才能执行。  \n（3）synchronized修饰静态方法\n\n```\npublic class SynTest {\n\t\n\tpublic static synchronized void  method1(){\n\t\tSystem.out.println(\"method 1 start\");\n\t\t\n\t\ttry {\n\t\t\tSystem.out.println(\"method 1 execute\");\n\t\t\tThread.sleep(2000);\n\t\t} catch (InterruptedException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tSystem.out.println(\"method 1 end\");\n\t}\n\tpublic static synchronized void method2(){\n\t\tSystem.out.println(\"method 2 start\");\n\t\t\n\t\ttry {\n\t\t\tSystem.out.println(\"method 2 execute\");\n\t\t\tThread.sleep(1000);\n\t\t} catch (InterruptedException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tSystem.out.println(\"method 2 end\");\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tSynTest test = new SynTest();\n\t\tSynTest test2 = new SynTest();\n\t\t//线程1---method1\n\t\tnew Thread(new Runnable() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\ttest.method1();\n\t\t\t}\n\t\t}).start();\n\t\t//线程2---method2\n\t\tnew Thread(new Runnable() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\ttest2.method2();\n\t\t\t}\n\t\t}).start();\n\t}\n}\n```\n```\nmethod 1 start\nmethod 1 execute\nmethod 1 end\nmethod 2 start\nmethod 2 execute\nmethod 2 end\n\n```\n可以看出，两个线程同样获得了同步的效果。但是明明是两个不同的对象（test、test2）所调用的，这是为什么？  \n**在这里synchronized修饰的是静态方法，而静态方法本质上是类的方法，因此这里的同步本质上是对类（Class对象）的同步**，test、test2都是属于类的实例对象，所以也会同步执行，不能并发执行。  \n**注：每个类只有一个Class对象。**  \n（4）synchronized修饰同步块\n\n```\npublic class SynTest {\n\t\n\tpublic  void  method1(){\n\t\tsynchronized(this){\n\t\tSystem.out.println(\"method 1 start\");\n\t\ttry {\n\t\t\tSystem.out.println(\"method 1 execute\");\n\t\t\tThread.sleep(2000);\n\t\t} catch (InterruptedException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tSystem.out.println(\"method 1 end\");}\n\t}\n\tpublic void method2(){\n\t\tsynchronized(this){\n\t\tSystem.out.println(\"method 2 start\");\n\t\t\n\t\ttry {\n\t\t\tSystem.out.println(\"method 2 execute\");\n\t\t\tThread.sleep(1000);\n\t\t} catch (InterruptedException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tSystem.out.println(\"method 2 end\");}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tSynTest test = new SynTest();\n\t\t//线程1---method1\n\t\tnew Thread(new Runnable() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\ttest.method1();\n\t\t\t}\n\t\t}).start();\n\t\t//线程2---method2\n\t\tnew Thread(new Runnable() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\ttest.method2();\n\t\t\t}\n\t\t}).start();\n\t}\n}\n```\n\n```\nmethod 1 start\nmethod 1 execute\nmethod 1 end\nmethod 2 start\nmethod 2 execute\nmethod 2 end\n\n```\n可以看到，两个线程获得了同步的效果。**两个线程的锁都是synchronized同步块括号中的this对象，即当前对象（test）**。\n\n## 二、synchronized的实现原理\n### 2.1 实现原理  \n**JVM基于进入和退出Monitor对象来实现方法同步和代码块同步。** 但两者的实现细节不一样。\n#### 1. 代码块同步  \n**代码块同步是使用monitorenter和monitorexit指令（字节码指令）来完成。**   \nmonitorenter指令是在编译后插入到同步代码块的开始位置，monitorexit指令插入到方法结束处和异常处，JVM保证每一个monitorenter都有一个monitorexit与之相对应。任何对象都有一个monitor与之相关联，当且一个monitor被持有之后，它将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor所有权，即尝试获取对象的锁； \n#### 2. 方法同步  \n**方法同步是根据方法上的ACC_SYNCHRONIZED标识符（不是字节码指令）来实现的。** 它没有通过指令monitorenter和monitorexit来完成（也可以通过它完成）。  \n反编译可以发现，相比普通方法，常量池中多了ACC_SYNCHRONIZED标示符。JVM就是根据该标示符来实现方法的同步的：当方法调用时，调用指令将会检查方法的ACC_SYNCHRONIZED访问标志是否被设置，如果设置了，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完后再释放monitor。在方法执行期间，其他任何线程都无法再获得同一个monitor对象。\n\n**总结：** 二者其实本质上没有区别，只是方法的同步是一种隐式的方式来实现，无需通过字节码指令来完成。\n### 2.2 对象头\nsynchronized用的锁是存在java对象头里的。\n要了解对象头，先看看对象在内存中（**java堆**）的分布。分为三部分：对象头，实例数据，和对齐填充。（如下图）  \n![image](http://osuskkx7k.bkt.clouddn.com/%E5%AF%B9%E8%B1%A1%E5%A4%B421.PNG?imageView2/2/w/500/h/600)\n\n从图上可以看到，对象头由2个字存储（若是数组对象则为3个字，多一个存储数组长度）。  \n对象头主要包括以下两部分数据（还有一个Fields）：  \n![image](http://osuskkx7k.bkt.clouddn.com/%E5%AF%B9%E8%B1%A1%E5%A4%B422.PNG?imageView2/2/w/400/h/500)  \n**Mark Word（标记字段）：** 用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等等。  \n**Klass Pointer（类型指针）：** 指向对象的类元数据，虚拟机通过这个指针来确定这个对象是哪个类的实例。  \n当对象头处于无锁状态时，它的Mark Word存储结构如下：\n\n锁状态| 25bit| 4bit| 1bit是否是偏向锁| 2bit锁标志位\n--------|-------|---|---|-------\n&#160;无锁状态|对象的hashCode|对象分代年龄|&#160;&#160;&#160;&#160;&#160;&#160;&#160;0|&#160;&#160;&#160;01\n\n**注：在运行期间，Mark Word里的存储数据会随着锁标志位的变化而变化。**\n\n\n## 三、锁的优化和对比\njdk1.6之后对synchronized的实现进行了优化，来减少锁操作的开销。  \n因此锁出现了以下四种状态 **：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态。**  \n它们并不是一成不变的状态，而是会通过互相竞争而升级，但是为了提高获得锁和释放锁的效率，它们只能升级不能降级。  升级顺序如下：  \n无锁 --> 偏向锁 --> 轻量级 --> 重量级\n### 3.1 偏向锁\n背景：大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让获取锁的代价降低而引入了偏向锁。**偏向锁主要为了解决在没有竞争情况下锁的性能问题。**\n#### 1. 偏向锁的加锁  \n主要步骤如下：  \n（1）检测对象头Mark Word中的状态是否为偏向锁状态：  \n若是偏向锁状态（偏向锁标志为1，锁标志位01）执行步骤（2）；  \n若是无锁状态（偏向锁标志关闭，锁标志位01），那么线程在执行同步块之前，JVM会现在当前线程的栈帧中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，并存储锁偏向的线程ID（当前线程）；  \n（2）是偏向锁状态，则测试线程ID是否为当前线程ID，如果是则执行步骤（5），否则执行步骤（3）；  \n（3）线程ID不为当前线程ID，则通过CAS操作竞争锁，竞争成功，则将Mark Word的线程ID替换为当前线程ID，否则执行步骤（4）；   \n（4）通过CAS操作竞争锁失败，证明当前存在多线程竞争的情况，当到达全局安全点，获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码块；  \n（5）执行同步代码块\n\n\n#### 2. 偏向锁的解锁  \n偏向锁的释放采用了一种只有竞争才会释放锁的机制，线程是不会主动去释放偏向锁，需要等待其他线程来竞争。偏向锁的撤销需要等待全局安全点，此时没有正在执行的字节码。步骤如下：  \n（1）首先暂停持有偏向锁的线程，然后检查该线程是否活着：\n没有活着：将对象头设置成无锁状态；  \n（2）活着：要么重新偏向于其他线程；要么恢复到无锁或升级为轻量锁；  \n（3）最后唤醒暂停的线程\n\n#### 3. 偏向锁的关闭    \n偏向锁默认开启，JVM参数关闭延迟：-XX：BiasedLockingStartupDelay=0。  \n如果确定应用程序里所有的锁通常都处于竞争状态下，通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，那么程序会默认进入轻量级锁状态。\n\n\n### 3.2 轻量级锁\n背景：**“对于绝大部分的锁，在整个同步周期内都是不存在竞争的”**，这是一个经验数据，也是轻量级锁能提升程序同步性能的依据。**轻量级锁所适应的场景是线程交替执行同步块的情况。**\n\n\n#### 1. 轻量级锁的加锁  \n当关闭偏向锁功能或偏向锁升级为轻量级锁时，会尝试去获取轻量级锁。主要步骤如下：  \n（1）检测对象头Mark Word中的状态是否为无锁状态：若是无锁状态（偏向锁标志关闭，锁标志位01）执行步骤（2）；否则步骤（4）  \n（2）若是无锁状态，将对象头中的Mark Word复制到锁记录中（在执行同步块之前，JVM会先在当前线程的栈帧中创建用于存储锁记录的空间）；  \n（3）通过CAS将Mark Word替换为指向锁记录的指针：如果成功表示竞争到锁，执行同步代码；如果失败执行步骤（4）；  \n（4）判断当前对象的Mark Word是否指向当前线程的栈帧，如果是则表示当前线程已经持有当前对象的锁，则直接执行同步代码块；否则只能说明该锁对象已经被其他线程抢占了，这时轻量级锁需要膨胀为重量级锁，锁标志位变成10，后面等待的线程将会进入阻塞状态；\n\n#### 2. 轻量级锁的解锁  \n轻量级锁的释放也是通过CAS操作来进行的，主要步骤如下： \n\n（1）取出获取轻量级锁时保存在Displaced Mark Word中的数据；  \n（2）用CAS操作将取出的数据替换当前对象的Mark\nWord中，如果成功，则说明释放锁成功，否则执行（3）；  \n（3） 如果CAS操作替换失败，说明有其他线程尝试获取该锁，存在锁竞争，锁会膨胀成重量级锁。\n### 3.3 重量级锁\n**重量级锁通过对象内部的监视器（monitor）实现，其中monitor的本质是依赖于底层操作系统的Mutex Lock实现**，由于使用Mutex Lock需要将当前线程挂起并从用户态切换到内核态来执行，这种切换的代价非常昂贵。\n\n\n### 3.4 锁的对比\n\n锁 | 优点 | 缺点 | 适用场景\n---|----|-|-\n偏向锁 | 加锁和解锁不需要额外的消耗,和执行非同步方法相比仅存在纳米级的差距|如果线程间存在锁竞争，有额外的锁撤销的消耗 | 适用于只有一个线程访问同步块的场景\n轻量级锁 |竞争的线程不会阻塞，提高了程序的响应速度|如果始终得不到锁竞争的线程，使用自旋会消耗CPU | 追求响应时间，同步块执行速度非常快\n重量级锁 | 线程竞争不使用自旋，不会消耗CPU|线程阻塞，响应时间缓慢 | 追求吞吐量，同步块执行速度较长\n\n\n","tags":["synchronized"],"categories":["技术"]},{"title":"深入理解volatile关键字","url":"/2017/10/12/深入理解volatile关键字(1)/","content":"## 一、volatile的特性\n###   1. volatile的可见性\n 可见性的意思是：当一个线程修改一个共享变量时，另一个线程能读到这个修改的值。  \n volatile在多线程的开发中，保证了共享变量的可见性（立即）。\n```\n//全局变量\nboolean open=true;\n\n//线程A\nresource.close();\nopen = false;\n\n//线程B\nwhile(open) {\ndoSomething(resource);\n}\n```\nopen是一个全局变量，用来描述一个资源的打开关闭状态，当线程A把资源关闭后，open置为false，而这个改动对线程B**不是立即可见**的，因此线程B还会运行，从而造成错误。  \n当添加volatile关键字修饰之后，线程B就可以**立即**将改动后的open变量（主内存）同步到自己的工作内存中，从而正确的停止运行。\n\n\n###  2. volatile的有序性（禁止指令重排序）\n \n\n```\n//线程A\ncontext = loadContext();//初始化\ninit = true;\n//线程B\nwhile(!init){ //根据init变量决定是否使用context（为false时等待，为true时顺序执行）\n   sleep(100);\n}\ndoSomething(context);\n\n```\n以上程序运行没有问题，然而当线程A中发生了指令重排序：\n```\ninit = true;\ncontext = loadContext();\n```\n那么B就可能跳过等待，拿到一个正在初始化或初始化未完成的context对象，从而发生程序错误。  \n当init变量用volatile修饰后，就会阻止JVM对其相关代码进行指令重排，这样就能够按照既定的顺序执行。  \n 在双重判断类型的单例模式中正是应用了volatile关键字的这个特性，才不会导致单例模式失效。\n \n###  3. volatile不保证操作的原子性\n原子操作：不可中断的一个或一系列操作（多线程中借助于原子操作可以实现互斥锁）  \n原子性：一个操作或多个操作要么全部成功执行，要么就都失败。一个操作是原子操作，那么我们称它具有原子性。  \n先看示例代码\n```\npublic class TestAtomic {\n//计数器\nprivate static volatile int count=0;\n\t\n\tpublic void inc(){\n\t\tcount++;\n\t}\n\tprivate static class Countone implements  Runnable {\n\t\tpublic void run() {\n\t\t\tfor(int i=0;i<100;i++){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\t\n\t\tfor(int i=0;i<10;i++){\n\t\t\tnew Thread(new Countone()).start();\n\t\t}\n\t\t//保证10个线程都执行完毕\n\t\twhile(Thread.activeCount()>1)\n\t\t\tThread.yield();\n\t\t\n\t\tSystem.out.println(\"最终count的值为：\"+TestAtomic.count);\n\t}\n}\n```\n```\n输出结果：\n最终count的值为：863\n最终count的值为：1000\n最终count的值为：872\n最终count的值为：835\n```\n将count变量声明为volatile int类型，保证了所有线程对变量count的可见性，上述定义了10个线程，每个线程对count执行100次自增的操作，按照理想的结果，最后的结果应该为10*100=1000，然而多次运行可以看到，并不是每次的结果都是1000，难道volatile修饰的变量的可见性特征失效了？**并不是，而是volatile只能保证共享变量对所有线程的可见性，不能保证变量操作的原子性。** count++不是一个原子操作，因此volatile不能保证这个操作的原子性。\n\n**有以下三种方式可以保证对变量操作的原子性：**\n\n 1. 使用synchronized关键字\n 2. 使用Lock对象\n 3. 使用java.util.concurrent.atomic包下提供的原子操作类\n\n## 二、volatile的实现原理\n### 1.可见性\n它的实现原理与java内存模型（JMM）相关，每个线程都有自己的工作内存，并共享主内存的数据。下面是普通变量与volatile变量的异同：\n\n - 普通变量：读操作会优先读取工作内存的数据，如果工作内存中不存在，则从主内存中拷贝一份数据到工作内存中；写操作只会修改工作内存的副本数据。这种情况下，其它线程就无法读取变量的最新值。\n \n - volatile变量：读操作时会把工作内存中对应的值设为无效，要求线程从主内存中读取数据；写操作时会把工作内存中对应的数据刷新到主内存中。这种情况下，其它线程就可以读取变量的最新值。\n\n那么它是如何是实现的呢？这就涉及到了CPU指令。  \n如果对声明了volatile变量进行写操作，**JVM就会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写回到系统内存。** 但是就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题，所以在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作的时候，会强制重新从系统内存里把数据读到处理器缓存里。\n### 2.禁止重排序\n在执行程序时为了提高性能，编译器和处理器通常会对指令做重排序： \n\n - 编译器重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序； \n - 处理器重排序。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序； \n指令重排序对单线程没有影响，但是会影响多线程的正确性，因此需要对禁止指令重排序。\n\n在上面提到过lock指令，**lock指令其实就相当于一个内存屏障。内存屏障是一组处理指令，用来实现对内存操作的顺序限制。** volatile的底层就是通过内存屏障来实现的。\n\n## 三、volatile与synchronized的比较\n\n 1. volatile本质是在告诉JVM当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞。 \n \n 2. volatile只能修饰变量，synchronized可以修饰变量、方法和类；  \n \n 3. volatile保证变量的修改可见性，synchronized则可以保证变量的修改可见性和原子性。  \n 4. volatile不会造成线程的阻塞，synchronized可能会造成线程的阻塞。  \n 5. volatile比synchronized的使用和执行成本更低，因为它不会引起上下文的切换和调度。\n\n## 四、volatile的扩展\n\n### 1.volatile的常用场景\n\n - 状态标记量（高并发的场景）\n\n - 双重判断的单例模式\n\n### 2.volatile修饰数组\n\n**问题：volatile能否保证数组中元素的可见性？** 如果用volatile修饰一个数组，那么当一个线程对数组中的元素进行设值时，对另一个线程是否**立即**可见？ \n\n**答案：** 不能立即可见。因为volatile修饰的数组只针对数组的引用具有volatile的语义，而不是它的元素。\n","tags":["volatile"],"categories":["技术"]},{"title":"Hello World","url":"/2017/10/10/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n"},{"title":"Mysql中查询某个数据库中所有表的字段信息","url":"/2017/08/09/Mysql中查询某个数据库中所有表的字段信息/","content":"## 前言 ##\n有时候，需要在数据库中查询一些字段的具体信息，而这些字段又存在于不同的表中，那么我们如何来查询呢？\n\n在每一个数据库链接的information_schema数据库中，存在这样一张表——COLUMNS，它记录了这个数据库中所有表的字段信息。\n## 查询某个特定类型的字段信息##\n如下：查询字段类型为decimal的字段信息\nSql语句：\n\n```\nSELECT\n\tTABLE_NAME,\n\tcolumn_name,\n\tDATA_TYPE,\n\tcolumn_comment\nFROM\n\tinformation_schema. COLUMNS\nWHERE\n\tTABLE_SCHEMA = 'evshare'\nAND DATA_TYPE = 'decimal';\n```\n\n其中\n\n - TABLE_SCHEMA 为数据库的名称（所属的数据库）\n - TABLE_NAME 为表的名称\n - DATA_TYPE 为字段的数据类型\n - column_name  为字段名\n - column_comment 为字段注释\n在Where的条件语句中，可以加入限制条件。\n结果如下：\n\n![1](http://osuskkx7k.bkt.clouddn.com/clipboard1.png) \n\n## 查询注释乱码的字段信息##\n\n如果需要查询数据库中所有乱码的字段信息，那么可以对以上的Sql稍稍改进：\n\n```\nSELECT\n\tTABLE_NAME,\n\tcolumn_name,\n\tDATA_TYPE,\n\tcolumn_comment\nFROM\n\tinformation_schema. COLUMNS\nWHERE\n\tTABLE_SCHEMA = 'evshare'\nAND column_comment LIKE '%?%';\n```\n\n结果如下：可以看到这个evshare数据库中，所有表的乱码字段都已显示\n\n![1](http://osuskkx7k.bkt.clouddn.com/clipboard3.png) \n\n## 总结 ##\n\n<font size=\"4\">以上，就是在Mysql中如何查询某个数据库中所有表的字段信息的过程。","tags":["数据库"],"categories":["技术"]},{"title":"在Hexo发布博客的MarkDown文件中引入JS代码","url":"/2017/08/07/Hexo发布博客的MarkDown文件中引入JS代码/","content":"## 前言 ##\n上周困扰了两天的问题终于得到解决，于是就打算写点东西，也当作一次记录。\n\n从题目可以看出，问题就是——**如何在Hexo发布博客的Md文件中引入JS代码**，来实现你想要的特效。\n之所以会提出这个问题，是源于一个简单的想法，单纯地想在某一篇博客中引入echarts（一个纯 Javascript 的图表库）特效，实质上就是引入它的JS代码。\n\n那么就详细讲解一下引入echarts来实现特效的过程。\n## 下载##\n首先，在[echarts下载页面](http://echarts.baidu.com/download.html) 中下载相应的版本，我这里下载的是完整版（echarts.min.js）。\n文件下载完成后，将其放入下图所示文件夹当中\n![WithYou](http://osuskkx7k.bkt.clouddn.com/js%E5%AD%98%E5%82%A8.PNG)\n\n我的博客使用的是next主题，打开themes文件夹中的next文件夹，再依次打开source、js、src文件夹，就可以看到许多js文件，将echarts.min.js放入即可。\n## 使用##\n在文件引入后（src就是指向刚刚存入js文件的目录），那么你就可以在你的博客中引用这个js文件来达到特定的效果。\n引用的方式很简单，只需一行代码：\n\n`<script type=\"text/javascript\" src=\"/js/src/echarts.min.js\"></script>`\n\n在引用js文件后，那么你只要在md文件中添加相应的js代码片段即可，这里贴出我使用的js代码片段\n\n```\n<script>\nvar bmapChart=echarts.init(document.getElementById(\"map-wrap\"));var data=[{name:\"上海\",value:299},{name:\"厦门\",value:245},{name:\"丰城\",value:120},{name:\"南昌\",value:160},{name:\"张家界\",value:128},{name:\"长沙\",value:75},{name:\"杭州\",value:90},{name:\"福州\",value:90},{name:\"深圳\",value:90},{name:\"武汉\",value:73}];var geoCoordMap={\"厦门\":[118.105,24.443],\"上海\":[121.399,31.321],\"丰城\":[115.801,28.201],\"南昌\":[115.856,28.691],\"张家界\":[110.489,29.118],\"福州\":[119.3,26.08],\"长沙\":[113,28.21],\"杭州\":[120.16,30.28],\"深圳\":[114.06,22.55],\"武汉\":[114.31,30.52]};var convertData=function(data){var res=[];for(var i=0;i<data.length;i++){var geoCoord=geoCoordMap[data[i].name];if(geoCoord){res.push({name:data[i].name,value:geoCoord.concat(data[i].value)})}}return res};option={title:{text:\"我们的足迹 - Our footprints\",subtext:\"一步一个脚印，让时光见证\",sublink:\"#\",left:\"center\"},tooltip:{trigger:\"item\"},bmap:{center:[106.320439,32.58783],zoom:5,roam:true,mapStyle:{styleJson:[{\"featureType\":\"water\",\"elementType\":\"all\",\"stylers\":{\"color\":\"#d1d1d1\"}},{\"featureType\":\"land\",\"elementType\":\"all\",\"stylers\":{\"color\":\"#f3f3f3\"}},{\"featureType\":\"railway\",\"elementType\":\"all\",\"stylers\":{\"visibility\":\"off\"}},{\"featureType\":\"highway\",\"elementType\":\"all\",\"stylers\":{\"color\":\"#fdfdfd\"}},{\"featureType\":\"highway\",\"elementType\":\"labels\",\"stylers\":{\"visibility\":\"off\"}},{\"featureType\":\"arterial\",\"elementType\":\"geometry\",\"stylers\":{\"color\":\"#fefefe\"}},{\"featureType\":\"arterial\",\"elementType\":\"geometry.fill\",\"stylers\":{\"color\":\"#fefefe\"}},{\"featureType\":\"poi\",\"elementType\":\"all\",\"stylers\":{\"visibility\":\"off\"}},{\"featureType\":\"green\",\"elementType\":\"all\",\"stylers\":{\"visibility\":\"off\"}},{\"featureType\":\"subway\",\"elementType\":\"all\",\"stylers\":{\"visibility\":\"off\"}},{\"featureType\":\"manmade\",\"elementType\":\"all\",\"stylers\":{\"color\":\"#d1d1d1\"}},{\"featureType\":\"local\",\"elementType\":\"all\",\"stylers\":{\"color\":\"#d1d1d1\"}},{\"featureType\":\"arterial\",\"elementType\":\"labels\",\"stylers\":{\"visibility\":\"off\"}},{\"featureType\":\"boundary\",\"elementType\":\"all\",\"stylers\":{\"color\":\"#fefefe\"}},{\"featureType\":\"building\",\"elementType\":\"all\",\"stylers\":{\"color\":\"#d1d1d1\"}},{\"featureType\":\"label\",\"elementType\":\"labels.text.fill\",\"stylers\":{\"color\":\"#999999\"}}]}},series:[{name:\"footmark\",type:\"scatter\",coordinateSystem:\"bmap\",data:convertData(data),symbolSize:function(val){return val[2]/10},label:{normal:{formatter:\"{b}\",position:\"right\",show:false},emphasis:{show:true}},itemStyle:{normal:{color:\"#60C0DD\"}}},{name:\"I miss you\",type:\"effectScatter\",coordinateSystem:\"bmap\",data:convertData(data.sort(function(a,b){return b.value-a.value}).slice(0,2)),symbolSize:function(val){return val[2]/10},showEffectOn:\"render\",rippleEffect:{brushType:\"stroke\"},hoverAnimation:true,label:{normal:{formatter:\"{b}\",position:\"right\",show:true}},itemStyle:{normal:{color:\"purple\",shadowBlur:10,shadowColor:\"#333\"}},zlevel:1}]};bmapChart.setOption(option);\n</script>\n```\n 文章末尾有博客链接。\n 在这个页面中所展现的特效中还引入了其他的js文件，如china.js、api.js、bmap.js等，例如api.js是百度地图的js代码，当然你可以引入任何你想要引用的js文件。  \n## 详细##\n至于bmap.js文件可以在[github](https://github.com/ecomfe/echarts/tree/master/extension/bmap)下载，下载之后打开echarts-master文件夹，找到extension中的bamp.js,如下图所示:\n![WithYou](http://osuskkx7k.bkt.clouddn.com/1.PNG)\n\n\nECharts使用参考（其中有china.js的介绍）：\n\n- [ECharts 实现地图散点图（上）](http://efe.baidu.com/blog/echarts-map-tutorial/)\n- [ECharts 实现地图散点图（下）](http://efe.baidu.com/blog/echarts-map-tutorial-2/)\n\n这里要注意一个问题，就是引入bmap.js后，地图并不显示，想要使用百度地图，还要去[百度地图开放平台](http://lbsyun.baidu.com/index.php?title=jspopular)申请一个密钥，申请成功后在页面中引入，但是经过多次尝试，直接在md文件中引入并不起作用，如下：\n\n` <script src=\"http://api.map.baidu.com/api?v=2.0&ak=？（你的密钥）\"></script>`\n\n   由此想到在script标签中嵌入了网页链接，md可能不能识别（只是猜测），于是想着将这个链接所指向的js转为文件引入试试。直接点击链接，跳转到如下页面：\n   \n![WithYou](http://osuskkx7k.bkt.clouddn.com/%E7%99%BE%E5%BA%A61.PNG)\n\n可以看到标记处同样为一个链接，再次从浏览器打开，出现如下：  \n\n![WithYou](http://osuskkx7k.bkt.clouddn.com/%E7%99%BE%E5%BA%A62.PNG)\n\n在你眼前呈现的是全屏的js代码，这就是我们所需要的js文件，即百度地图的js代码，将它全选保存为js文件，这里命名为api.js。\n然后在md中引入它即可使用，这样我们就能取得和百度地图类似的效果。\n\n下面贴出完整的文章代码，即md文件：\n```\n<div id=\"map-wrap\" style=\"height: 500px;width:800px;\"></div>\n\n    <script type=\"text/javascript\" src=\"/js/src/echarts.min.js\"></script>\n    <script src=\"/js/src/china.js\"></script>\n    <script src=\"/js/src/api.js\"></script>\n    <script src=\"/js/src/bmap.js\"></script>\n    \n<script>\nvar bmapChart=echarts.init(document.getElementById(\"map-wrap\"));var data=[{name:\"上海\",value:299},{name:\"厦门\",value:245},{name:\"丰城\",value:120},{name:\"南昌\",value:160},{name:\"张家界\",value:128},{name:\"长沙\",value:75},{name:\"杭州\",value:90},{name:\"福州\",value:90},{name:\"深圳\",value:90},{name:\"武汉\",value:73}];var geoCoordMap={\"厦门\":[118.105,24.443],\"上海\":[121.399,31.321],\"丰城\":[115.801,28.201],\"南昌\":[115.856,28.691],\"张家界\":[110.489,29.118],\"福州\":[119.3,26.08],\"长沙\":[113,28.21],\"杭州\":[120.16,30.28],\"深圳\":[114.06,22.55],\"武汉\":[114.31,30.52]};var convertData=function(data){var res=[];for(var i=0;i<data.length;i++){var geoCoord=geoCoordMap[data[i].name];if(geoCoord){res.push({name:data[i].name,value:geoCoord.concat(data[i].value)})}}return res};option={title:{text:\"我们的足迹 - Our footprints\",subtext:\"一步一个脚印，让时光见证\",sublink:\"#\",left:\"center\"},tooltip:{trigger:\"item\"},bmap:{center:[106.320439,32.58783],zoom:5,roam:true,mapStyle:{styleJson:[{\"featureType\":\"water\",\"elementType\":\"all\",\"stylers\":{\"color\":\"#d1d1d1\"}},{\"featureType\":\"land\",\"elementType\":\"all\",\"stylers\":{\"color\":\"#f3f3f3\"}},{\"featureType\":\"railway\",\"elementType\":\"all\",\"stylers\":{\"visibility\":\"off\"}},{\"featureType\":\"highway\",\"elementType\":\"all\",\"stylers\":{\"color\":\"#fdfdfd\"}},{\"featureType\":\"highway\",\"elementType\":\"labels\",\"stylers\":{\"visibility\":\"off\"}},{\"featureType\":\"arterial\",\"elementType\":\"geometry\",\"stylers\":{\"color\":\"#fefefe\"}},{\"featureType\":\"arterial\",\"elementType\":\"geometry.fill\",\"stylers\":{\"color\":\"#fefefe\"}},{\"featureType\":\"poi\",\"elementType\":\"all\",\"stylers\":{\"visibility\":\"off\"}},{\"featureType\":\"green\",\"elementType\":\"all\",\"stylers\":{\"visibility\":\"off\"}},{\"featureType\":\"subway\",\"elementType\":\"all\",\"stylers\":{\"visibility\":\"off\"}},{\"featureType\":\"manmade\",\"elementType\":\"all\",\"stylers\":{\"color\":\"#d1d1d1\"}},{\"featureType\":\"local\",\"elementType\":\"all\",\"stylers\":{\"color\":\"#d1d1d1\"}},{\"featureType\":\"arterial\",\"elementType\":\"labels\",\"stylers\":{\"visibility\":\"off\"}},{\"featureType\":\"boundary\",\"elementType\":\"all\",\"stylers\":{\"color\":\"#fefefe\"}},{\"featureType\":\"building\",\"elementType\":\"all\",\"stylers\":{\"color\":\"#d1d1d1\"}},{\"featureType\":\"label\",\"elementType\":\"labels.text.fill\",\"stylers\":{\"color\":\"#999999\"}}]}},series:[{name:\"footmark\",type:\"scatter\",coordinateSystem:\"bmap\",data:convertData(data),symbolSize:function(val){return val[2]/10},label:{normal:{formatter:\"{b}\",position:\"right\",show:false},emphasis:{show:true}},itemStyle:{normal:{color:\"#60C0DD\"}}},{name:\"I miss you\",type:\"effectScatter\",coordinateSystem:\"bmap\",data:convertData(data.sort(function(a,b){return b.value-a.value}).slice(0,2)),symbolSize:function(val){return val[2]/10},showEffectOn:\"render\",rippleEffect:{brushType:\"stroke\"},hoverAnimation:true,label:{normal:{formatter:\"{b}\",position:\"right\",show:true}},itemStyle:{normal:{color:\"purple\",shadowBlur:10,shadowColor:\"#333\"}},zlevel:1}]};bmapChart.setOption(option);\n    </script>\n```\n特效如下图所示：\n\n![WithYou](http://osuskkx7k.bkt.clouddn.com/%E7%89%B9%E6%95%882.PNG)\n\n欢迎访问博客页面查看效果：[Youngforzy](https://youngforzy.github.io/2017/08/07/index/#more)\n## 问题##\n<font size=\"4\">这里其实有个问题，就是特效虽然展现出来，但是在网页端还是无法实现地图的缩放，而在手机端和ipad中都可以进行地图的缩放，目前这个问题还未能得到解决，待日后解决再补充。</font>\n## 总结##\n以上就是在MarkDown中插入js代码的过程。","tags":["MarkDown"],"categories":["技术"]},{"title":"JS特效","url":"/2017/08/07/JS特效/","content":"\n<div id=\"map-wrap\" style=\"height: 500px;width:800px;\"></div>\n\n<script type=\"text/javascript\" src=\"/js/src/echarts.min.js\"></script>\n<script src=\"/js/src/china.js\"></script>\n<script src=\"/js/src/api.js\"></script>\n<script src=\"/js/src/bmap.js\"></script>\n\n<script>\nvar bmapChart=echarts.init(document.getElementById(\"map-wrap\"));var data=[{name:\"上海\",value:299},{name:\"厦门\",value:245},{name:\"丰城\",value:120},{name:\"南昌\",value:160},{name:\"张家界\",value:128},{name:\"长沙\",value:75},{name:\"杭州\",value:90},{name:\"福州\",value:90},{name:\"深圳\",value:90},{name:\"武汉\",value:73}];var geoCoordMap={\"厦门\":[118.105,24.443],\"上海\":[121.399,31.321],\"丰城\":[115.801,28.201],\"南昌\":[115.856,28.691],\"张家界\":[110.489,29.118],\"福州\":[119.3,26.08],\"长沙\":[113,28.21],\"杭州\":[120.16,30.28],\"深圳\":[114.06,22.55],\"武汉\":[114.31,30.52]};var convertData=function(data){var res=[];for(var i=0;i<data.length;i++){var geoCoord=geoCoordMap[data[i].name];if(geoCoord){res.push({name:data[i].name,value:geoCoord.concat(data[i].value)})}}return res};option={title:{text:\"我们的足迹 - Our footprints\",subtext:\"一步一个脚印，让时光见证\",sublink:\"#\",left:\"center\"},tooltip:{trigger:\"item\"},bmap:{center:[106.320439,32.58783],zoom:5,roam:true,mapStyle:{styleJson:[{\"featureType\":\"water\",\"elementType\":\"all\",\"stylers\":{\"color\":\"#d1d1d1\"}},{\"featureType\":\"land\",\"elementType\":\"all\",\"stylers\":{\"color\":\"#f3f3f3\"}},{\"featureType\":\"railway\",\"elementType\":\"all\",\"stylers\":{\"visibility\":\"off\"}},{\"featureType\":\"highway\",\"elementType\":\"all\",\"stylers\":{\"color\":\"#fdfdfd\"}},{\"featureType\":\"highway\",\"elementType\":\"labels\",\"stylers\":{\"visibility\":\"off\"}},{\"featureType\":\"arterial\",\"elementType\":\"geometry\",\"stylers\":{\"color\":\"#fefefe\"}},{\"featureType\":\"arterial\",\"elementType\":\"geometry.fill\",\"stylers\":{\"color\":\"#fefefe\"}},{\"featureType\":\"poi\",\"elementType\":\"all\",\"stylers\":{\"visibility\":\"off\"}},{\"featureType\":\"green\",\"elementType\":\"all\",\"stylers\":{\"visibility\":\"off\"}},{\"featureType\":\"subway\",\"elementType\":\"all\",\"stylers\":{\"visibility\":\"off\"}},{\"featureType\":\"manmade\",\"elementType\":\"all\",\"stylers\":{\"color\":\"#d1d1d1\"}},{\"featureType\":\"local\",\"elementType\":\"all\",\"stylers\":{\"color\":\"#d1d1d1\"}},{\"featureType\":\"arterial\",\"elementType\":\"labels\",\"stylers\":{\"visibility\":\"off\"}},{\"featureType\":\"boundary\",\"elementType\":\"all\",\"stylers\":{\"color\":\"#fefefe\"}},{\"featureType\":\"building\",\"elementType\":\"all\",\"stylers\":{\"color\":\"#d1d1d1\"}},{\"featureType\":\"label\",\"elementType\":\"labels.text.fill\",\"stylers\":{\"color\":\"#999999\"}}]}},series:[{name:\"footmark\",type:\"scatter\",coordinateSystem:\"bmap\",data:convertData(data),symbolSize:function(val){return val[2]/10},label:{normal:{formatter:\"{b}\",position:\"right\",show:false},emphasis:{show:true}},itemStyle:{normal:{color:\"#60C0DD\"}}},{name:\"I miss you\",type:\"effectScatter\",coordinateSystem:\"bmap\",data:convertData(data.sort(function(a,b){return b.value-a.value}).slice(0,2)),symbolSize:function(val){return val[2]/10},showEffectOn:\"render\",rippleEffect:{brushType:\"stroke\"},hoverAnimation:true,label:{normal:{formatter:\"{b}\",position:\"right\",show:true}},itemStyle:{normal:{color:\"purple\",shadowBlur:10,shadowColor:\"#333\"}},zlevel:1}]};bmapChart.setOption(option);\n</script>\n","categories":["技术"]},{"title":"使用Redis的管道（Pipeline）进行批量操作","url":"/2017/07/28/Redis—Pipline/","content":"# Redis管道技术简介\n\n----------\n\nReids是一个cs模式的Tcp服务，类似于http的请求。 当客户端发送一个请求时，服务器处理之后会将结果通过响应报文返回给客户端 。  \n\n那么当需要发送多个请求时，难道每次都要等待请求响应，再发送下一个请求吗？\n  \n当然不是，这里就可以采用Redis的管道技术。  \n\n举个例子，如果说jedis是：request response，request response，...；  \n\n&emsp;&emsp;&emsp;&emsp;&emsp;那么pipeline则是：request request... response response的方式。  \n\n下面，就简单测试一下使用管道的效果。\n\n----------\n\n# 单条插入与批量插入\n这里采用逐条和批量的方式往Redis中写入一些数据。  \n先从Mysql中查出需要的数据，这里大概是300条左右，数据量并不大，但是简单做个测试应该没问题。  \n**单条插入—— Jedis：**\n\n        Jedis jedis = jedisPool.getResource();\n\t\tlong start = System.currentTimeMillis();\n\t\tList<VehicleInfo> vehicleInfos  = vehicleInfoMapper.selectByParam(param);\n\t\tfor (VehicleInfo vehicleInfo : vehicleInfos) {\t\t\n\t\t\t//遍历每个vehicleInfo\n\t\t\tTVehicleRealReportMsg real = new TVehicleRealReportMsg();\n\t\t\tMap<String, String> keysmap = new HashMap<String, String>();\n\t\t\tkeysmap.put(\"vehicleStatus\", real.getVehicleStatus() + \"\");\n\t\t\tkeysmap.put(\"chargeStatus\", real.getChargeStatus() + \"\");\n\t\t\tkeysmap.put(\"longitude\", \"9\");\n\t\t\tkeysmap.put(\"latitude\", \"9\");\n\t\t\tList<Long> list1 = new ArrayList<Long>();\n\t\t\tLong l = 1000L;\n\t\t\tLong l2 = 22222L;\n\t\t\tlist1.add(l);\n\t\t\tlist1.add(l2);\n\t\t\treal.setEngineFaultsList(list1);\n\t\t\tkeysmap.put(\"engineFaultsList\", JSON.toJSONString(list1));\n\t\t\t//单条插入\n\t\t\tjedis.hmset(vehicleInfo.getVehicleSeq()+\"\", keysmap);\n\t\t}\t\n\t\tjedis.close();  \t\t\n\t\tlong end = System.currentTimeMillis(); System.out.println(\"耗时：\"+(end-start) +\"ms\");  \n结果：467ms  \n\n![1](http://osuskkx7k.bkt.clouddn.com/%E5%8D%95%E6%9D%A1%E6%8F%92%E5%85%A5.PNG)  \n\n**批量插入—— Pipeline：** \n   \n        Jedis jedis = jedisPool.getResource();\n\t\tPipeline pip = jedis.pipelined();\n\t\tlong start = System.currentTimeMillis();\n\t\tList<VehicleInfo> vehicleInfos  = vehicleInfoMapper.selectByParam(param);\n\t\tfor (VehicleInfo vehicleInfo : vehicleInfos) {\t\t\n\t\t\t//遍历每个vehicleInfo\n\t\t\tTVehicleRealReportMsg real = new TVehicleRealReportMsg();\n\t\t\tMap<String, String> keysmap = new HashMap<String, String>();\n\t\t\tkeysmap.put(\"vehicleStatus\", real.getVehicleStatus() + \"\");\n\t\t\tkeysmap.put(\"chargeStatus\", real.getChargeStatus() + \"\");\n\t\t\tkeysmap.put(\"longitude\", \"9\");\n\t\t\tkeysmap.put(\"latitude\", \"9\");\n\t\t\tList<Long> list1 = new ArrayList<Long>();\n\t\t\tLong l = 1000L;\n\t\t\tLong l2 = 22222L;\n\t\t\tlist1.add(l);\n\t\t\tlist1.add(l2);\n\t\t\treal.setEngineFaultsList(list1);\n\t\t\tkeysmap.put(\"engineFaultsList\", JSON.toJSONString(list1));\n\t\t\t//批量插入\n\t\t\tpip.hmset(vehicleInfo.getVehicleSeq()+\"\", keysmap);\n\t\t}\n\t\tpip.sync();//同步\n\t\tjedis.close();\t\t\n\t\tlong end = System.currentTimeMillis();\n\t\tSystem.out.println(\"耗时：\"+(end-start) +\"ms\");  \n\n\n结果：175ms  \n\n![2](http://osuskkx7k.bkt.clouddn.com/%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5.PNG)  \n  \n可以看到使用管道之后的时间为，相比于单条插入的总时间大大减少，性能更优。\n\n----------\n\n# 单条读取和批量读取\n\n**单条读取—— Jedis：**  \n\n        Jedis jedis = jedisPool.getResource();\n\t\tlong start = System.currentTimeMillis();\n\t\t//1.采用redis单条读取\n\t\tList<VehicleInfo> vehicleInfos = vehicleInfoMapper.selectByParam(param);\n\t\tList<Coordinate> list = new ArrayList<Coordinate>();\n\t\tfor(VehicleInfo key: vehicleInfos){\n\t\t\tString hashkey = key.getVehicleSeq()+\"\";\n\t\t\tif(jedis.exists(hashkey+\"\")){\t\t\t\t\t\t\t\n\t\t\tCoordinate coord = new Coordinate();\n\t\t\tcoord.setVehicleSeq(key.getVehicleSeq());\n\t\t\tcoord.setOrgId(key.getOrgId());\t\n\t\t\tcoord.setVehiclemodelseq(key.getVehiclemodelseq());\t\n\t\t\tcoord.setVin(jedis.hget(hashkey, \"vin\"));\n\t\t\tcoord.setLongitude(Long.valueOf(jedis.hget(hashkey, \"longitude\")));\n\t\t\tcoord.setLatitude(Long.valueOf(jedis.hget(hashkey, \"latitude\"))); \t\t\n\t\t\tlist.add(coord);\n\t\t\t}\n\t\t}\t\n\t\tjedis.close();\n\t\tlong end = System.currentTimeMillis();\n\t\tSystem.out.println(\"耗时：\"+(end-start)+\" ms\");\n\t\treturn list;  \n结果： 第一次为1032ms，之后稳定在800~900ms  \n ![3](http://osuskkx7k.bkt.clouddn.com/%E5%8D%95%E4%BD%93%E8%AF%BB.PNG)  \n\n**批量读取—— Pipeline**： \n\n        Jedis jedis = jedisPool.getResource();\n\t\tPipeline pip = jedis.pipelined();\n\t\tlong start = System.currentTimeMillis();\n        //2.采用redis管道读取\n\t\tList<VehicleInfo> vehicleInfos = vehicleInfoMapper.selectByParam(param);\n\t\tList<Coordinate> list = new ArrayList<Coordinate>();\n\t\tMap<String,Object> map = new HashMap<String, Object>();//map用来暂存属性\n\t\tMap<String,List<Response<String>>> responses  = new HashMap<String, List<Response<String>>>(vehicleInfos.size());\n\t\tfor(VehicleInfo info: vehicleInfos){\n\t\t\tList<Response<String>> resls = new ArrayList<Response<String>>();\n\t\t\tresls.add(pip.hget(info.getVehicleSeq()+\"\",\"longitude\"));\n\t\t\tresls.add(pip.hget(info.getVehicleSeq()+\"\",\"latitude\"));\n\t\t\tresponses.put(info.getVehicleSeq() + \"\", resls);//得到了一辆车所有的实时数据--300辆车\n\t\t\tmap.put(info.getVehicleSeq()+\"orgId\", info.getOrgId());\n\t\t\tmap.put(info.getVehicleSeq()+\"vin\", info.getVin());\n\t\t\tmap.put(info.getVehicleSeq()+\"vehiclemodelseq\", info.getVehiclemodelseq());\n\t\t}\n\t\tpip.sync(); \n\t\tfor(String k:responses.keySet()){\n\t\t\tCoordinate coord = new Coordinate();\n\t\t\tcoord.setLongitude(Long.valueOf(responses.get(k).get(0).get()));//是get，不是toString\n\t\t\tcoord.setLatitude(Long.valueOf(responses.get(k).get(1).get()));\n\t\t\tcoord.setVehicleSeq(Long.valueOf(k));\n\t\t\tcoord.setOrgId((String) map.get(k+\"orgId\"));\n\t\t\tcoord.setVin((String) map.get(k+\"vin\"));\n\t\t\tcoord.setVehiclemodelseq((Long) map.get(k+\"vehiclemodelseq\"));\n\t\t\tlist.add(coord);\n\t\t}\n\t\tjedis.close();\n\t\tlong end = System.currentTimeMillis();\n\t\tSystem.out.println(\"耗时：\"+(end-start)+\" ms\");\n\t\treturn list;  \n结果： 第一次为200ms，之后维持在30ms左右  \n ![4](http://osuskkx7k.bkt.clouddn.com/%E6%89%B9%E9%87%8F%E8%AF%BB.PNG)  \n\n总时间大概是单条读取总时间的1/5甚至更低，可以看出管道大大提升了效率，具有更好的性能。  \n\n<font size=\"3\">注：使用管道所获取的值的类型是Response<String\\>,因此需要转为String，如下代码片段： </font> \n\n    Map<String,List<Response<String>>> responses  = new HashMap<String, List<Response<String>>>  (vehicleInfos.size());  \n\n\t//转String\n    responses.get(k).get(0).get();  \n\n----------\n\n# 总结\n\n\n- <font size=\"3\">这里仅仅测试了300条数据的操作，已经取得了相对明显的效果。  \n- 对于大量数据的操作，使用Redis管道可以大大提升性能和效率。</font>","tags":["批量，缓存"],"categories":["技术"]},{"title":"You","url":"/2017/07/20/our01/","content":"# 概述","tags":["Soul"],"categories":["芭乐"]},{"title":"Thrift——入门Demo（Java）","url":"/2017/07/18/Thrift/","content":"# 概述\n\n\n----------\n\n\nThrift最初由Facebook研发，主要用于各个服务之间的RPC通信。\n\nThrift是一个典型的CS（客户端/服务端）结构，客户端和服务端可以使用不同的语言开发。\n那么它是如何实现使用不同的语言开发呢？\n答案：一种关联客户端和服务端的中间语言。\n\n这种语言就是IDL（Interface Description Language）。将这个IDL作为输入文件，编译器就可以生成代码（支持多种），即RPC客户端和服务器通信的无缝跨编程语言。\n\n# 安装\n\n\n----------\n\n\n下载官方链接：http://thrift.apache.org/download\n将下载好的thrift-0.10.0 .exe文件命名为thrift .exe，放在D盘下的一个Thtift文件夹中，\n为了更方便使用命令，将目录加入到系统Path路径下：\n\n![image](http://osuskkx7k.bkt.clouddn.com/path.png)\n\n在cmd中输入：thrift -version ，查看是否安装配置成功\n\n![image](http://osuskkx7k.bkt.clouddn.com/%E7%89%88%E6%9C%AC1.png)\n\n出现版本号，安装成功。\n\n定义thrift——IDL文件\n---------------\n\n\n----------\n\n\nIDL文件有许多数据类型\n\n- 结构体类型： struct：定义公共的对象，类似于 C 语 言中的结构体定义，在 Java 中是一个 JavaBean\n- 容器类型：  \n&emsp;&emsp;&emsp;&emsp;&emsp; list：对应 Java 的 ArrayList  \n&emsp;&emsp;&emsp;&emsp;&emsp; set：对应 Java 的 HashSet  \n&emsp;&emsp;&emsp;&emsp;&emsp; map：对应 Java 的 HashMap\n- 异常类型： exception：对应 Java 的 Exception\n- 服务类型： service：对应服务的类  \n\n这里仅仅定义一个服务。  \nthrift定义服务相当于Java中创建Interface，创建的service通过代码生成命令生成客户端和服务端的框架代码。  \n定义形式如下（helloworld.thrift，注意后缀！）：\n\n```\nnamespace java com.test\n\nservice HelloWorldService{\n\n    string sayHello(1:string name)\n}\n```\n——namespace 相当于Java中的package。\n\n在 cmd中 输入命令：  thrift -gen java helloworld.thrift\n\n![image](http://osuskkx7k.bkt.clouddn.com/%E5%91%BD%E4%BB%A41.PNG)\n\n可以看到生成了一个名为gen-java的文件夹，其中就是生成的代码，打开后可以看到层级目录下有：\n\n![image](http://osuskkx7k.bkt.clouddn.com/%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90.png)\n\n代码片段：\n```\n/**\n * Autogenerated by Thrift Compiler (0.10.0)\n *\n * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING\n *  @generated\n */\npackage com.test;\n\n@SuppressWarnings({\"cast\", \"rawtypes\", \"serial\", \"unchecked\", \"unused\"})\n@javax.annotation.Generated(value = \"Autogenerated by Thrift Compiler (0.10.0)\", date = \"2017-07-18\")\npublic class HelloWorldService {\n\n  public interface Iface {\n\n    public java.lang.String sayHello(java.lang.String name) throws org.apache.thrift.TException;\n\n  }\n\n```\n\n# 创建项目\n----\n创建一个Maven工程，引入依赖，可在Maven依赖中看到引入的相关Jar包\n\n```\n<dependency>\n      <groupId>org.apache.thrift</groupId>\n      <artifactId>libthrift</artifactId>\n      <version>0.10.0</version>\n</dependency>\n```\n\n# 服务端实现与启动\n--------\n服务端相关操作的步骤如下：\n\n - 实现服务处理接口Impl\n - 创建TProcessor\n - 创建TServerTransport\n - 创建TProtocol\n - 创建TServer\n - 启动Server  \n\n<font size=\"4\">服务端实现</font>\n\n```\npackage com.test;\n\nimport org.apache.thrift.TException;\n\npublic class HelloWorldImpl implements HelloWorldService.Iface{\n\t\n\tpublic HelloWorldImpl(){\t\n\t}\n\t\n\tpublic String sayHello(String name) throws TException {\n\t\t\n\t\treturn \"Hi,\" +name + \" welcome !\";\n\t}\n\n}\n\n```\n<font size=\"4\">服务端启动</font>\n\n```\npackage com.test;\n\nimport org.apache.thrift.TProcessor;\nimport org.apache.thrift.protocol.TBinaryProtocol;\nimport org.apache.thrift.server.TServer;\nimport org.apache.thrift.server.TSimpleServer;\nimport org.apache.thrift.transport.TServerSocket;\n\npublic class HelloServer {\n\t\n\tpublic static final int SERVER_PORT = 8090;\n\t\n\tpublic void startServer(){\t\n\t\tSystem.out.println(\"Server is Runing......\");\n\t\t\n\t\tTProcessor tprocessor = new HelloWorldService.Processor(new HelloWorldImpl());\t\n\t\t//简单的单线程服务模型，一般用于测试\n\t\ttry {\n\t\t\tTServerSocket serverTransport = new TServerSocket(SERVER_PORT);\n\t\t\tTServer.Args tArgs = new TServer.Args(serverTransport);\n\t\t\ttArgs.processor(tprocessor);\n\t\t\ttArgs.protocolFactory(new TBinaryProtocol.Factory());\n\t\t\tTServer server = new TSimpleServer(tArgs);\n\t\t\tserver.serve();\n\t\t\t\n\t\t} catch (Exception e) {\n\t\t\tSystem.out.println(\"Server start error！\");\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tHelloServer server = new HelloServer();\n\t\tserver.startServer();\n\t}\n}\n```\n运行上面的启动类，控制台输出：Server is Runing......\n\n![image](http://osuskkx7k.bkt.clouddn.com/%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8.png)\n\n# 客户端启动\n\n\n----------\n\n\n<font size=\"4\">客户端步骤：</font>\n\n -  创建Transport\n - 创建TProtocol\n - 基于TTransport和TProtocol创建 Client\n - 调用Client的相应方法\n\n<font size=\"4\">客户端启动</font>\n\n```\npackage com.test;\n\nimport org.apache.thrift.protocol.TBinaryProtocol;\nimport org.apache.thrift.protocol.TProtocol;\nimport org.apache.thrift.transport.TSocket;\nimport org.apache.thrift.transport.TTransport;\n\npublic class HelloClient {\n\t\n\tpublic static final String SERVER_IP = \"localhost\";\n\tpublic static final int SERVER_PORT = 8090;\n\tpublic static final int TIMEOUT = 30000;\n\t\n\tpublic void startClient(String userName){\n\t\tTTransport transport = null;\n\t\ttry {\n\t\t\ttransport = new TSocket(SERVER_IP,SERVER_PORT,TIMEOUT);\n\t\t\t//协议要和服务端一致\n\t\t\tTProtocol protocol  = new TBinaryProtocol(transport);\n\t\t\t\n\t\t\tHelloWorldService.Client client = new HelloWorldService.Client(protocol);\n\t\t\ttransport.open();\n\t\t\t\n\t\t\tString result = client.sayHello(userName);\t\t\n\t\t\tSystem.out.println(\"Thrift client result is:\"+result);\n\t\t\t\n\t\t} catch (Exception e) {\n\t\t\tSystem.out.println(\"client is error!\");\n\t\t}finally{\n\t\t\tif(null != transport){\n\t\t\t\ttransport.close();\n\t\t\t}\n\t\t}\t\n\t}\n\tpublic static void main(String[] args) {\n\t\tHelloClient client = new HelloClient();\n\t\tclient.startClient(\"Z Yong\");\n\t}\t\n}\n```\n<font size=\"4\">控制台输出：  Thrift client result is:  Hi,Z Yong welcome !\n</font>\n\n![image](http://osuskkx7k.bkt.clouddn.com/%E8%BE%93%E5%87%BA2.PNG)\n\n\n<font size=\"5\">**客户端成功收到了服务端返回的请求结果，通信完成**。</font>\n\n\n","tags":["RPC"],"categories":["技术"]},{"title":"Mysql批量操作之更新及插入","url":"/2017/07/12/mysql批量更新/","content":"## 前言\n   这个问题困扰了整整一天。\n   当遇到多条记录需要插入或者更新的时候，往往会使用批量操作来提高效率，提高性能。然而在使用过程中确是出现了各种问题，真的是有些坑只有趟过才知道！！\n   好了，话不多说，进入正题。\n   注：数据库Mysql     持久层框架 Mybatis\n\n## 批量更新\n需求如下代码：\t\t\n```\nMap<String,Object> ucmap = new HashMap<String, Object>();\n\t\tucmap.put(\"updateUser\",\"zyong\");\n\t\tucmap.put(\"updateTime\", time);\n\t\tucmap.put(\"list\", updateClist);\n\t\tconnectorInfoMapper.updateBatch(ucmap);\n```\n这里的需求是对设备的信息进行批量更新，利用Map来传参，Map中包含了一个List，这个List包含了需要更新的对象集合，也就是多条记录。\nsql片段如下：\n```\n<update id=\"updateBatch\" parameterType=\"java.util.Map\">\n      <foreach collection=\"list\" item=\"item\" index=\"index\" separator=\";\">\n update connector_info\n    set  \n      Connector_Type = #{item.connectorType,jdbcType=INTEGER},\n      Voltage_Upper_Limits = #{item.voltageUpperLimits,jdbcType=INTEGER},\n      Voltage_Lower_Limits = #{item.voltageLowerLimits,jdbcType=INTEGER},\n      Current = #{item.current,jdbcType=INTEGER},\n      Power = #{item.power,jdbcType=DOUBLE},\n      National_Standard = #{item.nationalStandard,jdbcType=INTEGER},\n      Update_User = #{updateUser,jdbcType=VARCHAR},\n\t  Update_Time = FROM_UNIXTIME(#{updateTime,jdbcType=TIMESTAMP})   \n    where Connector_ID = #{item.connectorId,jdbcType=VARCHAR}\n    </foreach>\n </update>\n```\n   可以看到，这里使用了foreach标签进行迭代，item代表着每一个元素，item.power等代表的就是每个元素的属性，而没有加上item的参数如updateUser、updateTime等则是存放在Map中的参数，从需求代码中能看得更加明显。\n\n当我检查了多遍后，感觉没问题之后，运行。\n控制台的错误让我明白还是太年轻——报错了！！！仔细一看，是Sql语法错误，What？我把sql放入Navicat中美化，又检查了好几遍，这明明没有错啊！\n\n于是开启了百度，各种查：\n - 有的说把separator=\";\"中的分号换成——separator=\"UNION ALL\"，测试，还是报同样的错误。\n - 将几个属于Map的字段删除再测试，依然报错  \n\n查了很多并没有什么实质性的进展，将多条数据改成一条数据进行更新，测试，竟然通过了！——原因很明显：批量操作的原因导致。\n再百度，终于找到了答案：\n并不是Sql的原因，而是数据库设置的原因————Mysql需要打开批量更新的设置。\n<font size=5>在数据库JDBC链接中加入： **&allowMultiQueries=true**</font>\n如下： \njdbc.url=jdbc:mysql://139.224.35.81:3306/evshare?useUnicode=true&characterEncoding=UTF-8&allowMultiQueries=true\n\n<font size=5>在添加了这个“开关”之后，成功批量更新多条数据。</font>\n\n## 批量插入\n\n相比于批量更新，批量插入则没有类似的设置。\n一个简单的示例Sql：\n```\n<insert id=\"insertBatch\" parameterType=\"java.util.Map\">\n  insert into connector_info (Equipment_Seq, Connector_ID, \n      Connector_Type, Voltage_Upper_Limits, \n      Voltage_Lower_Limits, Current, Power, \n      National_Standard,Create_User,Create_Time,Update_Time)\n      values\n      <foreach collection=\"list\" item=\"item\" index=\"index\" separator=\",\">\n     (#{item.equipmentSeq,jdbcType=BIGINT}, #{item.connectorId,jdbcType=VARCHAR}, \n      #{item.connectorType,jdbcType=INTEGER}, #{item.voltageUpperLimits,jdbcType=INTEGER}, \n      #{item.voltageLowerLimits,jdbcType=INTEGER}, #{item.current,jdbcType=INTEGER}, #{item.power,jdbcType=DOUBLE}, \n      #{item.nationalStandard,jdbcType=INTEGER},\n      #{createUser,jdbcType=VARCHAR},\n      FROM_UNIXTIME(#{createTime,jdbcType=TIMESTAMP}),\n      FROM_UNIXTIME(#{updateTime,jdbcType=TIMESTAMP}))\n      </foreach>\n  </insert>\n```\n## 总结： \n 1. 有时候问题并不是出现在代码上，可以往系统环境和配置方面考虑。  \n 2. 对于批量更新Mysql需要设置，而Oracle则不需要设置，但sql可能要变化\n","tags":["Mybatis"],"categories":["技术"]},{"title":"Jersey—— 一个基于Rest风格的Web Service开发框架","url":"/2017/07/10/jersey2/","content":"一、什么是Jersey\n-----------\n\n   Jersey 是一个Java规范（JAX-RS）下的基于Rest风格的Web Service开发框架。\n   \n   说的直白一点，主要应用于移动项目，用来给移动终端和服务端传递数据。\n   \n   Rest则是一种目前主流的软件架构风格，它可以通过一套统一的接口为 Web，iOS和Android提供服务。因为有些平台不需要显式的前端，只需要一套提供服务的接口，于是就有了Rest风格的软件架构。\n\n二、Jersey+Spring+Mybatis搭建一个简单的Web Service\n-----------------------------------------\n\n#### 1、在Eclipse下创建一个Maven工程\n工程目录结构如下图：\n\n![目录](http://img.blog.csdn.net/20170710212939408?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYmFieWxvdmVfQmFMZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n   上图中——com.zy包下存放业务代码\n              ——resources文件夹下存放资源文件\n              ——其它主要有Web.xml和Pom.xml文件\n#### 2、pom.xml\n\n```\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"  \n  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">  \n  <modelVersion>4.0.0</modelVersion>  \n  <groupId>com.zy</groupId>  \n  <artifactId>jersey</artifactId>  \n  <packaging>war</packaging>  \n  <version>0.0.1-SNAPSHOT</version>  \n  <name>jersey Maven Webapp</name>  \n  <url>http://maven.apache.org</url>  \n    \n  <properties>  \n        <!-- 指明使用JDK8 -->  \n        <java-version>1.8</java-version>  \n        <!-- 指明使用utf-8编码 -->  \n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>  \n        <spring3.version>4.2.6.RELEASE</spring3.version>  \n        <jersey.version>2.22.2</jersey.version>  \n    </properties>  \n      \n      \n  <dependencies>  \n    <dependency>  \n      <groupId>junit</groupId>  \n      <artifactId>junit</artifactId>  \n      <version>3.8.1</version>  \n      <scope>test</scope>  \n    </dependency>  \n    <dependency>  \n    <groupId>redis.clients</groupId>  \n    <artifactId>jedis</artifactId>  \n    <version>2.9.0</version>  \n    </dependency>  \n    <!-- Jersey依赖 -->  \n    <dependency>  \n            <groupId>org.glassfish.jersey.containers</groupId>  \n            <artifactId>jersey-container-servlet</artifactId>  \n            <version>${jersey.version}</version>  \n        </dependency>  \n  \n        <dependency>  \n            <groupId>org.springframework</groupId>  \n            <artifactId>spring-web</artifactId>  \n            <version>${spring3.version}</version>  \n            <scope>compile</scope>  \n        </dependency>  \n  \n        <dependency>  \n            <groupId>org.glassfish.jersey.ext</groupId>  \n            <artifactId>jersey-spring3</artifactId>  \n            <version>${jersey.version}</version>  \n        </dependency>  \n  \n        <dependency>  \n            <groupId>org.glassfish.jersey.media</groupId>  \n            <artifactId>jersey-media-json-jackson</artifactId>  \n            <version>${jersey.version}</version>  \n        </dependency>  \n    <!-- 加入mysql驱动依赖包 -->  \n    <dependency>  \n            <groupId>mysql</groupId>  \n            <artifactId>mysql-connector-java</artifactId>  \n            <version>5.1.27</version>  \n    </dependency>  \n      \n    <!-- 引入mybatis -->  \n        <dependency>  \n            <groupId>org.mybatis</groupId>  \n            <artifactId>mybatis-spring</artifactId>  \n            <version>1.1.1</version>  \n        </dependency>  \n        <dependency>  \n            <groupId>org.mybatis</groupId>  \n            <artifactId>mybatis</artifactId>  \n            <version>3.2.8</version>  \n        </dependency>  \n    <!-- 引入数据源 -->  \n        <dependency>  \n            <groupId>com.alibaba</groupId>  \n            <artifactId>druid</artifactId>  \n            <version>1.0.1</version>  \n        </dependency>  \n        <dependency>  \n            <groupId>org.aspectj</groupId>  \n            <artifactId>aspectjweaver</artifactId>  \n            <version>1.7.4</version>  \n        </dependency>  \n        <!-- 加入fastjson依赖包 -->  \n        <dependency>  \n            <groupId>com.alibaba</groupId>  \n            <artifactId>fastjson</artifactId>  \n            <version>1.1.37</version>  \n        </dependency>  \n  \n        <dependency>  \n            <groupId>com.github.pagehelper</groupId>  \n            <artifactId>pagehelper</artifactId>  \n            <version>3.7.6</version>  \n        </dependency>  \n        <dependency>  \n            <groupId>cglib</groupId>  \n            <artifactId>cglib</artifactId>  \n            <version>2.2.2</version>  \n        </dependency>  \n        <dependency>  \n            <groupId>commons-io</groupId>  \n            <artifactId>commons-io</artifactId>  \n            <version>2.4</version>  \n        </dependency>  \n        <dependency>  \n            <groupId>org.glassfish.jersey.ext</groupId>  \n            <artifactId>jersey-bean-validation</artifactId>  \n            <version>2.22.2</version>  \n            <exclusions>  \n                <exclusion>  \n                    <groupId>org.hibernate</groupId>  \n                    <artifactId>hibernate-validator</artifactId>  \n                </exclusion>  \n            </exclusions>  \n        </dependency>  \n        <dependency>  \n            <groupId>commons-beanutils</groupId>  \n            <artifactId>commons-beanutils</artifactId>  \n            <version>1.7.0</version>  \n        </dependency>  \n          \n        <dependency>  \n            <groupId>org.slf4j</groupId>  \n            <artifactId>slf4j-log4j12</artifactId>  \n            <version>1.7.5</version>  \n        </dependency>  \n        <!-- E起充解码包 -->  \n        <dependency>  \n            <groupId>com.extracme.evready</groupId>  \n            <artifactId>decode</artifactId>  \n            <version>1.1.6</version>  \n        </dependency>  \n        <dependency>  \n            <groupId>com.extracme</groupId>  \n            <artifactId>evreadyHelp</artifactId>  \n            <version>0.0.1-SNAPSHOT</version>  \n        </dependency>  \n        <!-- disconf注解插件 -->  \n        <dependency>  \n            <groupId>com.baidu.disconf</groupId>  \n            <artifactId>disconf-client</artifactId>  \n            <version>2.6.36</version>  \n        </dependency>  \n        <dependency>  \n            <groupId>org.apache.httpcomponents</groupId>  \n            <artifactId>httpclient</artifactId>  \n            <version>4.5.2</version>  \n        </dependency>  \n  </dependencies>  \n   \n  <build>  \n    <finalName>jersey</finalName>  \n        <plugins>  \n            <plugin>  \n                <groupId>org.apache.maven.plugins</groupId>  \n                <artifactId>maven-surefire-plugin</artifactId>  \n                <version>2.18.1</version>  \n                <configuration>  \n                    <skipTests>true</skipTests>  \n                </configuration>  \n            </plugin>  \n            <plugin>  \n                <groupId>org.apache.maven.plugins</groupId>  \n                <artifactId>maven-compiler-plugin</artifactId>  \n                <version>2.3.2</version>  \n                <configuration>  \n                    <skipTests>true</skipTests>  \n                    <source>1.8</source>  \n                    <target>1.8</target>  \n                </configuration>  \n            </plugin>  \n        </plugins>  \n  </build>  \n</project>  \n```\n\n以上就是项目所依赖的jar包，其中有一些是项目需要的可以忽略，重点是Jersey和spring以及mybatis的依赖，上面有相关的注释。\n#### 3、web.xml\n```\n<web-app>  \n      \n    <listener>  \n        <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>  \n    </listener>  \n    <listener>  \n        <listener-class>org.springframework.web.context.request.RequestContextListener</listener-class>  \n    </listener>  \n    <context-param>  \n        <param-name>contextConfigLocation</param-name>  \n        <param-value>classpath:spring.xml</param-value>  \n    </context-param>  \n    <servlet>  \n        <servlet-name>jersey</servlet-name>  \n        <servlet-class>org.glassfish.jersey.servlet.ServletContainer</servlet-class>  \n        <init-param>  \n            <param-name>javax.ws.rs.Application</param-name>  \n            <param-value>com.zy.StartApplication</param-value>  \n              \n        </init-param>  \n        <load-on-startup>1</load-on-startup>  \n    </servlet>  \n    <servlet-mapping>  \n        <servlet-name>jersey</servlet-name>  \n        <url-pattern>/*</url-pattern>  \n    </servlet-mapping>  \n</web-app>  \n```\n以上是web.xml的配置。\n——listener定义了Spring框架中的Bean随着Web容器启动而被创建。\n——context-param定义了Spring.xml的位置。\n——servlet定义了org.glassfish.jersey.servlet.ServletContainer，相当于对客户端的请求（/*）进行了拦截，同时还有一个启动参数，它是Application类的实现，需要我们自己定义，利用它来注册资源，实现如下：\n\n```\npublic class StartApplication extends ResourceConfig {  \n  \n    /**  \n     * Register JAX-RS application components.  \n     */  \n    public StartApplication() {  \n        //register(AuthRequestFilter.class);  \n        packages(\"com.zy.resource\");  \n      \n    }  \n}  \n```\n#### 4、spring-mybatis.xml和mybatis-config.xml以及spring.xml\nSpring-mybatis.xml如下：\n\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>  \n<beans xmlns=\"http://www.springframework.org/schema/beans\"  \n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\"  \n    xmlns:c=\"http://www.springframework.org/schema/c\" xmlns:cache=\"http://www.springframework.org/schema/cache\"  \n    xmlns:context=\"http://www.springframework.org/schema/context\"  \n    xmlns:jdbc=\"http://www.springframework.org/schema/jdbc\" xmlns:jee=\"http://www.springframework.org/schema/jee\"  \n    xmlns:lang=\"http://www.springframework.org/schema/lang\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\"  \n    xmlns:p=\"http://www.springframework.org/schema/p\" xmlns:task=\"http://www.springframework.org/schema/task\"  \n    xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:util=\"http://www.springframework.org/schema/util\"  \n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd  \n        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd  \n        http://www.springframework.org/schema/cache http://www.springframework.org/schema/cache/spring-cache.xsd  \n        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd  \n        http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc.xsd  \n        http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee.xsd  \n        http://www.springframework.org/schema/lang http://www.springframework.org/schema/lang/spring-lang.xsd  \n        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd  \n        http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task.xsd  \n        http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd  \n        http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd\">  \n          \n      \n          \n          \n    <!-- 配置测试环境数据源 -->  \n    <bean name=\"test-dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\"  \n        init-method=\"init\" destroy-method=\"close\">  \n        <property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\" />  \n        <property name=\"url\" value=\"jdbc:mysql://localhost:3306/jersey-test?useUnicode=true&characterEncoding=UTF-8\" />  \n        <property name=\"username\" value=\"root\" />  \n        <property name=\"password\" value=\"\" />  \n  \n        <!-- 初始化连接大小 -->  \n        <property name=\"initialSize\" value=\"0\" />  \n        <!-- 连接池最大使用连接数量 -->  \n        <property name=\"maxActive\" value=\"20\" />  \n        <!-- 连接池最小空闲 -->  \n        <property name=\"minIdle\" value=\"0\" />  \n        <!-- 获取连接最大等待时间 -->  \n        <property name=\"maxWait\" value=\"60000\" />  \n  \n        <property name=\"testOnBorrow\" value=\"false\" />  \n        <property name=\"testOnReturn\" value=\"false\" />  \n        <property name=\"testWhileIdle\" value=\"true\" />  \n  \n        <!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 -->  \n        <property name=\"timeBetweenEvictionRunsMillis\" value=\"60000\" />  \n        <!-- 配置一个连接在池中最小生存的时间，单位是毫秒 -->  \n        <property name=\"minEvictableIdleTimeMillis\" value=\"25200000\" />  \n  \n        <!-- 打开removeAbandoned功能 -->  \n        <property name=\"removeAbandoned\" value=\"true\" />  \n        <!-- 1800秒，也就是30分钟 -->  \n        <property name=\"removeAbandonedTimeout\" value=\"1800\" />  \n        <!-- 关闭abanded连接时输出错误日志 -->  \n        <property name=\"logAbandoned\" value=\"true\" />  \n  \n        <!-- 监控数据库 -->  \n        <!-- <property name=\"filters\" value=\"mergeStat\" /> -->  \n        <property name=\"filters\" value=\"stat\" />  \n    </bean>  \n      \n          \n          \n    <!--根据dataSource和configLocation创建一个sqlSessionFactory -->  \n    <bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\">  \n        <property name=\"dataSource\" ref=\"test-dataSource\" />  \n        <property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"></property>  \n    </bean>  \n    <bean id=\"sqlSession\" class=\"org.mybatis.spring.SqlSessionTemplate\"  \n        scope=\"prototype\">  \n        <constructor-arg index=\"0\" ref=\"sqlSessionFactory\" />  \n    </bean>  \n     <!-- 配置事务管理器 -->  \n    <bean name=\"transactionManager\"  \n        class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">  \n        <property name=\"dataSource\" ref=\"test-dataSource\"></property>  \n    </bean>  \n  \n    <!-- 注解方式配置事物 -->  \n     <tx:annotation-driven transaction-manager=\"transactionManager\" />   \n  \n    <bean id=\"sqlSessionCache\" class=\"com.zy.utils.SqlSessionCache\"  \n        init-method=\"initMapper\">  \n        <!-- 扫描的映射mapper.xml的文件路径 -->  \n        <property name=\"packageSearchPath\" value=\"classpath*:com/zy/*/sql/*.xml\"></property>  \n        <property name=\"sqlSessionFactory\" ref=\"sqlSessionFactory\"></property>  \n    </bean>  \n    <bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\">  \n        <property name=\"basePackage\" value=\"com.zy.*.mapper\" />  \n    </bean>  \n      \n    <bean id=\"framelnterceptor\" class=\"com.zy.utils.Framelnterceptor\" />   \n    <aop:aspectj-autoproxy/>     \n</beans>  \n```\nmybatis-config.xml如下：\n\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>  \n<!DOCTYPE configuration PUBLIC    \n    \"-//mybatis.org//DTD Config 3.0//EN\"    \n    \"http://mybatis.org/dtd/mybatis-3-config.dtd\">    \n<configuration>    \n<!--     <properties resource=\"project.properties\" /> -->  \n    <settings>    \n        <setting name=\"cacheEnabled\" value=\"true\" />  \n        <setting name=\"lazyLoadingEnabled\" value=\"true\" />  \n        <setting name=\"multipleResultSetsEnabled\" value=\"true\" />  \n        <setting name=\"useColumnLabel\" value=\"true\" />  \n        <setting name=\"useGeneratedKeys\" value=\"false\" />  \n        <setting name=\"autoMappingBehavior\" value=\"PARTIAL\" />  \n        <setting name=\"defaultExecutorType\" value=\"SIMPLE\" />  \n        <setting name=\"defaultStatementTimeout\" value=\"25\" />  \n        <setting name=\"safeRowBoundsEnabled\" value=\"false\" />  \n        <setting name=\"mapUnderscoreToCamelCase\" value=\"false\" />  \n        <setting name=\"localCacheScope\" value=\"SESSION\" />  \n        <!-- <setting name=\"logImpl\" value=\"STDOUT_LOGGING\" /> -->  \n        <setting name=\"jdbcTypeForNull\" value=\"OTHER\" />  \n        <setting name=\"lazyLoadTriggerMethods\" value=\"equals,clone,hashCode,toString\" />   \n    </settings></configuration> \n```\nSpring.xml的配置如下：\n\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>  \n  \n<beans xmlns=\"http://www.springframework.org/schema/beans\"  \n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"  \n       xmlns:context=\"http://www.springframework.org/schema/context\"  \n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans  \n  http://www.springframework.org/schema/beans/spring-beans.xsd  \n  http://www.springframework.org/schema/context  \n  http://www.springframework.org/schema/context/spring-context.xsd\"  \n        >  \n    <!-- 自动扫描dao和service包(自动注入) -->  \n    <context:component-scan base-package=\"com.zy.*\" />  \n    <import resource=\"classpath:spring-mybatis.xml\" />  \n</beans> \n\n```\n\n注意：在spring-mybatis.xml配置文件的底部配置了一个拦截器——\n`<bean id=\"framelnterceptor\" class=\"com.zy.utils.Framelnterceptor\" />\n`     ——作用是输出请求接口的信息和接口返回的信息，以及获取某些与Token相关的信息。\n\n#### 5、请求过程\n\n```\nResources\npackage com.zy.resource;\n\nimport javax.ws.rs.Consumes;\nimport javax.ws.rs.GET;\nimport javax.ws.rs.Path;\nimport javax.ws.rs.Produces;\nimport javax.ws.rs.core.MediaType;\n\n\n@Path(\"/helloworld\")\npublic class RestHelloWorld {\n\t\n\t@GET\n\t@Consumes(MediaType.APPLICATION_JSON)\n\t@Produces(\"application/json;charset=UTF-8\")\n\tpublic String sayHelloWorld(){\n\t\treturn \"Hello ZY!!!大苏打\";\n\t}\n}\n\n```\n\n————这是一个简单的获取资源，使用GET方式获取，屏幕输出     Hello ZY!!!大苏打 。\n\n资源类是一个简单的 Java 对象 (POJO)，可以实现任何接口，简单、可重用性强。\n资源类上的常用注解有：\n@Path，标注资源类或者方法的相对路径\n@GET，@PUT，@POST，@DELETE，标注方法是HTTP请求的类型。\n@Produces，标注返回的MIME媒体类型\n@Consumes，标注可接受请求的MIME媒体类型\n@PathParam，@QueryParam，@HeaderParam，@CookieParam，@MatrixParam，@FormParam\n分别标注方法的参数来自于HTTP请求的不同位置，例如\n@PathParam来自于URL的路径，\n@QueryParam来自于URL的查询参数，\n@HeaderParam来自于HTTP请求的头信息，\n@CookieParam来自于HTTP请求的Cookie。\n##**总结：以上就是一个简单的Jersey框架搭建过程，其中涉及到的很多东西这里没有详细解释，日后深入理解再详谈。**\n","tags":["Jersey"],"categories":["技术"]}]